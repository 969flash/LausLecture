Help on module ghpythonlib.components in ghpythonlib:

NAME
    ghpythonlib.components

CLASSES
    System.Object(builtins.object)
        IEnumerator__namedtupleiterator(System.Object, clr._extras.collections.IteratorMixin)
    builtins.object
        namespace_object
    clr._extras.collections.IteratorMixin(collections.abc.Iterator)
        IEnumerator__namedtupleiterator(System.Object, clr._extras.collections.IteratorMixin)
    
    namedtupleiterator = class IEnumerator__namedtupleiterator(System.Object, clr._extras.collections.IteratorMixin)
     |  Void .ctor()
     |  
     |  Method resolution order:
     |      IEnumerator__namedtupleiterator
     |      System.Object
     |      clr._extras.collections.IteratorMixin
     |      collections.abc.Iterator
     |      collections.abc.Iterable
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  MoveNext(self)
     |  
     |  Reset(self)
     |  
     |  __eq__(self, value, /)
     |      Return self==value.
     |  
     |  __ge__(self, value, /)
     |      Return self>=value.
     |  
     |  __gt__(self, value, /)
     |      Return self>value.
     |  
     |  __hash__(self, /)
     |      Return hash(self).
     |  
     |  __init__(self, namedtuple)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __iter__(self, /)
     |      Implement iter(self).
     |  
     |  __le__(self, value, /)
     |      Return self<=value.
     |  
     |  __lt__(self, value, /)
     |      Return self<value.
     |  
     |  __ne__(self, value, /)
     |      Return self!=value.
     |  
     |  get_Current(self)
     |  
     |  ----------------------------------------------------------------------
     |  Static methods defined here:
     |  
     |  __new__(*args, **kwargs) from clr._internal.CLRMetatype
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __pyobj__
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  Equals = <unbound method 'Equals'>
     |  
     |  Finalize = <unbound method 'Finalize'>
     |  
     |  GetHashCode = <unbound method 'GetHashCode'>
     |  
     |  Overloads = <unbound method '__init__'>
     |  
     |  ToString = <unbound method 'ToString'>
     |  
     |  __namespace__ = 'ghpythonlib.components'
     |  
     |  __overloads__ = <unbound method '__init__'>
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from System.Object:
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from System.Object:
     |  
     |  GetType = <unbound method 'GetType'>
     |  
     |  MemberwiseClone = <unbound method 'MemberwiseClone'>
     |  
     |  ReferenceEquals = <unbound method 'ReferenceEquals'>
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from clr._extras.collections.IteratorMixin:
     |  
     |  close(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from clr._extras.collections.IteratorMixin:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from clr._extras.collections.IteratorMixin:
     |  
     |  __abstractmethods__ = frozenset({'__next__'})
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from collections.abc.Iterator:
     |  
     |  __next__(self)
     |      Return the next item from the iterator. When exhausted, raise StopIteration
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from collections.abc.Iterator:
     |  
     |  __subclasshook__(C) from clr._internal.CLRMetatype
     |      Abstract classes can override this to customize issubclass().
     |      
     |      This is invoked early on by abc.ABCMeta.__subclasscheck__().
     |      It should return True, False or NotImplemented.  If it returns
     |      NotImplemented, the normal algorithm is used.  Otherwise, it
     |      overrides the normal algorithm (and the outcome is cached).
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from collections.abc.Iterable:
     |  
     |  __class_getitem__ = GenericAlias(...) from clr._internal.CLRMetatype
     |      Represent a PEP 585 generic type
     |      
     |      E.g. for t = list[int], t.__origin__ is list and t.__args__ is (int,).
    
    class namespace_object(builtins.object)
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)

FUNCTIONS
    Absolute(*args, **kwargs)
        Compute the absolute of a value.
        Input:
                value [Generic Data] - Input value
        Returns: [Generic Data] - Output value
    
    Addition(*args, **kwargs)
        Mathematical addition
        Input:
                a (in, optional) [Generic Data] - First item for addition
                b (in, optional) [Generic Data] - Second item for addition
        Returns: [Generic Data] - Result of addition
    
    AdjustPlane(*args, **kwargs)
        Adjust a plane to match a new normal direction
        Input:
                plane [Plane] - Plane to adjust
                normal [Vector] - New plane z-axis direction
        Returns: [Plane] - Adjusted plane
    
    AlignFaces(*args, **kwargs)
        Align faces of a pair of rigid bodies
        Input:
                planea (in, optional) [Plane] - The frame of one rigid body
                planeb (in, optional) [Plane] - The frame of the other rigid body
                facea (in, optional) [Plane] - The plane on body A to align
                faceb (in, optional) [Plane] - The plane on body B to align
                flip [Boolean] - Reverse the relative direction of the planes
                strength [Number] - Strength
        Returns: [Generic Data] - A
    
    AlignPlane(*args, **kwargs)
        Perform minimal rotation to align a plane with a guide vector
        Input:
                plane [Plane] - Plane to straighten
                direction [Vector] - Straightening guide direction
        Returns:
                plane [Plane] - Straightened plane
                angle [Number] - Rotation angle
    
    AlignPlanes(*args, **kwargs)
        Align planes by minimizing their serial rotation.
        Input:
                planes [Plane] - Planes to align
                master (in, optional) [Plane] - Optional master plane (if omitted the first plane in P is the master plane).
        Returns: [Plane] - Aligned planes
    
    AlignVertices(*args, **kwargs)
        Align nearby vertices in a mesh
        Input:
                mesh [Mesh] - Mesh to align
                tolerance [Number] - Alignment tolerance
        Returns:
                result [Mesh] - Aligned mesh
                count [Integer] - Number of aligned vertices
    
    AlignedDimension(*args, **kwargs)
        Aligned Dimension
        Input:
                aligned_dimension (in, optional) [Linear Dimension] - The Rhino aligned dimension
                plane (in, optional) [Plane] - Plane that this annotation lies on.
                point_a (in, optional) [Point] - First dimension point
                point_b (in, optional) [Point] - Second dimension point
                offset (in, optional) [Number] - Offset for the base line.
                style (in, optional) [Model Annotation Style] - The annotation style.
        Returns:
                aligned_dimension [Linear Dimension] - The Rhino aligned dimension
                plane [Plane] - Plane that this annotation lies on.
                point_a [Point] - First dimension point
                point_b [Point] - Second dimension point
                offset [Number] - Offset for the base line.
                style [Model Annotation Style] - The annotation style.
    
    Amplitude(*args, **kwargs)
        Set the amplitude (length) of a vector.
        Input:
                vector [Vector] - Base vector
                amplitude [Number] - Amplitude (length) value
        Returns: [Vector] - Resulting vector
    
    Anchor(*args, **kwargs)
        Anchor
        Input:
                point (in, optional) [Point] - Point to anchor
                target (in, optional) [Point] - Location to pull the anchor to. If left empty, the initial location will be used.
                strength [Number] - Strength
        Returns: [Generic Data] - Anchor out
    
    AnchorXYZ(*args, **kwargs)
        Fix a point only along chosen world axes. If you need to reset the initial position, disconnect then reconnect the Point input.
        Input:
                point (in, optional) [Point] - Point to anchor
                x [Boolean] - True to prevent movement in the X direction
                y [Boolean] - True to prevent movement in the Y direction
                z [Boolean] - True to prevent movement in the Z direction
                strength [Number] - Strength
        Returns: [Generic Data] - Anchor XYZ out
    
    Angle(*args, **kwargs)
        Angle
        Input:
                linea (in, optional) [Line] - First line segment
                lineb (in, optional) [Line] - Second line segment
                restangle (in, optional) [Number] - RestAngle in radians - if none provided current angle will be used
                strength [Number] - Strength
        Returns: [Generic Data] - Angle out
    
    AngleDimensionArc(*args, **kwargs)
        Angle Dimension From Arcs
        Input:
                angle_dimension (in, optional) [Angular Dimension] - The Rhino anglular dimension
                arc (in, optional) [Arc] - Arc guide
                offset (in, optional) [Number] - Dimension offset
                style (in, optional) [Model Annotation Style] - The annotation style.
        Returns:
                angle_dimension [Angular Dimension] - The Rhino anglular dimension
                arc [Arc] - Arc guide
                offset [Number] - Dimension offset
                style [Model Annotation Style] - The annotation style.
    
    AngleDimensionLines(*args, **kwargs)
        Angle Dimension From Lines
        Input:
                angle_dimension (in, optional) [Angular Dimension] - The Rhino anglular dimension
                plane (in, optional) [Plane] - Plane that this annotation lies on.
                line_a (in, optional) [Line] - The line which defines the direction of the first leg of the angle.
                line_b (in, optional) [Line] - The line which defines the direction of the second leg of the angle.
                dimension_location (in, optional) [Point] - A point on the dimension arc.
                style (in, optional) [Model Annotation Style] - The annotation style.
        Returns:
                angle_dimension [Angular Dimension] - The Rhino anglular dimension
                plane [Plane] - Plane that this annotation lies on.
                line_a [Line] - The line which defines the direction of the first leg of the angle.
                line_b [Line] - The line which defines the direction of the second leg of the angle.
                dimension_location [Point] - A point on the dimension arc.
                style [Model Annotation Style] - The annotation style.
    
    AngleDimensionPoints(*args, **kwargs)
        Angle Dimension
        Input:
                angle_dimension (in, optional) [Angular Dimension] - The Rhino anglular dimension
                center (in, optional) [Point] - Angle center point
                point_a (in, optional) [Point] - End of the first angle direction
                point_b (in, optional) [Point] - End of the second angle direction
                dimension_location (in, optional) [Point] - A point on the dimension line.
                style (in, optional) [Model Annotation Style] - The annotation style.
        Returns:
                angle_dimension [Angular Dimension] - The Rhino anglular dimension
                center [Point] - Angle center point
                point_a [Point] - End of the first angle direction
                point_b [Point] - End of the second angle direction
                dimension_location [Point] - A point on the dimension line.
                style [Model Annotation Style] - The annotation style.
    
    AngleSnap(*args, **kwargs)
        Snap the angle between 2 lines to the closest whole number multiple of a given value
        Input:
                linea (in, optional) [Line] - First line segment
                lineb (in, optional) [Line] - Second line segment
                factor (in, optional) [Number] - Angle will become an integer multiple of this value (in radians)
                strength [Number] - Strength
        Returns: [Generic Data] - Angle out
    
    AngularDimension(*args, **kwargs)
        Create an angle annotation between points.
        Input:
                center [Point] - Angle centre point
                point_a [Point] - End of first angle direction
                point_b [Point] - End of second angle direction
                reflex [Boolean] - Create dimension for reflex angle
                text [Text] - Dimension text
                size [Number] - Dimension size
    
    AngularDimensionsMesh(*args, **kwargs)
        Create angle annotations for all mesh corners.
        Input:
                mesh [Mesh] - Mesh to annotate
                text [Text] - Dimension text
                size [Number] - Dimension size
                length_factor [Number] - Radius of dimension as part of edge length.
                minimum_angle (in, optional) [Number] - Threshold angle below which dimensions are not drawn.
                maximum_angle (in, optional) [Number] - Threshold angle above which dimensions are not drawn.
    
    AnnotationArrowSettings(*args, **kwargs)
        Annotation Style Arrow Settings
        Input:
                arrow_settings (in, optional) [Annotation Arrow Settings] - Arrow Settings
                arrow_1 (in, optional) [Arrow Type] - Arrow 1
                arrow_2 (in, optional) [Arrow Type] - Arrow 2
                arrow_size (in, optional) [Number] - Arrow Size
                fit_arrow (in, optional) [Integer] - Fit arrow: 
        0) Auto - Display when space permits
        1) Force arrows inside extensions
        2) Force arrows outside extensions
                dimension_inline (in, optional) [Boolean] - Draw dimension line between extension lines if arrows are outside
                leader_arrow (in, optional) [Arrow Type] - Leader Arrow
                leader_arrow_size (in, optional) [Number] - Leader Arrow Size
        Returns:
                arrow_settings [Annotation Arrow Settings] - Arrow Settings
                arrow_1 [Arrow Type] - Arrow 1
                arrow_2 [Arrow Type] - Arrow 2
                arrow_size [Number] - Arrow Size
                fit_arrow [Integer] - Fit arrow: 
        0) Auto - Display when space permits
        1) Force arrows inside extensions
        2) Force arrows outside extensions
                dimension_inline [Boolean] - Draw dimension line between extension lines if arrows are outside
                leader_arrow [Arrow Type] - Leader Arrow
                leader_arrow_size [Number] - Leader Arrow Size
    
    AnnotationDimensionSettings(*args, **kwargs)
        Annotation Style Dimension Settings
        Input:
                dimension_settings (in, optional) [Dimension Settings] - Dimension Settings
                view_oriented (in, optional) [Boolean] - Text orientated to view
                text_location (in, optional) [Integer] - Text location: 
        0) Text is above dimension line
        1) Text is centered in dimension line
        2) Text is below dimension line
                text_rotation (in, optional) [Integer] - Text rotation: 
        0) Text is horizontal in the annotation object's plane
        1) Text is aligned with last leader direction or dimension line
        2) Text is rotated using an explicit angle
                radial_view_oriented (in, optional) [Boolean] - Radial text orientation horizontal to view
                radial_text_location (in, optional) [Integer] - Radial text location: 
        0) Text is above dimension line
        1) Text is centered in dimension line
        2) Text is below dimension line
                radial_text_rotation (in, optional) [Integer] - Radial text rotation: 
        0) Text is horizontal in the annotation object's plane
        1) Text is aligned with last leader direction or dimension line
        2) Text is rotated using an explicit angle
                dimension_line_extension (in, optional) [Number] - Dimension line extension
                extension_line_extension (in, optional) [Number] - Extension line extension
                extension_line_offset (in, optional) [Number] - Extension line offset
                fixed_extension (in, optional) [Boolean] - Enable fixed length extension
                fixed_extension_length (in, optional) [Number] - Fixed extension length
                suppress_extension_1 (in, optional) [Boolean] - Suppress extension 1
                suppress_extension_2 (in, optional) [Boolean] - Suppress extension 2
                baseline_spacing (in, optional) [Number] - Baseline spacing
                centermark_size (in, optional) [Number] - Centermark size
                centermark_type (in, optional) [Integer] - Centermark type: 
        0) No centermark display
        1) Mark only
        2) Mark and lines to radius
                decimal_separator (in, optional) [Text] - Decimal separator
        Returns:
                dimension_settings [Dimension Settings] - Dimension Settings
                view_oriented [Boolean] - Text orientated to view
                text_location [Integer] - Text location: 
        0) Text is above dimension line
        1) Text is centered in dimension line
        2) Text is below dimension line
                text_rotation [Integer] - Text rotation: 
        0) Text is horizontal in the annotation object's plane
        1) Text is aligned with last leader direction or dimension line
        2) Text is rotated using an explicit angle
                radial_view_oriented [Boolean] - Radial text orientation horizontal to view
                radial_text_location [Integer] - Radial text location: 
        0) Text is above dimension line
        1) Text is centered in dimension line
        2) Text is below dimension line
                radial_text_rotation [Integer] - Radial text rotation: 
        0) Text is horizontal in the annotation object's plane
        1) Text is aligned with last leader direction or dimension line
        2) Text is rotated using an explicit angle
                dimension_line_extension [Number] - Dimension line extension
                extension_line_extension [Number] - Extension line extension
                extension_line_offset [Number] - Extension line offset
                fixed_extension [Boolean] - Enable fixed length extension
                fixed_extension_length [Number] - Fixed extension length
                suppress_extension_1 [Boolean] - Suppress extension 1
                suppress_extension_2 [Boolean] - Suppress extension 2
                baseline_spacing [Number] - Baseline spacing
                centermark_size [Number] - Centermark size
                centermark_type [Integer] - Centermark type: 
        0) No centermark display
        1) Mark only
        2) Mark and lines to radius
                decimal_separator [Text] - Decimal separator
    
    AnnotationDot(*args, **kwargs)
        Annotation Dot
        Input:
                annotation_dot (in, optional) [Text Dot] - The Rhino annotation dot
                location (in, optional) [Point] - Location of the annotation dot
                primary_text (in, optional) [Text] - Primary text to be displayed in the annotation dot
                text_height (in, optional) [Integer] - Text Height
        Returns:
                annotation_dot [Text Dot] - The Rhino annotation dot
                location [Point] - Location of the annotation dot
                primary_text [Text] - Primary text to be displayed in the annotation dot
                text_height [Integer] - Text Height
    
    AnnotationLeaderSettings(*args, **kwargs)
        Annotation Style Leader Settings
        Input:
                leader_settings (in, optional) [Leader Settings] - Leader Settings
                leader_curve_type (in, optional) [Integer] - Leader curve type: 
        0) None
        1) Polyline
        2) Spline
                has_landing (in, optional) [Boolean] - Has landing
                landing_length (in, optional) [Number] - Landing length
                view_oriented (in, optional) [Boolean] - Text orientated to view
                horizontal_text_alignment (in, optional) [Integer] - Horizontal text alignment: 
        0) Left - Attach at left of text lines (Independent of glyphs being displayed)
        1) Center - Attach point at center of text horizontal advance (not glyph bounding box)
        2) Right - Attach point at right text horizontal advance (not glyph bounding box)
        3) Auto - Used for Leaders only. Attach point adjusts to Right or Left depending on leader tail direction in view
        If tail direction is to the Left, alignment is Right. If tail direction is to the Right, alignment is Left.
                vertical_text_alignment (in, optional) [Integer] - Vertical text alignment: 
        0) Top - Attach to top of an "I" on the first line. (Independent of glyphs being displayed)
        1) Middle of first line - Attach to middle of an "I" on the first line. (Independent of glyphs being displayed)
        2) Bottom of first line - Attach to baseline of first line. (Independent of glyphs being displayed)
        3) Middle - Attach to middle of text vertical advance. (Independent of glyphs being displayed)
        4) Middle of last line - Attach to the basline of the last line. (Independent of glyphs being displayed)
        5) Bottom - Attach to the basline of the last line. (Independent of glyphs being displayed)
        6) Bottom of bounding box - Attach to the bottom of the bounding box of the visible glyphs
        
                leader_text_orientation (in, optional) [Integer] - Text orientation: 
        0) Horizontal - Text is horizontal in the annotation object's plane
        1) Aligned - Text is aligned with last leader direction or dimension line
        2) Custom - Text is rotated using an explicit angle
        Returns:
                leader_settings [Leader Settings] - Leader Settings
                leader_curve_type [Integer] - Leader curve type: 
        0) None
        1) Polyline
        2) Spline
                has_landing [Boolean] - Has landing
                landing_length [Number] - Landing length
                view_oriented [Boolean] - Text orientated to view
                horizontal_text_alignment [Integer] - Horizontal text alignment: 
        0) Left - Attach at left of text lines (Independent of glyphs being displayed)
        1) Center - Attach point at center of text horizontal advance (not glyph bounding box)
        2) Right - Attach point at right text horizontal advance (not glyph bounding box)
        3) Auto - Used for Leaders only. Attach point adjusts to Right or Left depending on leader tail direction in view
        If tail direction is to the Left, alignment is Right. If tail direction is to the Right, alignment is Left.
                vertical_text_alignment [Integer] - Vertical text alignment: 
        0) Top - Attach to top of an "I" on the first line. (Independent of glyphs being displayed)
        1) Middle of first line - Attach to middle of an "I" on the first line. (Independent of glyphs being displayed)
        2) Bottom of first line - Attach to baseline of first line. (Independent of glyphs being displayed)
        3) Middle - Attach to middle of text vertical advance. (Independent of glyphs being displayed)
        4) Middle of last line - Attach to the basline of the last line. (Independent of glyphs being displayed)
        5) Bottom - Attach to the basline of the last line. (Independent of glyphs being displayed)
        6) Bottom of bounding box - Attach to the bottom of the bounding box of the visible glyphs
        
                leader_text_orientation [Integer] - Text orientation: 
        0) Horizontal - Text is horizontal in the annotation object's plane
        1) Aligned - Text is aligned with last leader direction or dimension line
        2) Custom - Text is rotated using an explicit angle
    
    AnnotationStyle(*args, **kwargs)
        Annotation Style
        Input:
                annotation_style (in, optional) [Model Annotation Style] - The Rhino model annotation style.
                name (in, optional) [Text] - Annotation Style Name
                model_scale (in, optional) [Number] - Model space scale
                text_settings (in, optional) [Text Settings] - Text Settings
                dimension_settings (in, optional) [Dimension Settings] - Dimension Settings
                arrow_settings (in, optional) [Annotation Arrow Settings] - Arrow Settings
                units_settings (in, optional) [Units Settings] - Units Settings
                leader_settings (in, optional) [Leader Settings] - Leader Settings
                tolerance_settings (in, optional) [Tolerance Settings] - Tolerance Settings
        Returns:
                annotation_style [Model Annotation Style] - The Rhino model annotation style.
                name [Text] - Annotation Style Name
                model_scale [Number] - Model space scale
                text_settings [Text Settings] - Text Settings
                dimension_settings [Dimension Settings] - Dimension Settings
                arrow_settings [Annotation Arrow Settings] - Arrow Settings
                units_settings [Units Settings] - Units Settings
                leader_settings [Leader Settings] - Leader Settings
                tolerance_settings [Tolerance Settings] - Tolerance Settings
    
    AnnotationStyleOverrides(*args, **kwargs)
        Get-Set annotation style and overridden attributes
        Input:
                annotation [Geometry] - The annotation
                style (in, optional) [Model Annotation Style] - The annotation style.
                model_scale (in, optional) [Number] - Model space scale
                text_settings (in, optional) [Text Settings] - Text settings overrides applied to the annotation
                dimension_settings (in, optional) [Dimension Settings] - Dimension settings overrides applied to the annotation
                arrow_settings (in, optional) [Annotation Arrow Settings] - Arrow settings overrides applied to the annotation
                units_settings (in, optional) [Units Settings] - Units settings overrides applied to the annotation
                leader_settings (in, optional) [Leader Settings] - Leader settings overrides applied to the annotation
                tolerance_settings (in, optional) [Tolerance Settings] - Tolerance settings overrides applied to the annotation
        Returns:
                annotation [Geometry] - The annotation
                style [Model Annotation Style] - The annotation style.
                model_scale [Number] - Model space scale
                text_settings [Text Settings] - Text settings overrides applied to the annotation
                dimension_settings [Dimension Settings] - Dimension settings overrides applied to the annotation
                arrow_settings [Annotation Arrow Settings] - Arrow settings overrides applied to the annotation
                units_settings [Units Settings] - Units settings overrides applied to the annotation
                leader_settings [Leader Settings] - Leader settings overrides applied to the annotation
                tolerance_settings [Tolerance Settings] - Tolerance settings overrides applied to the annotation
    
    AnnotationTextOverrides(*args, **kwargs)
        Manage annotation text attributes
        Input:
                annotation [Geometry] - The annotation
                text (in, optional) [Text] - Text to be displayed in the annotation
                view_oriented (in, optional) [Boolean] - Display annotation text oriented always to view
        Returns:
                annotation [Geometry] - The annotation
                text [Text] - Text displayed in the annotation
                view_oriented [Boolean] - Display annotation text oriented always to view
    
    AnnotationTextSettings(*args, **kwargs)
        Annotation Style Text Settings
        Input:
                text_settings (in, optional) [Text Settings] - Text Settings
                font (in, optional) [Font] - Typography font
                text_height (in, optional) [Number] - Text Height
                text_gap (in, optional) [Number] - Text Gap
                mask (in, optional) [Integer] - Mask: 
        0) None
        1) Background
        2) Solid Color
        
                mask_colour (in, optional) [Colour] - Mask Colour
                mask_margins (in, optional) [Number] - Mask Margins
                mask_frame (in, optional) [Integer] - Mask frame: 
        0) None
        1) Rectangular
        2) Capsule
        
                view_oriented (in, optional) [Boolean] - Text orientated to view
                draw_forward (in, optional) [Boolean] - Text reads forward when viewed from behind
                horizontal_alignment (in, optional) [Integer] - Horizontal text alignment: 
        0) Left - Attach at left of text lines (Independent of glyphs being displayed)
        1) Center - Attach point at center of text horizontal advance (not glyph bounding box)
        2) Right - Attach point at right text horizontal advance (not glyph bounding box)
        3) Auto - Used for Leaders only. Attach point adjusts to Right or Left depending on leader tail direction in view
        If tail direction is to the Left, alignment is Right. If tail direction is to the Right, alignment is Left.
                vertical_alignment (in, optional) [Integer] - Vertical text alignment: 
        0) Top - Attach to top of an "I" on the first line. (Independent of glyphs being displayed)
        3) Middle - Attach to middle of text vertical advance. (Independent of glyphs being displayed)
        5) Bottom - Attach to the basline of the last line. (Independent of glyphs being displayed.)
        
                fit_text (in, optional) [Integer] - Fit text: 
        0) Auto - Display inside when space permits
        1) Text Inside - Force text inside extensions
        2) Text Right - Force text outside to the right of extensions
        3) Text Left - Force text outside to the left of extensions
        4) Text Hint Right - Move text outside to the right of extensions when it won't fit inside
        5) Text Hint Left - Move text outside to the left of extensions when it won't fit inside
        
        Returns:
                text_settings [Text Settings] - Text Settings
                font [Font] - Typography font
                text_height [Number] - Text Height
                text_gap [Number] - Text Gap
                mask [Integer] - Mask: 
        0) None
        1) Background
        2) Solid Color
        
                mask_colour [Colour] - Mask Colour
                mask_margins [Number] - Mask Margins
                mask_frame [Integer] - Mask frame: 
        0) None
        1) Rectangular
        2) Capsule
        
                view_oriented [Boolean] - Text orientated to view
                draw_forward [Boolean] - Text reads forward when viewed from behind
                horizontal_alignment [Integer] - Horizontal text alignment: 
        0) Left - Attach at left of text lines (Independent of glyphs being displayed)
        1) Center - Attach point at center of text horizontal advance (not glyph bounding box)
        2) Right - Attach point at right text horizontal advance (not glyph bounding box)
        3) Auto - Used for Leaders only. Attach point adjusts to Right or Left depending on leader tail direction in view
        If tail direction is to the Left, alignment is Right. If tail direction is to the Right, alignment is Left.
                vertical_alignment [Integer] - Vertical text alignment: 
        0) Top - Attach to top of an "I" on the first line. (Independent of glyphs being displayed)
        3) Middle - Attach to middle of text vertical advance. (Independent of glyphs being displayed)
        5) Bottom - Attach to the basline of the last line. (Independent of glyphs being displayed.)
        
                fit_text [Integer] - Fit text: 
        0) Auto - Display inside when space permits
        1) Text Inside - Force text inside extensions
        2) Text Right - Force text outside to the right of extensions
        3) Text Left - Force text outside to the left of extensions
        4) Text Hint Right - Move text outside to the right of extensions when it won't fit inside
        5) Text Hint Left - Move text outside to the left of extensions when it won't fit inside
    
    AnnotationToleranceSettings(*args, **kwargs)
        Annotation Style Tolerance Settings
        Input:
                tolerance_settings (in, optional) [Tolerance Settings] - Tolerance Settings
                tolerance_format (in, optional) [Integer] - Tolerance format: 
        0) None - no tolerance display
        1) Symmetrical - symmetrical +/- tolerance
        2) Deviation - distance +tol, -tol
        3) Limits - distance with upper and lower limits
        
                tolerance_resolution (in, optional) [Integer] - Tolerance resolution
                alt._tolerance_resolution (in, optional) [Integer] - Alternate tolerance resolution
                tolerance_upper_value (in, optional) [Number] - Tolerance upper value
                tolerance_lower_value (in, optional) [Number] - Tolerance lower value
                tolerance_height_scale (in, optional) [Number] - Tolerance height scale (percentage)
        Returns:
                tolerance_settings [Tolerance Settings] - Tolerance Settings
                tolerance_format [Integer] - Tolerance format: 
        0) None - no tolerance display
        1) Symmetrical - symmetrical +/- tolerance
        2) Deviation - distance +tol, -tol
        3) Limits - distance with upper and lower limits
        
                tolerance_resolution [Integer] - Tolerance resolution
                alt._tolerance_resolution [Integer] - Alternate tolerance resolution
                tolerance_upper_value [Number] - Tolerance upper value
                tolerance_lower_value [Number] - Tolerance lower value
                tolerance_height_scale [Number] - Tolerance height scale (percentage)
    
    AnnotationUnitsSettings(*args, **kwargs)
        Annotation Style Units Settings
        Input:
                units_settings (in, optional) [Units Settings] - Units Settings
                length_units_format (in, optional) [Integer] - Length units format: 
        0) Decimal model units
        1) Fractional inches
        2) Fractional feet and inches
        3) Decimal millimeters
        4) Decimal centimeters
        5) Decimal meters
        6) Decimal kilometers
        7) Decimal inches
        8) Decimal feet
        9) Decimal miles
                length_factor (in, optional) [Number] - Length factor
                linear_resolution (in, optional) [Integer] - Linear resolution
                roundoff (in, optional) [Number] - Roundoff
                prefix (in, optional) [Text] - Prefix
                suffix (in, optional) [Text] - Suffix
                zero_suppression (in, optional) [Integer] - Angle zero suppression: 
        0) No zero suppression
        1) Suppress leading zeros
        2) Suppress trailing zeros
        3) Suppress leading and trailing zeros
        4) Suppress zero feet
        8) Suppress zero inches.
        12) Suppress zero feet and zero inches
                fraction_format (in, optional) [Integer] - Fraction format: 
        0) No stacking
        1) Stack with horizontal line
        2) Stack with angled line
                fraction_height_scale (in, optional) [Number] - Fraction height scale (percentage)
                angular_units_format (in, optional) [Integer] - Angular units format: 
        0) Decimal degrees
        1) Degrees minutes seconds
        2) Decimal radians
        3) Decimal gradians
                angle_resolution (in, optional) [Integer] - Angle resolution
                angle_roundoff (in, optional) [Number] - Roundoff
                angle_zero_suppression (in, optional) [Integer] - Angle zero suppression: 
        0) No zero suppression
        1) Suppress leading zeros
        2) Suppress trailing zeros
        3) Suppress leading and trailing zeros
        4) Suppress zero feet
        8) Suppress zero inches.
        12) Suppress zero feet and zero inches
        Returns:
                units_settings [Units Settings] - Units Settings
                length_units_format [Integer] - Length units format: 
        0) Decimal model units
        1) Fractional inches
        2) Fractional feet and inches
        3) Decimal millimeters
        4) Decimal centimeters
        5) Decimal meters
        6) Decimal kilometers
        7) Decimal inches
        8) Decimal feet
        9) Decimal miles
                length_factor [Number] - Length factor
                linear_resolution [Integer] - Linear resolution
                roundoff [Number] - Roundoff
                prefix [Text] - Prefix
                suffix [Text] - Suffix
                zero_suppression [Integer] - Angle zero suppression: 
        0) No zero suppression
        1) Suppress leading zeros
        2) Suppress trailing zeros
        3) Suppress leading and trailing zeros
        4) Suppress zero feet
        8) Suppress zero inches.
        12) Suppress zero feet and zero inches
                fraction_format [Integer] - Fraction format: 
        0) No stacking
        1) Stack with horizontal line
        2) Stack with angled line
                fraction_height_scale [Number] - Fraction height scale (percentage)
                angular_units_format [Integer] - Angular units format: 
        0) Decimal degrees
        1) Degrees minutes seconds
        2) Decimal radians
        3) Decimal gradians
                angle_resolution [Integer] - Angle resolution
                angle_roundoff [Number] - Roundoff
                angle_zero_suppression [Integer] - Angle zero suppression: 
        0) No zero suppression
        1) Suppress leading zeros
        2) Suppress trailing zeros
        3) Suppress leading and trailing zeros
        4) Suppress zero feet
        8) Suppress zero inches.
        12) Suppress zero feet and zero inches
    
    Arc(*args, **kwargs)
        Create an arc defined by base plane, radius and angle domain.
        Input:
                plane [Plane] - Base plane of arc
                radius [Number] - Radius of arc
                angle [Domain] - Angle domain in radians
        Returns:
                arc [Arc] - Resulting arc
                length [Number] - Arc length
    
    Arc3Pt(*args, **kwargs)
        Create an arc through three points.
        Input:
                point_a [Point] - Start point of arc
                point_b [Point] - Point on arc interior
                point_c [Point] - End point of arc
        Returns:
                arc [Geometry] - Resulting arc
                plane [Plane] - Arc plane
                radius [Number] - Arc radius
    
    ArcCosine(*args, **kwargs)
        Compute the angle whose cosine is the specified value.
        Input:
                value [Generic Data] - Input value
        Returns: [Generic Data] - Output value
    
    ArcDimension(*args, **kwargs)
        Create an angle annotation based on an arc.
        Input:
                arc [Arc] - Arc guide
                offset [Number] - Dimension offset
                text [Text] - Dimension text
                size [Number] - Dimension size
    
    ArcSED(*args, **kwargs)
        Create an arc defined by start point, end point and a tangent vector.
        Input:
                start [Point] - Start point of arc
                end [Point] - End point of arc
                direction [Vector] - Direction (tangent) at start
        Returns:
                arc [Geometry] - Resulting arc
                plane [Plane] - Arc plane
                radius [Number] - Arc radius
    
    ArcSine(*args, **kwargs)
        Compute the angle whose sine is the specified value.
        Input:
                value [Generic Data] - Input value
        Returns: [Generic Data] - Output value
    
    ArcTangent(*args, **kwargs)
        Compute the angle whose tangent is the specified value.
        Input:
                value [Generic Data] - Input value
        Returns: [Generic Data] - Output value
    
    Area(*args, **kwargs)
        Solve area properties for breps, meshes and planar closed curves.
        Input:
                geometry [Geometry] - Brep, mesh or planar closed curve for area computation
        Returns:
                area [Number] - Area of geometry
                centroid [Point] - Area centroid of geometry
    
    AreaMoments(*args, **kwargs)
        Solve area moments for breps, meshes and planar closed curves.
        Input:
                geometry [Geometry] - Brep, mesh or planar closed curve for area computation
        Returns:
                area [Number] - Area of geometry
                centroid [Point] - Volume centroid of geometry
                inertia [Vector] - Moments of inertia around the centroid
                secondary [Vector] - Secondary moments of inertia around the centroid
                gyration [Vector] - Radii of gyration
    
    AtomData(*args, **kwargs)
        Get detailed information for an atom
        Input:
                atom [Atom] - Atom to evaluate
        Returns:
                point [Point] - Location of atom
                element [Text] - Element name of atom
                chain [Text] - Chain ID to which this atom belongs
                residue [Text] - Residue name to which this atom belongs
                charge [Integer] - Charge of this atom
                occupancy [Number] - Occupancy of this atom
                temperature [Number] - Temperature factor of this atom
                atomic_number [Integer] - Atomic number of atom
                serial_number [Integer] - Atom serial number
                residue_number [Integer] - Residue serial number
    
    Average(*args, **kwargs)
        Solve the arithmetic average for a set of items
        Input:
                input [Generic Data] - Input values for averaging
        Returns: [Generic Data] - Arithmetic mean (average) of all input values
    
    Barycentric(*args, **kwargs)
        Create a point from barycentric {u,v,w} coordinates
        Input:
                point_a [Point] - First anchor point
                point_b [Point] - Second anchor point
                point_c [Point] - Third anchor point
                coordinate_u [Number] - First barycentric coordinate
                coordinate_v [Number] - Second barycentric coordinate
                coordinate_w [Number] - Third barycentric coordinate
        Returns: [Point] - Barycentric point coordinate
    
    Beam(*args, **kwargs)
        Beam resisting bending and torsion
        Input:
                startframe (in, optional) [Plane] - The plane at one end of the beam, its Z axis aligned with the beam direction
                endframe (in, optional) [Plane] - Should be parallel to StartFrame
                startnode (in, optional) [Plane] - The plane defining the node the start of the beam attaches to. If none supplied this defaults to XY aligned
                endnode (in, optional) [Plane] - The plane defining the node the end of the beam attaches to. If none supplied this defaults to XY aligned
                e [Number] - Young's Modulus
                a [Number] - Cross-section area
                ix [Number] - 2nd moment of area about X
                iy [Number] - 2nd moment of area about Y
                gj [Number] - Shear modulus * torsional constant
        Returns: [Generic Data] - B
    
    BendDeform(*args, **kwargs)
        Deform a shape by bending it
        Input:
                geometry [Geometry] - Geometry to deform
                bending_arc [Arc] - Bending arc segment
        Returns: [Geometry] - Deformed geometry
    
    BezierSpan(*args, **kwargs)
        Construct a bezier span from endpoints and tangents.
        Input:
                start_point [Point] - Start of curve
                start_tangent [Vector] - Tangent at start
                end_point [Point] - End of curve
                end_tangent [Vector] - Tangent at end
        Returns:
                curve [Curve] - Resulting bezier span
                length [Number] - Curve length
                domain [Domain] - Curve domain
    
    BiArc(*args, **kwargs)
        Create a bi-arc based on endpoints and tangents.
        Input:
                start_point [Point] - Start point of bi-arc.
                start_tangent [Vector] - Tangent vector at start of bi-arc.
                end_point [Point] - End point of bi-arc.
                end_tangent [Vector] - Tangent vector at end of bi-arc.
                ratio [Number] - Ratio of bi-arc segment weight
        Returns:
                first_arc [Arc] - First segment of bi-arc curve
                second_arc [Arc] - Second segment of bi-arc curve
                bi-arc [Curve] - Resulting bi-arc.
    
    Bipartite(*args, **kwargs)
        Attempt to assign a boolean to each vertex of a mesh such that no connected vertices share the same value
        Input:
                mesh [Mesh] - Mesh
        Returns: [Integer] - Vertex assignments
    
    BlendBox(*args, **kwargs)
        Create a twisted box between two surfaces.
        Input:
                surface_a [Surface] - First surface
                domain_a [Domain²] - Domain on first surface
                surface_b [Surface] - Second surface
                domain_b [Domain²] - Domain on second surface
        Returns: [Twisted Box] - Resulting blend box
    
    BlendCurve(*args, **kwargs)
        Create a blend curve between two curves.
        Input:
                curve_a [Curve] - First curve for blend
                curve_b [Curve] - Second curve for blend
                bulge_a [Number] - Bulge factor at A
                bulge_b [Number] - Bulge factor at B
                continuity [Integer] - Continuity of blend (0=position, 1=tangency, 2=curvature)
        Returns: [Curve] - Blend curve connecting the end of A to the start of B
    
    BlendCurvePt(*args, **kwargs)
        Create a blend curve between two curves that intersects a point.
        Input:
                curve_a [Curve] - First curve for blend
                curve_b [Curve] - Second curve for blend
                point [Point] - Point for blend intersection
                continuity [Integer] - Continuity of blend (1=tangency, 2=curvature)
        Returns: [Curve] - Blend curve connecting the end of A to the start of B, ideally coincident with P
    
    BlurMesh(*args, **kwargs)
        Blur the colours on a mesh
        Input:
                mesh [Mesh] - Mesh to blur
                iterations [Integer] - Number of consecutive blurring iterations
        Returns: [Mesh] - Mesh with blurred vertex colours
    
    BlurNumbers(*args, **kwargs)
        Blur a list of numbers by averaging neighbours
        Input:
                numbers [Number] - Numbers to blur
                strength [Number] - Blurring strength (0=none, 1=full)
                iterations [Integer] - Number of successive blurring iterations
                lock [Boolean] - Lock first and last value
                wrap [Boolean] - Treat the list as a cyclical collection
        Returns: [Number] - Blurred numbers
    
    Bomb(*args, **kwargs)
        Causes an explosion after a given number of iterations
        Input:
                location (in, optional) [Point] - The point which will be the center of the explosion
                points (in, optional) [Point] - The points which will be affected by the explosion
                detonationtime [Integer] - The solver iteration at which the explosion will occur
                strength [Number] - Strength
                reset [Boolean] - Connect this to the same button you have connected to the Solver component reset input
        Returns: [Generic Data] - Bomb Goal
    
    BouncySolver(*args, **kwargs)
        Solver with momentum
        Input:
                goalobjects (in, optional) [Generic Data] - GoalObjects
                reset [Boolean] - Hard Reset (completely rebuild the particle list and indexing)
                threshold [Number] - Stop when average movement is less than this (default is 1e-15)
                tolerance [Number] - Points closer than this distance will be combined into a single particle
                damping [Number] - Value between 0 and 1, for how much velocity is preserved between iterations
                iterations [Integer] - This many internal iterations will be performed for each results output
                on [Boolean] - If true, Kangaroo will continue to iterate until reaching the given threshold value
        Returns:
                i [Integer] - Iterations
                v [Point] - V
                o [Generic Data] - GoalFunction Outputs
    
    BoundarySurfaces(*args, **kwargs)
        Create planar surfaces from a collection of boundary edge curves.
        Input:
                edges [Curve] - Boundary curves
        Returns: [Surface] - Resulting boundary surfaces
    
    BoundaryVolume(*args, **kwargs)
        Create a closed polysurface from boundary surfaces
        Input:
                boundaries [Brep] - Boundary surfaces
        Returns: [Brep] - Solid volume
    
    BoundingBox(*args, **kwargs)
        Solve oriented geometry bounding boxes.
        Input:
                content [Geometry] - Geometry to contain
                plane [Plane] - BoundingBox orientation plane
        Returns:
                box [Box] - Aligned bounding box in world coordinates
                box [Box] - Bounding box in orientation plane coordinates
    
    Bounds(*args, **kwargs)
        Create a numeric domain which encompasses a list of numbers.
        Input:
                numbers [Number] - Numbers to include in Bounds
        Returns: [Domain] - Numeric Domain between the lowest and highest numbers in {N}
    
    Bounds2D(*args, **kwargs)
        Create a numeric two-dimensional domain which encompasses a list of coordinates.
        Input:
                coordinates [Point] - Two dimensional coordinates to include in Bounds
        Returns: [Domain²] - Numeric two-dimensional domain between the lowest and highest numbers in {N.x ; N.y}
    
    Box2Pt(*args, **kwargs)
        Create a box defined by two points.
        Input:
                point_a [Point] - First corner
                point_b [Point] - Second corner
                plane [Plane] - Base plane
        Returns: [Box] - Resulting box
    
    BoxArray(*args, **kwargs)
        Create a box array of geometry.
        Input:
                geometry (in, optional) [Geometry] - Base geometry
                cell [Box] - 3D Box array cell
                x_count [Integer] - Number of elements in the array x-direction.
                y_count [Integer] - Number of elements in the array y-direction.
                z_count [Integer] - Number of elements in the array z-direction.
        Returns:
                geometry [Geometry] - Arrayed geometry
                transform [Transform] - Transformation data
    
    BoxCorners(*args, **kwargs)
        Extract all 8 corners of a box.
        Input:
                box [Box] - Base box
        Returns:
                corner_a [Point] - Corner at {x=min, y=min, z=min}
                corner_b [Point] - Corner at {x=max, y=min, z=min}
                corner_c [Point] - Corner at {x=max, y=max, z=min}
                corner_d [Point] - Corner at {x=min, y=max, z=min}
                corner_e [Point] - Corner at {x=min, y=min, z=max}
                corner_f [Point] - Corner at {x=max, y=min, z=max}
                corner_g [Point] - Corner at {x=max, y=max, z=max}
                corner_h [Point] - Corner at {x=min, y=max, z=max}
    
    BoxMapping(*args, **kwargs)
        Transform geometry from one box into another.
        Input:
                geometry (in, optional) [Geometry] - Base geometry
                source [Box] - Box to map from
                target [Box] - Box to map into
        Returns:
                geometry [Geometry] - Mapped geometry
                transform [Transform] - Transformation data
    
    BoxMorph(*args, **kwargs)
        Morph an object into a twisted box.
        Input:
                geometry [Geometry] - Base geometry
                reference [Box] - Reference box
                target [Twisted Box] - Target box
        Returns: [Geometry] - Translated geometry
    
    BoxProperties(*args, **kwargs)
        Get some properties of a box
        Input:
                box [Box] - Box to analyze
        Returns:
                center [Point] - Center point of box
                diagonal [Vector] - Diagonal vector of box
                area [Number] - Area of box
                volume [Number] - Volume of box
                degeneracy [Integer] - Degeneracy of box
    
    BoxRectangle(*args, **kwargs)
        Create a box defined by a rectangle and a height.
        Input:
                rectangle [Rectangle] - Base rectangle
                height [Domain] - Box height
        Returns: [Box] - Resulting box
    
    BoxSlits(*args, **kwargs)
        Add slits to a collection of intersecting boxes
        Input:
                boxes [Box] - Boxes to intersect
                gap [Number] - Additional gap width
        Returns:
                breps [Brep] - Boxes with slits
                topology [Integer] - Slit topology
    
    BreakField(*args, **kwargs)
        Break a field into individual elements
        Input:
                field [Field] - Field to break
        Returns: [Field] - Elemental fields
    
    BrepClosestPoint(*args, **kwargs)
        Find the closest point on a brep
        Input:
                point [Point] - Sample point
                brep [Brep] - Base Brep
        Returns:
                point [Point] - Closest point
                normal [Vector] - Normal direction at closest point
                distance [Number] - Distance between sample point and Brep
    
    BrepEdges(*args, **kwargs)
        Extract the edge curves of a brep.
        Input:
                brep [Brep] - Base Brep
        Returns:
                naked [Curve] - Naked edge curves
                interior [Curve] - Interior edge curves
                non-manifold [Curve] - Non-Manifold edge curves
    
    BrepJoin(*args, **kwargs)
        Join a number of Breps together
        Input:
                breps [Brep] - Breps to join
        Returns:
                breps [Brep] - Joined Breps
                closed [Boolean] - Closed flag for each resulting Brep
    
    BrepTopology(*args, **kwargs)
        Get and display the topology of a brep.
        Input:
                brep [Brep] - Base Brep
        Returns:
                face|face_adjacency [Integer] - For each face lists all faces that surround it.
                face|edge_adjacency [Integer] - For each face lists all edges that surround it.
                edge|face_adjacency [Integer] - for each edge lists all faces that surround it.
    
    BrepWireframe(*args, **kwargs)
        Extract the wireframe curves of a brep.
        Input:
                brep [Brep] - Base Brep
                density [Integer] - Wireframe isocurve density
        Returns: [Curve] - Wireframe curves
    
    BrepXBrep(*args, **kwargs)
        Solve intersection events for two Breps.
        Input:
                brep_a [Brep] - First Brep
                brep_b [Brep] - Second Brep
        Returns:
                curves [Curve] - Intersection curves
                points [Point] - Intersection points
    
    BrepXCurve(*args, **kwargs)
        Solve intersection events for a Brep and a curve.
        Input:
                brep [Brep] - Base Brep
                curve [Curve] - Intersection curve
        Returns:
                curves [Curve] - Intersection overlap curves
                points [Point] - Intersection points
    
    BrepXLine(*args, **kwargs)
        Solve intersection events for a Brep and a line.
        Input:
                brep [Brep] - Base Brep
                line [Line] - Intersection line
        Returns:
                curves [Curve] - Intersection overlap curves
                points [Point] - Intersection points
    
    BrepXPlane(*args, **kwargs)
        Solve intersection events for a Brep and a plane (otherwise known as section).
        Input:
                brep [Brep] - Base Brep
                plane [Plane] - Section plane
        Returns:
                curves [Curve] - Section curves
                points [Point] - Section points
    
    ByParent(*args, **kwargs)
        Refine a Mesh, separating outputs by parent face
        Input:
                mesh [Mesh] - Mesh to refine
                level [Integer] - Level of subdivision
        Returns: [Mesh] - Refined Meshes list
    
    CameraObscura(*args, **kwargs)
        Camera Obscura (point mirror) transformation.
        Input:
                geometry (in, optional) [Geometry] - Base geometry
                point [Point] - Mirror point
                factor [Number] - Scaling factor
        Returns:
                geometry [Geometry] - Mirrored geometry
                transform [Transform] - Transformation data
    
    CapHoles(*args, **kwargs)
        Cap all planar holes in a Brep.
        Input:
                brep [Brep] - Brep to cap
        Returns: [Brep] - Capped Brep
    
    CapHolesEx(*args, **kwargs)
        Cap as many holes as possible in a Brep.
        Input:
                brep [Brep] - Brep to cap
        Returns:
                brep [Brep] - Capped Brep
                caps [Integer] - Number of caps added
                solid [Boolean] - Value indicating whether capped brep is solid
    
    CarthesianProduct(*args, **kwargs)
        Create the Carthesian product for two sets of identical cardinality.
        Input:
                set_a [Generic Data] - First set for carthesian product.
                set_b [Generic Data] - Second set for carthesian product.
        Returns: [Generic Data] - Carthesian product of A and B.
    
    Catenary(*args, **kwargs)
        Create a catenary chain between two points.
        Input:
                point_a [Point] - Start point of catenary
                point_b [Point] - End point of catenary
                length [Number] - Length of catenary chain (should be larger than the distance |AB|)
                gravity [Vector] - Direction of gravity
        Returns: [Curve] - Catenary chain
    
    CenterBox(*args, **kwargs)
        Create a box centered on a plane.
        Input:
                base [Plane] - Base plane
                x [Number] - Size of box in {x} direction.
                y [Number] - Size of box in {y} direction.
                z [Number] - Size of box in {z} direction.
        Returns: [Box] - Resulting box
    
    Centermark(*args, **kwargs)
        Centermark
        Input:
                centermark (in, optional) [Radial Centermark] - The Rhino centermark
                plane (in, optional) [Plane] - Plane that this annotation lies on.
                curve (in, optional) [Curve] - The planar curve to assign the centermark.
                parameter (in, optional) [Number] - Parameter on the curve domain to mark the center from
                style (in, optional) [Model Annotation Style] - The annotation style.
        Returns:
                centermark [Radial Centermark] - The Rhino centermark
                plane [Plane] - Plane that this annotation lies on.
                center_point [Point] - The location of the centermark
                radius [Number] - The radius of the curve at the parameter
                style [Model Annotation Style] - The annotation style.
    
    Centroid(*args, **kwargs)
        Generate the triangle centroid from medians.
        Input:
                point_a [Point] - First triangle corner
                point_b [Point] - Second triangle corner
                point_c [Point] - Third triangle corner
        Returns:
                centroid [Point] - Centroid point for triangle
                median_ab [Line] - Median line connecting edge AB with corner C
                median_bc [Line] - Median line connecting edge BC with corner A
                median_ca [Line] - Median line connecting edge CA with corner B
    
    CharSequence(*args, **kwargs)
        Create a sequence of textual characters.
        Input:
                count [Integer] - Number of elements in the sequence.
                char_pool [Text] - Pool of characters available to the sequence.
                format (in, optional) [Text] - Optional formatting mask
        Returns: [Text] - Sequence of character tags
    
    Characters(*args, **kwargs)
        Break text into individual characters
        Input:
                text [Text] - Text to split.
        Returns:
                result [Text] - Resulting characters
                unicode [Integer] - Unicode value of character
    
    Checkerboard(*args, **kwargs)
        Attempt to assign a boolean to each face of a mesh such that no adjacent faces share the same value
        Input:
                mesh [Mesh] - Mesh to checkerboard
        Returns: [Integer] - Face assignments
    
    Circle(*args, **kwargs)
        Create a circle defined by base plane and radius.
        Input:
                plane [Plane] - Base plane of circle
                radius [Number] - Radius of circle
        Returns: [Circle] - Resulting circle
    
    Circle3Pt(*args, **kwargs)
        Create a circle defined by three points.
        Input:
                point_a [Point] - First point on circle
                point_b [Point] - Second point on circle
                point_c [Point] - Third point on circle
        Returns:
                circle [Circle] - Resulting circle
                plane [Plane] - Circle plane
                radius [Number] - Circle radius
    
    CircleCNR(*args, **kwargs)
        Create a circle defined by center, normal and radius.
        Input:
                center [Point] - Center point
                normal [Vector] - Normal vector of circle plane
                radius [Number] - Radius of circle
        Returns: [Circle] - Resulting circle
    
    CircleFit(*args, **kwargs)
        Fit a circle to a collection of points.
        Input:
                points [Point] - Points to fit
        Returns:
                circle [Circle] - Resulting circle
                radius [Number] - Circle radius
                deviation [Number] - Maximum distance between circle and points
    
    CircleTanTan(*args, **kwargs)
        Create a circle tangent to two curves.
        Input:
                curve_a [Curve] - First curve for tangency constraint
                curve_b [Curve] - Second curve for tangency constraint
                point [Point] - Circle center point guide
        Returns: [Circle] - Resulting circle
    
    CircleTanTanTan(*args, **kwargs)
        Create a circle tangent to three curves.
        Input:
                curve_a [Curve] - First curve for tangency constraint
                curve_b [Curve] - Second curve for tangency constraint
                curve_c [Curve] - Third curve for tangency constraint
                point [Point] - Circle center point guide
        Returns: [Circle] - Resulting circle
    
    CircularDimension(*args, **kwargs)
        Create an angle annotation projected to a circle.
        Input:
                circle [Circle] - Dimension guide circle
                point_a [Point] - First angle point
                point_b [Point] - Second angle point
                text [Text] - Dimension text
                size [Number] - Dimension size
    
    Circumcentre(*args, **kwargs)
        Generate the triangle circumcentre from perpendicular bisectors.
        Input:
                point_a [Point] - First triangle corner
                point_b [Point] - Second triangle corner
                point_c [Point] - Third triangle corner
        Returns:
                circumcentre [Point] - Circumcentre point for triangle
                bisector_ab [Line] - Perpendicular bisector line emanating from edge AB
                bisector_bc [Line] - Perpendicular bisector line emanating from edge AB
                bisector_ca [Line] - Perpendicular bisector line emanating from edge AB
    
    Clamp(*args, **kwargs)
        Restrict a number between two numeric extremes.
        Input:
                value [Generic Data] - Item to restrict between two numeric extremes
                domain [Domain] - Domain between two numberic extremes
        Returns: [Generic Data] - Clamped value
    
    ClampAngle(*args, **kwargs)
        Keep an angle between 2 lines within a given range
        Input:
                linea (in, optional) [Line] - First line segment
                lineb (in, optional) [Line] - Second line segment
                upperlimit [Number] - Maximum allowed angle in radians
                lowerlimit [Number] - Minimum allowed angle in radians
                strength [Number] - Strength
        Returns: [Generic Data] - ClampAngle out
    
    ClampLength(*args, **kwargs)
        Keep length within given bounds
        Input:
                line (in, optional) [Curve] - Line
                lowerlimit (in, optional) [Number] - Length will be kept above this length
                upperlimit (in, optional) [Number] - Length will be kept below this length
                strength [Number] - Strength
        Returns: [Generic Data] - Clamp
    
    Clash(*args, **kwargs)
        Perform clash analysis on a set of shapes.
        Input:
                first_set [Mesh] - First set of shapes
                second_set [Mesh] - Second set of shapes
                distance [Number] - Distance tolerance for clash detection
                result_limit [Integer] - Maximum number of results to search for.
        Returns:
                clash_count [Integer] - Number of clashes found
                clash_points [Point] - Collection of clashing points.
                clash_radii [Number] - Collection of clashing radii (one for each point).
                first_index [Integer] - Index of clashing mesh in first set.
                second_index [Integer] - Index of clashing mesh in second set.
    
    CleanTree(*args, **kwargs)
        Removed all null and invalid items from a data tree.
        Input:
                remove_nulls [Boolean] - Remove null items from the tree.
                remove_invalid [Boolean] - Remove invalid items from the tree.
                remove_empty [Boolean] - Remove empty branches from the tree.
                tree [Generic Data] - Data tree to clean
        Returns: [Generic Data] - Spotless data tree
    
    Closed(*args, **kwargs)
        Test if a curve is closed or periodic.
        Input:
                curve [Curve] - Curve to evaluate
        Returns:
                closed [Boolean] - True if curve is closed or periodic
                periodic [Boolean] - True if curve is periodic
    
    ClosestPoint(*args, **kwargs)
        Find closest point in a point collection.
        Input:
                point [Point] - Point to search from
                cloud [Point] - Cloud of points to search
        Returns:
                closest_point [Point] - Point in [C] closest to [P]
                cp_index [Integer] - Index of closest point
                distance [Number] - Distance between [P] and [C](i)
    
    ClosestPoints(*args, **kwargs)
        Find closest points in a point collection.
        Input:
                point [Point] - Point to search from
                cloud [Point] - Cloud of points to search
                count [Integer] - Number of closest points to find
        Returns:
                closest_point [Point] - Point in [C] closest to [P]
                cp_index [Integer] - Index of closest point
                distance [Number] - Distance between [P] and [C](i)
    
    CloudDisplay(*args, **kwargs)
        Draw a collection of points as a fuzzy cloud
        Input:
                points (in, optional) [Point] - Location for each blob
                colours (in, optional) [Colour] - Colour for each blob
                size (in, optional) [Number] - Size for each blob
    
    CoCircular(*args, **kwargs)
        CoCircular
        Input:
                points (in, optional) [Point] - Points to make coplanar
                strength [Number] - Strength
        Returns: [Generic Data] - CoCircular out
    
    CoLinear(*args, **kwargs)
        CoLinear
        Input:
                points (in, optional) [Point] - Points to make coLinear
                strength [Number] - Strength
        Returns: [Generic Data] - CoLinear out
    
    CoPlanar(*args, **kwargs)
        CoPlanar
        Input:
                points (in, optional) [Point] - Points to make coplanar
                strength [Number] - Strength
        Returns: [Generic Data] - Coplanar out
    
    CoSecant(*args, **kwargs)
        Compute the co-secant (reciprocal of the Sine) of an angle.
        Input:
                value [Generic Data] - Input value
        Returns: [Generic Data] - Output value
    
    CoSpherical(*args, **kwargs)
        CoSpherical
        Input:
                points (in, optional) [Point] - Points to make coSpherical
                strength [Number] - Strength
        Returns: [Generic Data] - CoSpherical out
    
    CoTangent(*args, **kwargs)
        Compute the co-tangent (reciprocal of the Tangent) of an angle.
        Input:
                value [Generic Data] - Input value
        Returns: [Generic Data] - Output value
    
    Coincident(*args, **kwargs)
        Equivalent to a zero length constraint between a pair of points
        Input:
                point0 (in, optional) [Point] - Point 0
                point1 (in, optional) [Point] - Point 1
                strength [Number] - Strength
        Returns: [Generic Data] - Coincident
    
    Collider(*args, **kwargs)
        Collisions between thickened line segments and spheres
        Input:
                objects (in, optional) [Generic Data] - Lines or points
                radii (in, optional) [Number] - A radius for each item in Objects. Alternatively, a single value to use for all
                ignorea (in, optional) [Integer] - First index of a pair to exclude from collisions
                ignoreb (in, optional) [Integer] - Second index of a pair to exclude from collisions
                strength [Number] - Strength
        Returns: [Generic Data] - Collider out
    
    CollisionManyXMany(*args, **kwargs)
        Test for many|many collision between objects
        Input:
                colliders [Geometry] - Objects for collision
        Returns:
                collision [Boolean] - True if object at this index collides with any of the other objects
                indices [Integer] - Index of object in set which collided with the object at this index
    
    CollisionOneXMany(*args, **kwargs)
        Test for one|many collision between objects
        Input:
                collider [Geometry] - Object for collision
                obstacles [Geometry] - Obstacles for collision
        Returns:
                collision [Boolean] - True if objects collides with any of the obstacles
                index [Integer] - Index of first obstacle that collides with the object
    
    ColourCMYK(*args, **kwargs)
        Create a colour from floating point {CMYK} channels.
        Input:
                cyan [Number] - Cyan channel (cyan is defined in the range {0.0 to 1.0})
                magenta [Number] - Magenta channel (magenta is defined in the range {0.0 to 1.0})
                yellow [Number] - Yellow channel (yellow is defined in the range {0.0 to 1.0})
                key [Number] - Key channel (key is defined in the range {0.0 to 1.0})
        Returns: [Colour] - Resulting colour
    
    ColourGradient(*args, **kwargs)
        Colour Gradient
        Input:
                gradient (in, optional) [Colour Gradient] - Color Gradient
                start_point (in, optional) [Point] - Start point of the color gradient
                end_point (in, optional) [Point] - End point of the color gradient
                repeat (in, optional) [Number] - Repeat factor for gradient. [1.0, ∞)
                type (in, optional) [Integer] - Gradient Type:
        0) Solid
        1) Linear Reflected
        2) Linear Wrapped
        3) Radial Reflected
        4) Radial Wrapped
                colours (in, optional) [Colour Stop] - The colour stops used to define the gradient
        Returns:
                gradient [Colour Gradient] - Color Gradient
                start_point [Point] - Start point of the color gradient
                end_point [Point] - End point of the color gradient
                repeat [Number] - Repeat factor for gradient.
                type [Integer] - Gradient Type:
        0) Solid
        1) Linear Reflected
        2) Linear Wrapped
        3) Radial Reflected
        4) Radial Wrapped
                colours [Colour Stop] - The colour stops used to define the gradient
    
    ColourHSL(*args, **kwargs)
        Create a colour from floating point {HSL} channels.
        Input:
                alpha [Number] - Alpha channel (alpha is defined in the range {0.0 to 1.0})
                hue [Number] - Hue channel (hue is defined in the range {0.0 to 1.0})
                saturation [Number] - Saturation channel (saturation is defined in the range {0.0 to 1.0})
                luminance [Number] - Luminance channel (luminance is defined in the range {0.0 to 1.0})
        Returns: [Colour] - Resulting colour
    
    ColourHSV(*args, **kwargs)
        Create a colour from floating point {HSV} channels.
        Input:
                alpha [Number] - Alpha channel (alpha is defined in the range {0.0 to 1.0})
                hue [Number] - Hue channel (hue is defined in the range {0.0 to 1.0})
                saturation [Number] - Saturation channel (saturation is defined in the range {0.0 to 1.0})
                value [Number] - Value channel (value/brightness is defined in the range {0.0 to 1.0})
        Returns: [Colour] - Resulting colour
    
    ColourLCH(*args, **kwargs)
        Create a colour from floating point {CIE LCH} channels.
        Input:
                alpha [Number] - Alpha channel (alpha is defined in the range {0.0 to 1.0})
                luminance [Number] - Luminance channel (luminance is defined in the range {0.0 to 1.0})
                chroma [Number] - Chromaticity channel (chroma is defined in the range {0.0 to 1.0})
                hue [Number] - Hue channel (hue is defined in the range {0.0 to 1.0})
        Returns: [Colour] - Resulting colour
    
    ColourLxab(*args, **kwargs)
        Create a colour from floating point {CIE L*ab} channels.
        Input:
                alpha [Number] - Alpha channel (alpha is defined in the range {0.0 to 1.0})
                luminance [Number] - Luminance channel (luminance is defined in the range {0.0 to 1.0})
                a [Number] - First colour channel (A is defined in the range {-1.0 to 1.0})
                b [Number] - Opposing colour channel (B is defined in the range {-1.0 to 1.0})
        Returns: [Colour] - Resulting colour
    
    ColourRGB(*args, **kwargs)
        Create a colour from {RGB} channels.
        Input:
                alpha [Integer] - Alpha channel (255 = opaque)
                red [Integer] - Red channel
                green [Integer] - Green channel
                blue [Integer] - Blue channel
        Returns: [Colour] - Resulting colour
    
    ColourRGBf(*args, **kwargs)
        Create a colour from floating point {RGB} channels.
        Input:
                alpha [Number] - Alpha channel (1.0 = opaque)
                red [Number] - Red channel
                green [Number] - Green channel
                blue [Number] - Blue channel
        Returns: [Colour] - Resulting colour
    
    ColourXYZ(*args, **kwargs)
        Create a colour from floating point {XYZ} channels (CIE 1931 spec).
        Input:
                alpha [Number] - Alpha channel (alpha is defined in the range {0.0 to 1.0})
                x [Number] - X stimulus (X is defined in the range {0.0 to 1.0})
                y [Number] - Y stimulus (y is defined in the range {0.0 to 1.0})
                z [Number] - Z stimulus (Z is defined in the range {0.0 to 1.0})
        Returns: [Colour] - Resulting colour
    
    CombineClean(*args, **kwargs)
        Combine and Clean a list of meshes, removing unused and duplicate vertices
        Input:
                meshes [Mesh] - Meshes to combine
        Returns: [Mesh] - Cleaned and combined mesh
    
    CombineData(*args, **kwargs)
        Combine non-null items out of several inputs
        Input:
                input_0 (in, optional) [Generic Data] - Data to combine
                input_1 (in, optional) [Generic Data] - Data to combine
        Returns:
                result [Generic Data] - Resulting data with as few nulls as possible
                index [Integer] - Index of input that was copied into result
    
    CombineDateTime(*args, **kwargs)
        Combine a pure date and a pure time into a single date
        Input:
                date [Time] - Date portion
                time [Time] - Time portion
        Returns: [Time] - Resulting combination of date and time.
    
    ComplexArgument(*args, **kwargs)
        Get the argument of a Complex number
        Input:
                complex [Complex] - Complex number
        Returns: [Number] - Argument of the Complex number [C]
    
    ComplexComponents(*args, **kwargs)
        Extract the Real and Imaginary components from a complex number
        Input:
                complex [Complex] - Complex number to disembowel
        Returns:
                real [Number] - Real component of complex number
                imaginary [Number] - Imaginary component of complex number
    
    ComplexConjugate(*args, **kwargs)
        Create the conjugate of a Complex number
        Input:
                complex [Complex] - Complex number
        Returns: [Complex] - Conjugate of the Complex number [C]
    
    ComplexModulus(*args, **kwargs)
        Get the modulus of a Complex number
        Input:
                complex [Complex] - Complex number
        Returns: [Number] - Modulus of the Complex number [C]
    
    Compound(*args, **kwargs)
        Compound two transformations.
        Input:
                transforms [Transform] - Transformations to compound
        Returns: [Transform] - Compound transformation
    
    Concatenate(*args, **kwargs)
        Concatenate some fragments of text
        Input:
                fragment_a (in, optional) [Text] - First text fragment
                fragment_b (in, optional) [Text] - Second text fragment
        Returns: [Text] - Resulting text consisting of all the fragments
    
    Concentric(*args, **kwargs)
        Align axes of a pair of rigid bodies
        Input:
                planea (in, optional) [Plane] - The frame of one rigid body
                planeb (in, optional) [Plane] - The frame of the other rigid body
                axisa [Line] - The axis of the first body
                axisb [Line] - The axis of the other body
                flip [Boolean] - Reverse the relative direction of the axes
                strength [Number] - Strength
        Returns: [Generic Data] - C
    
    Cone(*args, **kwargs)
        Create a conical surface
        Input:
                base [Plane] - Base plane
                radius [Number] - Radius at cone base
                length [Number] - Cone height
        Returns:
                cone [Surface] - Resulting cone
                tip [Point] - Tip of cone
    
    Conicalize(*args, **kwargs)
        Adjust a quad mesh to make vertices conical - so the mesh has a face-face offset (See the paper 'The focal geometry of circular and conical meshes' for details). Use together with Planarize
        Input:
                m [Mesh] - M
                strength [Number] - Strength
        Returns: [Generic Data] - Planarize out
    
    ConnectCurves(*args, **kwargs)
        Connect a sequence of curves.
        Input:
                curves [Curve] - Curves to connect
                continuity [Integer] - Continuity of blends (0=position, 1=tangency, 2=curvature)
                close [Boolean] - Create a closed loop from all curves
                bulge [Number] - Bulge factor for connecting segments
        Returns: [Curve] - Joined segments and connecting curves
    
    ConsecutiveDomains(*args, **kwargs)
        Create consecutive domains from a list of numbers
        Input:
                numbers [Number] - Numbers for consecutive domains
                additive [Boolean] - If True, values are added to a sum-total
        Returns: [Domain] - Domains describing the spaces between the numbers
    
    ConstantTension(*args, **kwargs)
        An element which adapts its stiffness to maintain a constant force
        Input:
                line (in, optional) [Curve] - Line
                strength [Number] - Strength - positive for tension, negative for compression
        Returns: [Generic Data] - ConstantTension out
    
    ConstructDate(*args, **kwargs)
        Construct a date and time instance.
        Input:
                year [Integer] - Year number (must be between 1 and 9999)
                month [Integer] - Month number (must be between 1 and 12)
                day [Integer] - Day of month (must be between 1 and 31)
                hour [Integer] - Hour of day (must be between 0 and 23)
                minute [Integer] - Minute of the hour (must be between 0 and 59)
                second [Integer] - Second of the minute (must be between 0 and 59)
        Returns: [Time] - Date and Time data
    
    ConstructDomain(*args, **kwargs)
        Create a numeric domain from two numeric extremes.
        Input:
                domain_start [Number] - Start value of numeric domain
                domain_end [Number] - End value of numeric domain
        Returns: [Domain] - Numeric domain between {A} and {B}
    
    ConstructDomain2(*args, **kwargs)
        Create a two-dimensinal domain from four numbers.
        Input:
                u_min [Number] - Lower limit of domain in {u} direction
                u_max [Number] - Upper limit of domain in {u} direction
                v_min [Number] - Lower limit of domain in {v} direction
                v_max [Number] - Upper limit of domain in {v} direction
        Returns: [Domain²] - Two dimensional numeric domain of {u} and {v}
    
    ConstructExoticDate(*args, **kwargs)
        Construct a date using a specific calendar
        Input:
                year [Integer] - Year number (must be between 1 and 9999)
                month [Integer] - Month number (must be between 1 and 12)
                day [Integer] - Day of month (must be between 1 and 31)
        Returns: [Time] - Gregorian representation of date.
    
    ConstructMatrix(*args, **kwargs)
        Construct a matrix from initial values
        Input:
                rows [Integer] - Number of rows in the matrix
                columns [Integer] - Number of columns in the matrix
                values (in, optional) [Number] - Optional matrix values, if omitted, an identity matrix will be created
        Returns: [Matrix] - A newly created matrix
    
    ConstructMesh(*args, **kwargs)
        Construct a mesh from vertices, faces and optional colours.
        Input:
                vertices [Point] - Vertices of mesh object
                faces [Mesh face] - Faces of mesh object
                colours (in, optional) [Colour] - Optional vertex colours
        Returns: [Mesh] - Constructed mesh
    
    ConstructPath(*args, **kwargs)
        Construct a data tree branch path.
        Input:
                indices [Integer] - Branch path indices
        Returns: [Path] - Branch path
    
    ConstructPlane(*args, **kwargs)
        Construct a plane from an origin point and {x}, {y} axes.
        Input:
                origin [Point] - Origin of plane
                x-axis [Vector] - X-Axis direction of plane
                y-axis [Vector] - Y-Axis direction of plane
        Returns: [Plane] - Constructed plane
    
    ConstructPoint(*args, **kwargs)
        Construct a point from {xyz} coordinates.
        Input:
                x_coordinate [Number] - {x} coordinate
                y_coordinate [Number] - {y} coordinate
                z_coordinate [Number] - {z} coordinate
        Returns: [Point] - Point coordinate
    
    ConstructSmoothTime(*args, **kwargs)
        Construct a time instance from smooth components
        Input:
                days [Number] - Number of days
                hours [Number] - Number of hours
                minutes [Number] - Number of minutes
                seconds [Number] - Number of seconds
        Returns: [Time] - Time construct
    
    ConstructTime(*args, **kwargs)
        Construct a time instance
        Input:
                hour [Integer] - Number of hours
                minute [Integer] - Number of minutes
                second [Integer] - Number of seconds
        Returns: [Time] - Time construct
    
    ContainsTextFilter(*args, **kwargs)
        Create a filter that determines if a piece of text occurs within another text
        Input:
                key [Text] - The key to use as a filtering criteria
                text [Text] - The text to search
                case (in, optional) [Boolean] - Compare using case-sensitive matching
                culture (in, optional) [Culture] - Culture to use for string comparison
        Returns: [Predicate] - A filter that determines if a piece of text occurs within another text
    
    ContentCache(*args, **kwargs)
        Push or Pull content to and from a Rhino model
        Input:
                content (in, optional) [Model Content] - Content to cache
        Returns: [Model Content] - Resulting content
    
    ContentIdentity(*args, **kwargs)
        Retrieve some details about model content identity.
        Input:
                content [Model Content] - The model content
                path (in, optional) [Text] - The content full path name
        Using "Root::Parent::Name" schema
        Returns:
                content [Model Content] - The input model content
                id [Guid] - The model content Id
                path [Text] - The content full path name
        Using "Root::Parent::Name" schema
    
    ContentInformation(*args, **kwargs)
        Get or set some information about Rhino content elements.
        Input:
                content [Model Content] - The Rhino model content
                parent (in, optional) [Text] - Content parent path.
        To nest it, use the following schema:
        "Root::Parent"
        Else use an empty string.
        
                name (in, optional) [Text] - The content name
                tags (in, optional) [Text] - The content tags
        Returns:
                content [Model Content] - The Rhino model content
                parent [Text] - Content parent path.
        If nested, it will follow the schema:
        "Parent Root::Parent Name"
        Else will be an empty string.
        
                name [Text] - The content name
                tags [Text] - The content tags
    
    ContextBake(*args, **kwargs)
        Content for baking at the end of the GrasshopperPlayer command or with Hops and Rhino.Compute.
        Input:
                content [Generic Data] - Content to collect for baking
    
    ContextPrint(*args, **kwargs)
        Textual data to print at the end of the GrasshopperPlayer command.
        Input:
                text [Text] - Text for printing.
    
    Contour(*args, **kwargs)
        Create a set of Brep or Mesh contours
        Input:
                shape [Geometry] - Brep or Mesh to contour
                point [Point] - Contour start point
                direction [Vector] - Contour normal direction
                distance [Number] - Distance between contours
        Returns: [Curve] - Resulting contours (grouped by section)
    
    Contourex(*args, **kwargs)
        Create a set of Curve contours
        Input:
                curve [Curve] - Curve to contour
                plane [Plane] - Base plane for contours
                offsets (in, optional) [Number] - Contour offsets from base plane (if omitted, you must specify distances instead)
                distances (in, optional) [Number] - Distances between contours (if omitted, you must specify offset instead)
        Returns:
                contours [Point] - Resulting contour points (grouped by section)
                parameters [Number] - Curve parameters for all contour points
    
    ControlPointLoft(*args, **kwargs)
        Create a loft through curve control points.
        Input:
                curves [Curve] - Section curves
                degree [Integer] - Degree perpendicular to curve direction
        Returns: [Surface] - Loft result
    
    ControlPoints(*args, **kwargs)
        Extract the nurbs control points and knots of a curve.
        Input:
                curve [Curve] - Curve to evaluate
        Returns:
                points [Point] - Control points of the Nurbs-form.
                weights [Number] - Weights of control points.
                knots [Number] - Knot vector of Nurbs-form.
    
    ControlPolygon(*args, **kwargs)
        Extract the nurbs control polygon of a curve.
        Input:
                curve [Curve] - Curve to evaluate
        Returns:
                polygon [Curve] - Control polygon curve for input curve adjusted for periodicity.
                points [Point] - Control polygon points.
    
    ConvertUnits(*args, **kwargs)
        Performs a unit conversion on input Data
        Input:
                data [Generic Data] - Data in source units
                source [Unit System] - Source unit system
                target [Unit System] - Target unit system
        Returns: [Generic Data] - Data in target units
    
    ConvexEdges(*args, **kwargs)
        Select concave or convex brep edges.
        Input:
                brep [Brep] - Brep for edge extraction
        Returns:
                convex [Integer] - Fully convex edge indices
                concave [Integer] - Fully concave edge indices
                mixed [Integer] - Mixed concavity edge indices
    
    ConvexHull(*args, **kwargs)
        Compute the planar, convex hull for a collection of points
        Input:
                points [Point] - Points for convex hull solution
                plane (in, optional) [Plane] - Optional base plane. If no plane is provided, then the best-fit plane will be used.
        Returns:
                hull [Curve] - Convex hull in base plane space
                hull(z) [Curve] - Convex hull in world space
                indices [Integer] - Indices of points on convex hull
    
    ConvexHull3D(*args, **kwargs)
        Compute the non planar, convex hull for a collection of points
        Input:
                points [Point] - Points for convex hull solution
        Returns:
                hull [Mesh] - Convex hull in world coordinates space
                indices [Integer] - Indices of points on convex hull
    
    CopyTrim(*args, **kwargs)
        Copy UV trim data from one surface to another.
        Input:
                source [Surface] - Source surface
                target [Surface] - Target surface
        Returns: [Surface] - Retrimmed surface
    
    Cosine(*args, **kwargs)
        Compute the cosine of a value
        Input:
                value [Generic Data] - Input value
        Returns: [Generic Data] - Output value
    
    CreateComplex(*args, **kwargs)
        Create a complex number from a Real and an Imaginary component
        Input:
                real [Number] - Real component of complex number
                imaginary [Number] - Imaginary component of complex number
        Returns: [Complex] - Complex number
    
    CreateMaterial(*args, **kwargs)
        Create an OpenGL material.
        Input:
                diffuse [Colour] - Colour of the diffuse channel
                specular [Colour] - Colour of the specular highlight
                emission [Colour] - Emissive colour of the material
                transparency [Number] - Amount of transparency (0.0 = opaque, 1.0 = transparent
                shine [Integer] - Amount of shinyness (0 = none, 1 = low shine, 100 = max shine
        Returns: [Shader] - Resulting material
    
    CreateSet(*args, **kwargs)
        Creates the valid set from a list of items (a valid set only contains distinct elements).
        Input:
                list [Generic Data] - List of data.
        Returns:
                set [Generic Data] - A set of all the distincts values in L
                map [Integer] - An index map from original indices to set indices
    
    CrossProduct(*args, **kwargs)
        Compute vector cross product.
        Input:
                vector_a [Vector] - First vector
                vector_b [Vector] - Second vector
                unitize [Boolean] - Unitize output
        Returns:
                vector [Vector] - Cross product vector
                length [Number] - Vector length
    
    CrossReference(*args, **kwargs)
        Cross Reference data from multiple lists
        Input:
                list_(a) (in, optional) [Generic Data] - List (A) to operate on
                list_(b) (in, optional) [Generic Data] - List (B) to operate on
        Returns:
                list_(a) [Generic Data] - Adjusted list (A)
                list_(b) [Generic Data] - Adjusted list (B)
    
    Cube(*args, **kwargs)
        Compute the cube of a value
        Input:
                value [Generic Data] - Input value
        Returns: [Generic Data] - Output value
    
    CubeRoot(*args, **kwargs)
        Compute the cube root of a value
        Input:
                value [Generic Data] - Input value
        Returns: [Generic Data] - Output value
    
    CullDuplicates(*args, **kwargs)
        Cull points that are coincident within tolerance
        Input:
                points [Point] - Points to operate on
                tolerance [Number] - Proximity tolerance distance
        Returns:
                points [Point] - Culled points
                indices [Integer] - Index map of culled points
                valence [Integer] - Number of input points represented by this output point
    
    CullFaces(*args, **kwargs)
        Cull faces from a mesh
        Input:
                mesh [Mesh] - Mesh for face culling
                pattern [Boolean] - Face culling pattern
        Returns: [Mesh] - Mesh with all indicated faces removed
    
    CullIndex(*args, **kwargs)
        Cull (remove) indexed elements from a list.
        Input:
                list [Generic Data] - List to cull
                indices [Integer] - Culling indices
                wrap [Boolean] - Wrap indices to list range
        Returns: [Generic Data] - Culled list
    
    CullNth(*args, **kwargs)
        Cull (remove) every Nth element in a list.
        Input:
                list [Generic Data] - List to cull
                cull_frequency [Integer] - Cull frequency
        Returns: [Generic Data] - Culled list
    
    CullPattern(*args, **kwargs)
        Cull (remove) elements in a list using a repeating bit mask.
        Input:
                list [Generic Data] - List to cull
                cull_pattern [Boolean] - Culling pattern
        Returns: [Generic Data] - Culled list
    
    CullVertices(*args, **kwargs)
        Cull vertices from a mesh
        Input:
                mesh [Mesh] - Mesh for vertex culling
                pattern [Boolean] - Vertex culling pattern
                shrink [Boolean] - Shrink quads, if true, quads will become triangles if possible
        Returns: [Mesh] - Mesh with all indicated vertices removed
    
    Curvature(*args, **kwargs)
        Evaluate the curvature of a curve at a specified parameter.
        Input:
                curve [Curve] - Curve to evaluate
                parameter [Number] - Parameter on curve domain to evaluate
        Returns:
                point [Point] - Point on curve at {t}
                curvature [Vector] - Curvature vector at {t}
                curvature [Curve] - Curvature circle at {t}
    
    CurvatureGraph(*args, **kwargs)
        Draws Rhino Curvature Graphs.
        Input:
                curve [Curve] - Curve for Curvature graph display
                density [Integer] - Sampling density of the Graph
                scale [Integer] - Scale of graph
    
    CurveArray(*args, **kwargs)
        Create an array of geometry along a curve.
        Input:
                geometry (in, optional) [Geometry] - Base geometry
                curve [Curve] - Array rail curve
                count [Integer] - Number of elements in the array.
        Returns:
                geometry [Geometry] - Arrayed geometry
                transform [Transform] - Transformation data
    
    CurveClosestPoint(*args, **kwargs)
        Find the closest point on a curve.
        Input:
                point [Point] - Point to project onto curve
                curve [Curve] - Curve to project onto
        Returns:
                point [Point] - Point on the curve closest to the base point
                parameter [Number] - Parameter on curve domain of closest point
                distance [Number] - Distance between base point and curve
    
    CurveCollide(*args, **kwargs)
        Collisions between closed curves in a given plane
        Input:
                curves [Curve] - Closed Curves to collide
                frames (in, optional) [Plane] - The frame of each curve (if none provided, a WorldXY aligned plane at the curve centroid will be used)
                passivecurves (in, optional) [Curve] - Passive curves (they take part in collisions but are not themselves moved)
                baseplane [Plane] - Plane in which to check for collisions
                strength [Number] - Strength
        Returns:
                goal [Generic Data] - Connect this to the GoalObjects input of a Kangaroo Solver component
                frames [Plane] - The planes of each of the curves
    
    CurveContour(*args, **kwargs)
        Create a set of Curve contours
        Input:
                curve [Curve] - Curve to contour
                point [Point] - Contour start point
                direction [Vector] - Contour normal direction
                distance [Number] - Distance between contours
        Returns:
                contours [Point] - Resulting contour points (grouped by section)
                parameters [Number] - Curve parameters for all contour points
    
    CurveDomain(*args, **kwargs)
        Measure and set the curve domain
        Input:
                curve [Curve] - Curve to measure/modify
                domain (in, optional) [Domain] - Optional domain, if omitted the curve will not be modified.
        Returns:
                curve [Curve] - Curve with new domain.
                domain [Domain] - Domain of original curve.
    
    CurveFrame(*args, **kwargs)
        Get the curvature frame of a curve at a specified parameter.
        Input:
                curve [Curve] - Curve to evaluate
                parameter [Number] - Parameter on curve domain to evaluate
        Returns: [Plane] - Curve frame at {t}
    
    CurveFrames(*args, **kwargs)
        Generate a number of equally spaced curve frames.
        Input:
                curve [Curve] - Curve to divide
                count [Integer] - Number of segments
        Returns:
                frames [Plane] - Curve frames
                parameters [Number] - Parameter values at division points
    
    CurveMiddle(*args, **kwargs)
        Get the point in the middle of a curve
        Input:
                curve [Curve] - Curve for mid-point.
        Returns: [Point] - Point in the middle of the curve
    
    CurveNearestObject(*args, **kwargs)
        Find the object nearest to a curve.
        Input:
                curve [Curve] - Curve to search from
                geometry [Geometry] - Shapes to search
        Returns:
                point_a [Point] - Point on curve closest to nearest shape
                point_b [Point] - Point on nearest shape closest to curve
                index [Integer] - Index of nearest shape
    
    CurveOnSurface(*args, **kwargs)
        Create an interpolated curve through a set of points on a surface.
        Input:
                surface [Surface] - Base surface
                uv_coordinates [Point] - {v} coordinates of interpolation points
                closed [Boolean] - Closed curve
        Returns:
                curve [Curve] - Resulting nurbs curve
                length [Number] - Curve length
                domain [Domain] - Curve domain
    
    CurvePointCollide(*args, **kwargs)
        Keep a set of points outside or inside a given 2d curve
        Input:
                points (in, optional) [Point] - Points to affect
                curve (in, optional) [Curve] - A closed 2d curve
                plane [Plane] - Plane in which to consider collisions
                interior [Boolean] - If false, points will be kept outside the curve. If true they will be kept inside
                strength [Number] - Strength
        Returns: [Generic Data] - S
    
    CurveProximity(*args, **kwargs)
        Find the pair of closest points between two curves.
        Input:
                curve_a [Curve] - First curve
                curve_b [Curve] - Second curve
        Returns:
                point_a [Point] - Point on curve A closest to curve B
                point_b [Point] - Point on curve B closest to curve A
                distance [Number] - Smallest distance between two curves
    
    CurveSide(*args, **kwargs)
        Find on which side of a curve a point exists
        Input:
                curve [Curve] - Base curve
                point [Point] - Point to measure.
                plane (in, optional) [Plane] - Optional plane to measure in. If omitted, the curve plane will be used.
        Returns:
                side [Integer] - Side of curve on which point was found (-1=Left, 0=Coincident, +1=Right).
                left [Boolean] - Boolean indicating whether a point is to the left of the curve.
                right [Boolean] - Boolean indicating whether a point is to the right of the curve.
    
    CurveToPolyline(*args, **kwargs)
        Convert a curve to a polyline.
        Input:
                curve [Curve] - Curve to simplify
                tolerance_(distance) [Number] - Deviation tolerance
                tolerance_(angle) [Number] - Angle tolerance in radians
                minedge (in, optional) [Number] - Optional minimum allowed segment length
                maxedge (in, optional) [Number] - Optional maximum allowed segment length
        Returns:
                polyline [Curve] - Converted curve
                segments [Integer] - Number of polyline segments
    
    CurveXCurve(*args, **kwargs)
        Solve intersection events for two curves.
        Input:
                curve_a [Curve] - First curve
                curve_b [Curve] - Second curve
        Returns:
                points [Point] - Intersection events
                params_a [Number] - Parameters on first curve
                params_b [Number] - Parameters on second curve
    
    CurveXLine(*args, **kwargs)
        Solve intersection events for a curve and a line.
        Input:
                curve [Curve] - Curve to intersect
                line [Line] - Line to intersect with
        Returns:
                points [Point] - Intersection events
                params [Number] - Parameters on curve
                count [Integer] - Number of intersection events
    
    CurveXPlane(*args, **kwargs)
        Solve intersection events for a curve and a plane.
        Input:
                curve [Curve] - Base curve
                plane [Plane] - Intersection plane
        Returns:
                points [Point] - Intersection events
                params_c [Number] - Parameters {t} on curve
                params_p [Point] - Parameters {uv} on plane
    
    CurveXSelf(*args, **kwargs)
        Solve all self intersection events for a curve.
        Input:
                curve [Curve] - Curve for self-intersections
        Returns:
                points [Point] - Intersection events
                params [Number] - Parameters on curve
    
    CustomCurvePreview(*args, **kwargs)
        Custom Curve Preview
        Input:
                curve [Curve] - Curves to draw
                linetype (in, optional) [Model Linetype] - The Rhino model linetype used to draw the curves
                colour [Colour] - The colour used to draw the curves
    
    CustomPreview(*args, **kwargs)
        Allows for customized geometry previews
        Input:
                geometry [Geometry] - Geometry to preview
                material [Shader] - The material override
    
    CyclicQuad(*args, **kwargs)
        Make a quadrilateral have a circumscribed circle
        Input:
                m [Mesh] - M
                strength [Number] - Strength
        Returns: [Generic Data] - Cyclic out
    
    Cylinder(*args, **kwargs)
        Create a cylindrical surface.
        Input:
                base [Plane] - Base plane
                radius [Number] - Cylinder radius
                length [Number] - Cylinder height
        Returns: [Surface] - Resulting cylinder
    
    DashPattern(*args, **kwargs)
        Convert a curve to a dash pattern.
        Input:
                curve [Curve] - Curve to dash
                pattern [Number] - An collection of dash and gap lengths.
        Returns:
                dashes [Curve] - Dash segments
                gaps [Curve] - Gap segments
    
    DataDam(*args, **kwargs)
        Delay data on its way through the document
        Input:
                data_a (in, optional) [Generic Data] - Data to buffer
        Returns: [Generic Data] - Buffered data
    
    DataInput(*args, **kwargs)
        Read a bunch of data from a file.
        Input:
    
    DataOutput(*args, **kwargs)
        Write a bunch of data to a file.
        Input:
                data_input (in, optional) [Generic Data] - Data to include in the file.
    
    DateRange(*args, **kwargs)
        Create a range of successive dates or times
        Input:
                time_a [Time] - First time
                time_b [Time] - Second time
                count [Integer] - Number of times to create between A and B
        Returns: [Time] - Range of varying times between A and B.
    
    Deconstruct(*args, **kwargs)
        Deconstruct a point into its component parts.
        Input:
                point [Point] - Input point
        Returns:
                x_component [Number] - Point {x} component
                y_component [Number] - Point {y} component
                z_component [Number] - Point {z} component
    
    DeconstructArc(*args, **kwargs)
        Retrieve the base plane, radius and angle domain of an arc.
        Input:
                arc [Arc] - Arc or Circle to deconstruct
        Returns:
                base_plane [Plane] - Base plane of arc or circle
                radius [Number] - Radius of arc or circle
                angle [Domain] - Angle domain (in radians) of arc
    
    DeconstructBox(*args, **kwargs)
        Deconstruct a box into its constituent parts.
        Input:
                box [Box] - Base box
        Returns:
                plane [Plane] - Box plane
                x [Domain] - {x} dimension of box
                y [Domain] - {y} dimension of box
                z [Domain] - {z} dimension of box
    
    DeconstructBrep(*args, **kwargs)
        Deconstruct a brep into its constituent parts.
        Input:
                brep [Brep] - Base Brep
        Returns:
                faces [Surface] - Faces of Brep
                edges [Curve] - Edges of Brep
                vertices [Point] - Vertices of Brep
    
    DeconstructDate(*args, **kwargs)
        Deconstruct a date into years, months, days, hours, minutes and seconds
        Input:
                date [Time] - Date and Time data
        Returns:
                year [Integer] - Year number
                month [Integer] - Month number
                day [Integer] - Day of month
                hour [Integer] - Hour of day
                minute [Integer] - Minute of the hour
                second [Integer] - Second of the minute
    
    DeconstructDomain(*args, **kwargs)
        Deconstruct a numeric domain into its component parts.
        Input:
                domain [Domain] - Base domain
        Returns:
                start [Number] - Start of domain
                end [Number] - End of domain
    
    DeconstructDomain2(*args, **kwargs)
        Deconstruct a two-dimensional domain into its component parts
        Input:
                domain [Domain²] - Base domain
        Returns:
                u_component [Domain] - {u} component of domain
                v_component [Domain] - {v} component of domain
    
    DeconstructFace(*args, **kwargs)
        Deconstruct a mesh face into its four corner indices.
        Input:
                face [Mesh face] - Mesh face
        Returns:
                corner_a [Integer] - Index of first face vertex
                corner_b [Integer] - Index of second face vertex
                corner_c [Integer] - Index of third face vertex
                corner_d [Integer] - Index of fourth face vertex (identical to C if face is a triangle)
    
    DeconstructMaterial(*args, **kwargs)
        Deconstruct a display material (ie. shader) into its various attributes
        Input:
                material [Shader] - The display material
        Returns:
                diffuse [Colour] - Colour of the diffuse channel.
                specular [Colour] - Colour of the specular highlight.
                emission [Colour] - Emmissive colour of the material.
                transparency [Number] - Amount of transparency (0.0 = opaque, 1.0 = transparent)
                shine [Integer] - The amount of shinyness (0 = none, 1 = low shine, 100 = max shine)
    
    DeconstructMatrix(*args, **kwargs)
        Deconstruct a matrix into its component parts
        Input:
                matrix [Matrix] - Matrix to deconstruct
        Returns:
                rows [Integer] - Number of rows in the matrix
                columns [Integer] - Number of columns in the matrix
                values [Number] - Matrix values
    
    DeconstructMesh(*args, **kwargs)
        Deconstruct a mesh into its component parts.
        Input:
                mesh [Mesh] - Base mesh
        Returns:
                vertices [Point] - Mesh vertices
                faces [Mesh face] - Mesh faces
                colours [Colour] - Mesh vertex colours
                normals [Vector] - Mesh normals
    
    DeconstructPath(*args, **kwargs)
        Deconstruct a data tree path into individual integers.
        Input:
                branch [Path] - Branch path
        Returns: [Integer] - Branch path indices
    
    DeconstructPlane(*args, **kwargs)
        Deconstruct a plane into its component parts.
        Input:
                plane [Plane] - Plane to deconstruct
        Returns:
                origin [Point] - Origin point
                x-axis [Vector] - X-Axis vector
                y-axis [Vector] - Y-Axis vector
                z-axis [Vector] - Z-Axis vector
    
    DeconstructRectangle(*args, **kwargs)
        Retrieve the base plane and side intervals of a rectangle.
        Input:
                rectangle [Rectangle] - Rectangle to deconstruct
        Returns:
                base_plane [Plane] - Base plane of rectangle
                x_interval [Domain] - Size interval along base plane X axis
                y_interval [Domain] - Size interval along base plane Y axis
    
    DeconstructVector(*args, **kwargs)
        Deconstruct a vector into its component parts.
        Input:
                vector [Vector] - Input vector
        Returns:
                x_component [Number] - Vector {x} component
                y_component [Number] - Vector {y} component
                z_component [Number] - Vector {z} component
    
    Degrees(*args, **kwargs)
        Convert an angle specified in radians to degrees
        Input:
                radians [Number] - Angle in radians
        Returns: [Number] - Angle in degrees
    
    DelaunayEdges(*args, **kwargs)
        Delaunay connectivity
        Input:
                points [Point] - Points for triangulate
                plane (in, optional) [Plane] - Optional base plane. If no plane is provided, then the best-fit plane will be used.
        Returns:
                connectivity [Integer] - Topological Connectivity diagram
                edges [Line] - Edges of the connectivity diagram
    
    DelaunayMesh(*args, **kwargs)
        Delaunay triangulation
        Input:
                points [Point] - Points for triangulate
                plane (in, optional) [Plane] - Optional base plane. If no plane is provided, then the best-fit plane will be used.
        Returns: [Mesh] - Mesh
    
    DeleteConsecutive(*args, **kwargs)
        Delete consecutive similar members in a set.
        Input:
                set [Generic Data] - Set to operate on.
                wrap [Boolean] - If true, the last and first member are considered to be adjacent.
        Returns:
                set [Generic Data] - Set with consecutive identical members removed.
                count [Integer] - Number of members removed.
    
    DeleteFaces(*args, **kwargs)
        Delete faces from a mesh
        Input:
                mesh [Mesh] - Mesh for face deletion
                indices [Integer] - List of all face indices to delete
        Returns: [Mesh] - Mesh with all indexed faces removed
    
    DeleteVertices(*args, **kwargs)
        Delete vertices from a mesh
        Input:
                mesh [Mesh] - Mesh for vertex deletion
                indices [Integer] - List of all vertex indices to delete
                shrink [Boolean] - Shrink quads, if true, quads will become triangles if possible
        Returns: [Mesh] - Mesh with all indexed vertices removed
    
    Derivatives(*args, **kwargs)
        Evaluate the derivatives of a curve at a specified parameter.
        Input:
                curve [Curve] - Curve to evaluate
                parameter [Number] - Parameter on curve domain to evaluate
        Returns:
                point [Point] - Point on curve at {t}
                first_derivative [Vector] - First curve derivative at t (Velocity)
    
    Developablize(*args, **kwargs)
        Turn a triangular mesh into developable patches with creases. Based on the paper 'Developability of Triangle Meshes' by Stein, Grinspun & Crane
        Input:
                m [Mesh] - M
                strength [Number] - Strength
        Returns: [Generic Data] - out
    
    Diagonalize(*args, **kwargs)
        Replace each edge with a new face
        Input:
                mesh [Mesh] - Mesh to diagonalize
        Returns: [Mesh] - Diagonal mesh
    
    Dimensions(*args, **kwargs)
        Get the approximate dimensions of a surface
        Input:
                surface [Surface] - Surface to measure
        Returns:
                u_dimension [Number] - Approximate dimension in U direction
                v_dimension [Number] - Approximate dimension in V direction
    
    Direction(*args, **kwargs)
        Align a line segment with a given vector, or if none supplied, the closest of the World XYZ vectors
        Input:
                line (in, optional) [Line] - Line
                direction (in, optional) [Vector] - Direction - if none supplied, closest ortho axis will be used
                strength [Number] - Strength
        Returns: [Generic Data] - Direction out
    
    DirectionDisplay(*args, **kwargs)
        Display the force directions of a field section
        Input:
                field [Field] - Field to evaluate
                section [Rectangle] - Rectangle describing section
                samples [Integer] - Section sample count indicator
        Returns: [Mesh] - Section display mesh
    
    DirectionalLight(*args, **kwargs)
        Directional Light
        Input:
                directional_light (in, optional) [Light] - The directional light
                location (in, optional) [Point] - Location of the directional light
                direction (in, optional) [Vector] - Direction of the light rays
        Returns:
                directional_light [Light] - The directional light
                location [Point] - Location of the directional light
                direction [Vector] - Direction of the light rays
    
    Discontinuity(*args, **kwargs)
        Find all discontinuities along a curve.
        Input:
                curve [Curve] - Curve to analyze
                level [Integer] - Level of discontinuity to test for (1=C1, 2=C2, 3=Cinfinite)
        Returns:
                points [Point] - Points at discontinuities
                parameters [Number] - Curve parameters at discontinuities
    
    Disjoint(*args, **kwargs)
        Test whether two sets are disjoint.
        Input:
                set_a [Generic Data] - First set.
                set_b [Generic Data] - Second set.
        Returns: [Boolean] - True if none of the items in A occur in B.
    
    DisjointMesh(*args, **kwargs)
        Split a mesh into disjoint pieces.
        Input:
                mesh [Mesh] - Mesh to split
        Returns: [Mesh] - Disjoint pieces
    
    Dispatch(*args, **kwargs)
        Dispatch the items in a list into two target lists.
        Input:
                list [Generic Data] - List to filter
                dispatch_pattern [Boolean] - Dispatch pattern
        Returns:
                list_a [Generic Data] - Dispatch target for True values
                list_b [Generic Data] - Dispatch target for False values
    
    DisplayAttributes(*args, **kwargs)
        Object display attributes
        Input:
                display (in, optional) [Display Attributes] - Object Display Attributes
                display_colour (in, optional) [Display Colour] - Object Display Colour
                display_mode (in, optional) [Display Mode] - Object Display Mode
        Returns:
                display [Display Attributes] - Object Display Attributes
                display_colour [Display Colour] - Object Display Colour
                display_mode [Display Mode] - Object Display Mode
    
    DisplayColour(*args, **kwargs)
        Object display colour attributes
        Input:
                display_colour (in, optional) [Display Colour] - Object Display Colour
                source (in, optional) [Integer] - Colour Source:
        0) By Layer
        1) By Object
        2) By Material
        3) By Parent
                colour (in, optional) [Colour] - Colour
        Returns:
                display_colour [Display Colour] - Object Display Colour
                source [Integer] - Colour Source:
        0) By Layer
        1) By Object
        2) By Material
        3) By Parent
                colour [Colour] - Colour
    
    Distance(*args, **kwargs)
        Compute Euclidean distance between two point coordinates.
        Input:
                point_a [Point] - First point
                point_b [Point] - Second point
        Returns: [Number] - Distance between A and B
    
    DivideCurve(*args, **kwargs)
        Divide a curve into equal length segments
        Input:
                curve [Curve] - Curve to divide
                count [Integer] - Number of segments
                kinks [Boolean] - Split segments at kinks
        Returns:
                points [Point] - Division points
                tangents [Vector] - Tangent vectors at division points
                parameters [Number] - Parameter values at division points
    
    DivideDistance(*args, **kwargs)
        Divide a curve with a preset distance between points
        Input:
                curve [Curve] - Curve to divide
                distance [Number] - Distance between points
        Returns:
                points [Point] - Division points
                tangents [Vector] - Tangent vectors at division points
                parameters [Number] - Parameter values at division points
    
    DivideDomain(*args, **kwargs)
        Divide a domain into equal segments.
        Input:
                domain [Domain] - Base domain
                count [Integer] - Number of segments
        Returns: [Domain] - Division segments
    
    DivideDomain2(*args, **kwargs)
        Divides a two-dimensional domain into equal segments.
        Input:
                domain [Domain²] - Base domain
                u_count [Integer] - Number of segments in {u} direction
                v_count [Integer] - Number of segments in {v} direction
        Returns: [Domain²] - Individual segments
    
    DivideLength(*args, **kwargs)
        Divide a curve into segments with a preset length
        Input:
                curve [Curve] - Curve to divide
                length [Number] - Length of segments
        Returns:
                points [Point] - Division points
                tangents [Vector] - Tangent vectors at division points
                parameters [Number] - Parameter values at division points
    
    DivideSurface(*args, **kwargs)
        Generate a grid of {uv} points on a surface.
        Input:
                surface [Surface] - Surface to divide
                u_count [Integer] - Number of segments in {u} direction
                v_count [Integer] - Number of segments in {v} direction
        Returns:
                points [Point] - Division points
                normals [Vector] - Normal vectors at division points
                parameters [Point] - Parameter coordinates at division points
    
    Division(*args, **kwargs)
        Mathematical division
        Input:
                a [Generic Data] - Item to divide (dividend)
                b [Generic Data] - Item to divide with (divisor)
        Returns: [Generic Data] - The result of the Division
    
    DomainBox(*args, **kwargs)
        Create a box defined by a base plane and size domains.
        Input:
                base [Plane] - Base plane
                x [Domain] - Domain of the box in the {x} direction.
                y [Domain] - Domain of the box in the {y} direction.
                z [Domain] - Domain of the box in the {z} direction.
        Returns: [Box] - Resulting box
    
    DotDisplay(*args, **kwargs)
        Show points as round dots
        Input:
                point [Point] - Points to display
    
    DotProduct(*args, **kwargs)
        Compute vector dot product.
        Input:
                vector_a [Vector] - First vector
                vector_b [Vector] - Second vector
                unitize [Boolean] - Unitize input
        Returns: [Number] - Vector dot product
    
    DraftingAttributes(*args, **kwargs)
        Object drafting attributes
        Input:
                drafting (in, optional) [Drafting Attributes] - Object Drafting Attributes
                linetype (in, optional) [Linetype] - Object Linetype
                linetype_scale (in, optional) [Number] - Object Linetype Scale
        Returns:
                drafting [Drafting Attributes] - Object Drafting Attributes
                linetype [Linetype] - Object Linetype
                linetype_scale [Number] - Object Linetype Scale
    
    DraftingScale(*args, **kwargs)
        Get or set the scale factor for annotations, linetypes, and/or hatch patterns.
        Input:
                annotation_model_scaling (in, optional) [Boolean] - Enable model space scaling for annotations
                annotation_layout_scaling (in, optional) [Boolean] - Enable layout space scaling for annotations
                hatch_scaling (in, optional) [Boolean] - Enable model space scaling for hatches
                hatch_scale (in, optional) [Number] - The model space hatch pattern scale factor
                linetype_scale (in, optional) [Number] - The model space linetype scale factor
        Returns:
                annotation_model_scaling [Boolean] - Enable model space scaling for annotations
                annotation_layout_scaling [Boolean] - Enable layout space scaling for annotations
                hatch_scaling [Boolean] - Enable model space scaling for hatches
                hatch_scale [Number] - The model space hatch pattern scale factor
                linetype_scale [Number] - The model space linetype scale factor
    
    DuplicateContent(*args, **kwargs)
        Duplicates input content with a new identity.
        Clears the current content Id and optionally lets you set a new parent and name.
        Input:
                content [Model Content] - Model Content
                name (in, optional) [Text] - New content name
        Returns: [Model Content] - Model Content
    
    DuplicateData(*args, **kwargs)
        Duplicate data a predefined number of times.
        Input:
                data [Generic Data] - Data to duplicate
                number [Integer] - Number of duplicates
                order [Boolean] - Retain list order
        Returns: [Generic Data] - Duplicated data
    
    DynamicWeight1d(*args, **kwargs)
        A load in the negative Z direction, which updates its magnitude according to the length of the line
        Input:
                line (in, optional) [Curve] - Line
                weight [Number] - Weight per unit length
        Returns: [Generic Data] - DynamicWeight out
    
    EdgeLengths(*args, **kwargs)
        Set the edge lengths of a mesh
        Input:
                mesh [Mesh] - Mesh to set edge lengths for
                lengthfactor [Number] - Target edge length as a multiple of current length
                strength [Number] - Strength
        Returns: [Generic Data] - out
    
    EdgeSurface(*args, **kwargs)
        Create a surface from two, three or four edge curves.
        Input:
                curve_a [Curve] - First curve
                curve_b [Curve] - Second curve
                curve_c (in, optional) [Curve] - Optional Third curve
                curve_d (in, optional) [Curve] - Optional Fourth curve
        Returns: [Brep] - Brep representing the edge-surface
    
    EdgesfromDirections(*args, **kwargs)
        Select brep edges based on edge direction
        Input:
                brep [Brep] - Brep for edge extraction
                directions [Vector] - Directions to filter
                reflex [Boolean] - If true, angle test includes the reflex angle
                angle [Number] - Direction angle tolerance.
        Returns:
                edges [Curve] - Found edges
                indices [Integer] - Edge indices
                map [Text] - Direction map per edge
    
    EdgesfromFaces(*args, **kwargs)
        Select all brep edges that delineate certain faces
        Input:
                brep [Brep] - Brep for edge extraction
                points [Point] - Points for face coincidence check
        Returns:
                edges [Curve] - Found edges
                indices [Integer] - Edge indices
    
    EdgesfromLength(*args, **kwargs)
        Select brep edges based on length
        Input:
                brep [Brep] - Brep for edge extraction
                minimum [Number] - Minimum edge length for inclusion.
                maximum [Number] - Maximum edge length for inclusion.
        Returns:
                edges [Curve] - Found edges
                indices [Integer] - Edge indices
    
    EdgesfromLinearity(*args, **kwargs)
        Select brep edges based on linearity
        Input:
                brep [Brep] - Brep for edge extraction
                minimum [Number] - Minimum linearity deviation for edge inclusion.
                maximum [Number] - Maximum linearity deviation for edge inclusion.
        Returns:
                edges [Curve] - Found edges
                indices [Integer] - Edge indices
    
    EdgesfromPoints(*args, **kwargs)
        Select brep edges based on point coincidence
        Input:
                brep [Brep] - Brep for edge extraction
                points [Point] - Points for coincidence check
                valence [Integer] - Minimum valence of points per edge
                tolerance (in, optional) [Number] - Optional coincidence tolerance.
        Returns:
                edges [Curve] - Found edges
                indices [Integer] - Edge indices
                map [Text] - Point map per edge
    
    Ellipse(*args, **kwargs)
        Create an ellipse defined by base plane and two radii.
        Input:
                plane [Plane] - Base plane of ellipse
                radius_1 [Number] - Radius in {x} direction
                radius_2 [Number] - Radius in {y} direction
        Returns:
                ellipse [Curve] - Resulting ellipse
                focus_1 [Point] - First focus point
                focus_2 [Point] - Second focus point
    
    EndPoints(*args, **kwargs)
        Extract the end points of a curve.
        Input:
                curve [Curve] - Curve to evaluate
        Returns:
                start [Point] - Curve start point
                end [Point] - Curve end point
    
    Entwine(*args, **kwargs)
        Flatten and combine a collection of data streams
        Input:
                branch_{0;0} (in, optional) [Generic Data] - Data to entwine
                branch_{0;1} (in, optional) [Generic Data] - Data to entwine
                branch_{0;2} (in, optional) [Generic Data] - Data to entwine
        Returns: [Generic Data] - Entwined result
    
    Epsilon(*args, **kwargs)
        Returns a factor of double precision floating point epsilon.
        Input:
                factor [Number] - Factor to be multiplied by epsilon
        Returns: [Number] - Output value
    
    EqualAngle(*args, **kwargs)
        Equalize angles between multiple pairs of lines
        Input:
                linea (in, optional) [Line] - First line segment of each pair
                lineb (in, optional) [Line] - Second line segment of each pair
                strength [Number] - Strength
        Returns: [Generic Data] - EqualAngle Goal
    
    EqualLength(*args, **kwargs)
        EqualLength
        Input:
                line (in, optional) [Curve] - List of lines to make equal length
                strength [Number] - Strength
        Returns: [Generic Data] - EqualLength out
    
    Equality(*args, **kwargs)
        Test for (in)equality of two numbers
        Input:
                first_number [Number] - Number to compare
                second_number [Number] - Number to compare to
        Returns:
                equality [Boolean] - True if A = B
                inequality [Boolean] - True if A ≠ B
    
    EqualityFilter(*args, **kwargs)
        Create a filter that determines if a value is equal to another
        Input:
                key [Text] - The key to use as a filtering criteria
                value [Generic Data] - The value to compare
        Returns:
                equal [Predicate] - A filter that determine if one object is equal to another
                unequal [Predicate] - A filter that determine if one object is not equal to another
    
    Evaluate(*args, **kwargs)
        Evaluate an expression with a flexible number of variables.
        Input:
                expression [Expression] - Expression to evaluate
                x (in, optional) [Expression Variant] - 'x' value used to evaluate Expression
                y (in, optional) [Expression Variant] - 'y' value used to evaluate Expression
        Returns: [Generic Data] - Expression result
    
    EvaluateAnnotationText(*args, **kwargs)
        Get the annotation text with the text field expressions evaluated
        Input:
                annotation [Geometry] - The annotation to evaluate
        Returns: [Text] - The evaluated text of the annotation
    
    EvaluateBox(*args, **kwargs)
        Evaluate a box in normalised {UVW} space.
        Input:
                box [Box] - Base box
                u_parameter [Number] - {u} parameter (values between 0.0 and 1.0 are inside the box)
                v_parameter [Number] - {v} parameter (values between 0.0 and 1.0 are inside the box)
                w_parameter [Number] - {w} parameter (values between 0.0 and 1.0 are inside the box)
        Returns:
                plane [Plane] - Plane at {uvw} coordinate
                point [Point] - Point at {uvw} coordinate
                include [Boolean] - True if point is inside or on box
    
    EvaluateCurve(*args, **kwargs)
        Evaluate a curve at the specified parameter.
        Input:
                curve [Curve] - Curve to evaluate
                parameter [Number] - Parameter on curve domain to evaluate
        Returns:
                point [Point] - Point on the curve at {t}
                tangent [Vector] - Tangent vector at {t}
                angle [Number] - Angle (in Radians) of incoming vs. outgoing curve at {t}
    
    EvaluateField(*args, **kwargs)
        Evaluate a field at a point
        Input:
                field [Field] - Field to evaluate
                point [Point] - Point to evaluate at
        Returns:
                tensor [Vector] - Field tensor at sample location
                strength [Number] - Field strength at sample location
    
    EvaluateLength(*args, **kwargs)
        Evaluate a curve at a certain factor along its length. Length factors can be supplied both in curve units and normalized units. Change the [N] parameter to toggle between the two modes.
        Input:
                curve [Curve] - Curve to evaluate
                length [Number] - Length factor for curve evaluation
                normalized [Boolean] - If True, the Length factor is normalized (0.0 ~ 1.0)
        Returns:
                point [Point] - Point at the specified length
                tangent [Vector] - Tangent vector at the specified length
                parameter [Number] - Curve parameter at the specified length
    
    EvaluateSurface(*args, **kwargs)
        Evaluate local surface properties at a {uv} coordinate.
        Input:
                surface [Surface] - Base surface
                point [Point] - {uv} coordinate to evaluate
        Returns:
                point [Point] - Point at {uv}
                normal [Vector] - Normal at {uv}
                u_direction [Vector] - U direction at {uv}
                v_direction [Vector] - V direction at {uv}
                frame [Plane] - Frame at {uv}
    
    EvaluateTextFields(*args, **kwargs)
        Evaluates fields expressions of a text.
        Input:
                text [Text] - The text with field expressions to evaluate
        Returns:
                text [Text] - The formatted text expression
                values [Text] - The evaluated values of the text fields
    
    Explode(*args, **kwargs)
        Explode a curve into smaller segments.
        Input:
                curve [Curve] - Curve to explode
                recursive [Boolean] - Recursive decomposition until all segments are atomic
        Returns:
                segments [Curve] - Exploded segments that make up the base curve
                vertices [Point] - Vertices of the exploded segments
    
    ExplodeObject(*args, **kwargs)
        Explode Object
        Input:
                object [Model Object] - Model object to explode
        Returns: [Model Object] - Exploded model objects
    
    ExplodeTree(*args, **kwargs)
        Extract all the branches from a tree
        Input:
                data (in, optional) [Generic Data] - Data to explode
        Returns:
                branch_0 [Generic Data] - All data inside the branch at index: 0
                branch_1 [Generic Data] - All data inside the branch at index: 1
    
    ExportHatchPattern(*args, **kwargs)
        Export hatch patterns to a file.
        Input:
                file_path [Text] - Location to save the hatch pattern as a Rhino (*.pat) file.
                hatch_patterns [Model Hatch Pattern] - Hatch pattern list to export
                overwrite [Boolean] - Overwrite Existing File
        Returns:
                file_path [Text] - Hatch Pattern file path
                hatch_patterns [Model Hatch Pattern] - List of exported hatch patterns
                exported [Boolean] - Exported
    
    ExportModelBlockDefinition(*args, **kwargs)
        Export a block definition as a Rhino (*.3dm) file.
        Input:
                block_definition [Model Block Definition] - Block Definition
                file_path [Text] - Location to save the block definition as a Rhino (*.3dm) file.
                overwrite [Boolean] - Overwrite Existing File
        Returns:
                block_definition [Model Block Definition] - Block Definition
                file_path [Text] - Target File Path
                exported [Boolean] - Exported
    
    Exposure(*args, **kwargs)
        Solve mesh exposure for a collection of energy rays and obstructions.
        Input:
                shape [Mesh] - Mesh for exposure solution
                obstructions (in, optional) [Mesh] - Optional additional obstructing geometry
                rays [Vector] - Light ray directions
                energy (in, optional) [Number] - Optional Energy values for each ray
                lambert [Boolean] - If true, Lambertian shading will be applied,
        Returns:
                exposure [Number] - Combined exposure for every individual mesh vertex.
                range [Domain] - Exposure Range for the entire mesh.
    
    Expression(*args, **kwargs)
        Evaluate an expression
        Input:
                x (in, optional) [Expression Variant] - 'x' value used to evaluate ''
                y (in, optional) [Expression Variant] - 'y' value used to evaluate ''
        Returns: [Generic Data] - Result of expression
    
    ExtendCurve(*args, **kwargs)
        Extend a curve by a specified distance.
        Input:
                curve [Curve] - Curve to extend
                type [Integer] - Type of extension (0=Line, 1=Arc, 2=Smooth)
                start [Number] - Extension length at start of curve
                end [Number] - Extension length at end of curve
        Returns: [Curve] - Extended curve
    
    Extremes(*args, **kwargs)
        Find the extremes (highest and lowest points) on a curve.
        Input:
                curve [Curve] - Base curve
                plane [Plane] - Plane for extreme direction.
        Returns:
                highest [Point] - Highest point on curve.
                lowest [Point] - Lowest point on curve.
    
    Extrude(*args, **kwargs)
        Extrude points, curves and surfaces along a vector.
        Input:
                base [Geometry] - Profile surface
                direction [Vector] - Extrusion direction
        Returns: [Geometry] - Extrusion result
    
    ExtrudeAlong(*args, **kwargs)
        Extrude curves and surfaces along a curve.
        Input:
                base [Geometry] - Profile curve or surface
                curve [Curve] - Extrusion curve
        Returns: [Brep] - Extrusion result
    
    ExtrudeLinear(*args, **kwargs)
        Extrude curves and surfaces along a straight path.
        Input:
                profile [Geometry] - Profile curve or surface
                orientation_(p) [Plane] - Plane indicating orientation of profile shape
                axis [Line] - Extrusion axis
                orientation_(a) (in, optional) [Plane] - Optional orientational plane for the axis
        Returns: [Brep] - Extrusion result
    
    ExtrudePoint(*args, **kwargs)
        Extrude curves and surfaces to a point.
        Input:
                base [Geometry] - Profile curve or surface
                point [Point] - Extrusion tip
        Returns: [Brep] - Extrusion result
    
    FaceBoundaries(*args, **kwargs)
        Convert all mesh faces to polylines
        Input:
                mesh [Mesh] - Mesh for face boundary extraction
        Returns: [Curve] - Boundary polylines for each mesh face
    
    FaceCircles(*args, **kwargs)
        Solve the circumscribed circles for all mesh faces
        Input:
                mesh [Mesh] - Mesh for normal and center point extraction
        Returns:
                centers [Circle] - Circum-circles for all mesh triangles (quads are skipped)
                ratio [Number] - Ratio of triangles; altitude / longest edge. (quads are skipped)
    
    FaceFaceOffset(*args, **kwargs)
        Offset a conical mesh so that corresponding faces are constant distance apart
        Input:
                mesh [Mesh] - Input Mesh
                distance [Number] - Offset distance
        Returns:
                offset [Mesh] - The offset mesh
                beams [Mesh] - Beams between the 2 meshes
    
    FaceNormals(*args, **kwargs)
        Extract the normals and center points of all faces in a mesh
        Input:
                mesh [Mesh] - Mesh for normal and center point extraction
        Returns:
                centers [Point] - Center-points of all faces
                normals [Vector] - Normal vectors for all faces
    
    FacetDome(*args, **kwargs)
        Create a facetted dome
        Input:
                points [Point] - Points on dome that describe the facet centers
                box (in, optional) [Box] - Optional bounding box for facet boundary
                radius (in, optional) [Number] - Optional radius for facets
        Returns:
                pattern [Curve] - Complete facet pattern
                dome [Surface] - dome surface
    
    Factorial(*args, **kwargs)
        Returns the factorial of an integer.
        Input:
                number [Integer] - Input integer
        Returns: [Generic Data] - Factorial of {N}
    
    Fibonacci(*args, **kwargs)
        Creates a Fibonacci sequence.
        Input:
                seed_a [Number] - First seed number of the sequence
                seed_b [Number] - Second seed number of the sequence
                number [Integer] - Number of values in the sequence
        Returns: [Number] - First N numbers in this Fibonacci sequence
    
    FieldLine(*args, **kwargs)
        Compute the field line through a certain point
        Input:
                field [Field] - Field to evaluate
                point [Point] - Point to start from
                steps [Integer] - Number of samples
                accuracy [Number] - Accuracy hint (will only be loosely obeyed)
                method [Integer] - Solver (1=Euler, 2=RK2, 3=RK3, 4=RK4)
        Returns: [Curve] - Curve approximation of field line through P
    
    Fillet(*args, **kwargs)
        Fillet a curve at a parameter.
        Input:
                curve [Curve] - Curve to fillet
                parameter [Number] - Curve parameter for fillet
                radius [Number] - Radius of fillet
        Returns:
                curve [Curve] - Filleted curve
                parameter [Number] - Parameter where the fillet eventually occured
    
    FilletDistance(*args, **kwargs)
        Fillet the sharp corners of a curve by distance.
        Input:
                curve [Curve] - Curve to fillet
                distance [Number] - Distance from corner of fillet start
        Returns: [Curve] - Curve with filleted corners
    
    FilletEdge(*args, **kwargs)
        Fillet some edges of a brep.
        Input:
                shape [Brep] - Shape to fillet
                blend [Integer] - Fillet blend type
                metric [Integer] - Fillet metric type
                edges (in, optional) [Integer] - Edge indices to fillet
                radii (in, optional) [Number] - Fillet radii/measures per edge
        Returns: [Brep] - Filleted Brep
    
    FilterContent(*args, **kwargs)
        Separate content by filter condition
        Input:
                content [Model Content] - The content to filter
                filter [Predicate] - Determines the filtering criteria that the content must satisfy to be included
        Returns: [Model Content] - Input content filtered by value
    
    FindDomain(*args, **kwargs)
        Find the first domain that contains a specific value
        Input:
                domains [Domain] - Collection of domains to search
                number [Number] - Number to test
                strict [Boolean] - Strict comparison, if true then the value must be on the interior of a domain
        Returns:
                index [Integer] - Index of first domain that includes the specified value
                neighbour [Integer] - Index of domain that is closest to the specified value
    
    Findsimilarmember(*args, **kwargs)
        Find the most similar member in a set.
        Input:
                data [Generic Data] - Data to search for.
                set [Generic Data] - Set to search.
        Returns:
                hit [Generic Data] - Member in S closest to D.
                index [Integer] - Index of H in set.
    
    FitCurve(*args, **kwargs)
        Fit a curve along another curve.
        Input:
                curve [Curve] - Curve to fit
                degree (in, optional) [Integer] - Optional degree of curve (if omitted, input degree is used)
                tolerance (in, optional) [Number] - Tolerance for fitting (if omitted, document tolerance is used)
        Returns: [Curve] - Fitted curve
    
    FitLine(*args, **kwargs)
        Fit a line to a collection of points.
        Input:
                points [Point] - Points to fit
        Returns: [Line] - Line segment
    
    FitLoft(*args, **kwargs)
        Create a loft fitted through a set of curves.
        Input:
                curves [Curve] - Section curves
                count_u [Integer] - Number of points along curve direction
                degree_u [Integer] - Degree along curve direction
                degree_v [Integer] - Degree perpendicular to curve direction
        Returns: [Surface] - Loft result
    
    FitnessLandscape(*args, **kwargs)
        Display a 2.5D fitness landscape
        Input:
                bounds [Rectangle] - Landscape bounds
                values [Number] - Landscape values
                count [Integer] - Number of samples along X direction
        Returns: [Mesh] - Landscaper mesh
    
    FlattenTree(*args, **kwargs)
        Flatten a data tree by removing all branching information.
        Input:
                tree [Generic Data] - Data tree to flatten
                path [Path] - Path of flattened tree
        Returns: [Generic Data] - Flattened data tree
    
    Flip(*args, **kwargs)
        Flip the normals of a surface based on local or remote geometry
        Input:
                surface [Surface] - Surface to flip
                guide (in, optional) [Surface] - Optional guide surface to match
        Returns:
                surface [Surface] - Flipped surface
                result [Boolean] - Result: True if surface was flipped
    
    FlipCurve(*args, **kwargs)
        Flip a curve using an optional guide curve.
        Input:
                curve [Curve] - Curve to flip
                guide (in, optional) [Curve] - Optional guide curve
        Returns:
                curve [Curve] - Flipped curve
                flag [Boolean] - Flip action
    
    FlipMatrix(*args, **kwargs)
        Flip a matrix-like data tree by swapping rows and columns.
        Input:
                data [Generic Data] - Data matrix to flip
        Returns: [Generic Data] - Flipped data matrix
    
    FlipMesh(*args, **kwargs)
        Flip the normal vectors of a mesh
        Input:
                mesh [Mesh] - Mesh to flip
                vertex_normals [Boolean] - Flip all vertex normals
                face_normals [Boolean] - Flip all face normals
                face_orientation [Boolean] - Reverse all face orientations
        Returns: [Mesh] - Flipped mesh
    
    FlipPlane(*args, **kwargs)
        Flip or swap the axes of a plane
        Input:
                plane [Plane] - Plane to adjust
                reverse_x [Boolean] - Reverse the x-axis direction
                reverse_y [Boolean] - Reverse the y-axis direction
                swap_axes [Boolean] - Swap the x and y axis directions
        Returns: [Plane] - Flipped plane
    
    Floor(*args, **kwargs)
        Floor
        Input:
                strength (in, optional) [Number] - Strength
        Returns: [Generic Data] - Floor out
    
    FloorFriction(*args, **kwargs)
        Floor with static friction
        Input:
                points (in, optional) [Point] - Points to act on
                limit [Number] - Limit - set to 0 for no friction
                strength [Number] - Strength
        Returns: [Generic Data] - Floor goal
    
    Flow(*args, **kwargs)
        Re-aligns objects from a base curve to a target curve.
        Input:
                geometry [Geometry] - Base geometry
                base [Curve] - Base curve
                target [Curve] - Target curve
                reverse_base [Boolean] - If true, then direction of the base curve is reversed.
                reverse_target [Boolean] - If true, then direction of the target curve is reversed.
                stretch [Boolean] - If true, the length of objects along the curve directions is changed to reflect the curve dimensions.
                rigid [Boolean] - Geometry will not be deformed as it is transformed
        Returns: [Geometry] - Morphed geometry
    
    FoldAngle(*args, **kwargs)
        Measure the current angle between two triangles about their common edge
        Input:
                p1 [Point] - Start of the common edge shared by both triangles
                p2 [Point] - End of the common edge shared by both triangles
                p3 [Point] - Tip of first triangle
                p4 [Point] - Tip of second triangle
        Returns: [Number] - Angle between the triangles
    
    Format(*args, **kwargs)
        Format some data using placeholders and formatting tags
        Input:
                format [Text] - Text format
                culture [Culture] - Formatting culture
                data_0 (in, optional) [Generic Data] - Data to insert at {0} placeholders
                data_1 (in, optional) [Generic Data] - Data to insert at {1} placeholders
        Returns: [Text] - Formatted text
    
    FragmentPatch(*args, **kwargs)
        Create a fragmented patch from a polyline boundary
        Input:
                boundary [Curve] - Fragment polyline boundary
        Returns: [Brep] - Fragmented patch
    
    G2(*args, **kwargs)
        Maintain curvature continuity between 2 nurbs curves
        Input:
                points (in, optional) [Point] - 5 points - the three control points at the end of the 1st curve, and the 3 at the start of the 2nd curve, with the middle one shared by both
                strength [Number] - Strength
        Returns: [Generic Data] - G2 Goal
    
    GateAnd(*args, **kwargs)
        Perform boolean conjunction (AND gate).
        Input:
                a (in, optional) [Boolean] - First boolean for AND operation
                b (in, optional) [Boolean] - Second boolean for AND operation
        Returns: [Boolean] - Resulting value
    
    GateMajority(*args, **kwargs)
        Calculates the majority vote among three booleans.
        Input:
                a [Boolean] - First boolean
                b [Boolean] - Second boolean
                c [Boolean] - Third boolean
        Returns: [Boolean] - Average value
    
    GateNand(*args, **kwargs)
        Perform boolean alternative denial (NAND gate).
        Input:
                a [Boolean] - Left hand boolean
                b [Boolean] - Right hand boolean
        Returns: [Boolean] - Resulting value
    
    GateNor(*args, **kwargs)
        Perform boolean joint denial (NOR gate).
        Input:
                a [Boolean] - Left hand boolean
                b [Boolean] - Right hand boolean
        Returns: [Boolean] - Resulting value
    
    GateNot(*args, **kwargs)
        Perform boolean negation (NOT gate).
        Input:
                a [Boolean] - Boolean value
        Returns: [Boolean] - Inverse of {A}
    
    GateOr(*args, **kwargs)
        Perform boolean disjunction (OR gate).
        Input:
                a (in, optional) [Boolean] - First boolean for OR operation
                b (in, optional) [Boolean] - Second boolean for OR operation
        Returns: [Boolean] - Resulting value
    
    GateXnor(*args, **kwargs)
        Perform boolean biconditional (XNOR gate).
        Input:
                a [Boolean] - Left hand boolean
                b [Boolean] - Right hand boolean
        Returns: [Boolean] - Resulting value
    
    GateXor(*args, **kwargs)
        Perform boolean exclusive disjunction (XOR gate).
        Input:
                a [Boolean] - Left hand boolean
                b [Boolean] - Right hand boolean
        Returns: [Boolean] - Resulting value
    
    Geodesic(*args, **kwargs)
        Construct a surface geodesic between two points.
        Input:
                surface [Surface] - Base surface for geodesic
                start [Point] - Start point of geodesic
                end [Point] - End point of geodesic
        Returns: [Curve] - Surface geodesic
    
    GoldenRatio(*args, **kwargs)
        Returns a factor of the golden ratio (Phi).
        Input:
                factor [Number] - Factor to be multiplied by Phi
        Returns: [Number] - Output value
    
    Grab(*args, **kwargs)
        This lets you drag Kangaroo particles in Rhino viewports
        Input:
                on [Boolean] - When on, drag vertices in the Rhino viewport with LMB
                strength [Number] - Strength
                range [Number] - Maximum distance from which to grab points
        Returns: [Generic Data] - Connect to Goals input
    
    Gradient(*args, **kwargs)
        Represents a multiple colour gradient
        Input:
                lower_limit [Number] - Lower limit of gradient range
                upper_limit [Number] - Upper limit of gradient range
                parameter [Number] - Parameter along gradient range
        Returns: [Colour] - Colour along gradient at parameter
    
    GradientColourStop(*args, **kwargs)
        Gradient Colour Stop
        Input:
                color_stop (in, optional) [Colour Stop] - Color Stop is defined by a color at a given parameter
                colour (in, optional) [Colour] - Colour
                position (in, optional) [Number] - Numeric parameter of the colour [0.0..1.0]
        Returns:
                color_stop [Colour Stop] - Color Stop is defined by a color at a given parameter
                colour [Colour] - Colour
                position [Number] - Numeric parameter of the colour [0.0..1.0]
    
    GradientHatch(*args, **kwargs)
        Create a gradient hatch
        Input:
                boundaries [Curve] - Boundary curves for hatch objects
                axis [Line] - Gradient axis
                colour_1 [Colour] - Colour at start of axis.
                colour_2 [Colour] - Colour at end of axis.
    
    GraftTree(*args, **kwargs)
        Graft a data tree by adding an extra branch for every item.
        Input:
                tree [Generic Data] - Data tree to graft
        Returns: [Generic Data] - Grafted data tree
    
    GreaterThanFilter(*args, **kwargs)
        Create a filter that determines if a value is greater than another
        Input:
                key [Text] - The key to use as a filtering criteria
                value [Generic Data] - The value to compare
        Returns:
                greater_than [Predicate] - A filter that determines if a value is greater than another
                …_or_equal [Predicate] - A filter that determines if a value is greater than or equal to another
    
    Group(*args, **kwargs)
        Group a geometry set
        Input:
                geometry [Geometry] - Geometry to group
        Returns: [Group] - Grouped objects
    
    GroupContent(*args, **kwargs)
        Group content by key
        Input:
                content [Model Content] - The content to group
                key [Text] - The key to use as a grouping criteria
        Returns:
                content [Model Content] - Input content grouped by value
                values [Generic Data] - The sorted list of values under key
    
    Hexagonal(*args, **kwargs)
        2D grid with hexagonal cells
        Input:
                plane [Plane] - Base plane for grid
                size [Number] - Size of hexagon radius
                extent_x [Integer] - Number of grid cells in base plane x directions
                extent_y [Integer] - Number of grid cells in base plane y directions
        Returns:
                cells [Curve] - Grid cell outlines
                points [Point] - Points at grid centers
    
    HideModelLayer(*args, **kwargs)
        Defines layer visibility for model viewports and new details.
        Input:
                layer [Model Layer] - Model Layer
                model (in, optional) [Boolean] - Defines if the input layer(s) is hidden in the model
                new_detail (in, optional) [Boolean] - Defines if the input layer(s) is hidden on new details
        Returns:
                layer [Model Layer] - Model Layer
                model [Boolean] - Defines if the input layer(s) is hidden in the model
                new_detail [Boolean] - Defines if the input layer(s) is hidden on new details
    
    Hinge(*args, **kwargs)
        Hinge
        Input:
                foldstart (in, optional) [Point] - FoldStart
                foldend (in, optional) [Point] - FoldEnd
                tip1 (in, optional) [Point] - Tip1
                tip2 (in, optional) [Point] - Tip2
                restangle (in, optional) [Number] - Rest angle - if none supplied, current angle will be used
                strength [Number] - Strength
        Returns: [Generic Data] - Hinge out
    
    HingePoints(*args, **kwargs)
        Get the 4 points for each internal edge to use in a Hinge Force
        Input:
                mesh [Mesh] - Mesh to get points for
        Returns:
                1 [Point] - Point 1
                2 [Point] - Point 2
                3 [Point] - Point 3
                4 [Point] - Point 4
    
    HorizontalFrame(*args, **kwargs)
        Get a horizontally aligned frame along a curve at a specified parameter.
        Input:
                curve [Curve] - Curve to evaluate
                parameter [Number] - Parameter on curve domain to evaluate
        Returns: [Plane] - Horizontal curve frame at {t}
    
    HorizontalFrames(*args, **kwargs)
        Generate a number of equally spaced, horizontally aligned curve frames.
        Input:
                curve [Curve] - Curve to divide
                count [Integer] - Number of segments
        Returns:
                frames [Plane] - Curvature frames
                parameters [Number] - Parameter values at division points
    
    ImageCircles(*args, **kwargs)
        Circle packing with sizes from image colours
        Input:
                points [Point] - Initial circle centre locations
                mesh [Mesh] - Coloured mesh - darker areas will get smaller circles
                min [Number] - Smallest circle radius
                max [Number] - Largest circle radius
                curves (in, optional) [Curve] - Optional collision curves
                strength [Number] - Strength
        Returns: [Generic Data] - ImageCircles Goal
    
    Import3DM(*args, **kwargs)
        Import geometry into a RhinoDoc
        Input:
                file [Text] - Location of file
                layer [Text] - Layer name filter
                name [Text] - Object name filter
        Returns: [Geometry] - Imported geometry
    
    ImportContent(*args, **kwargs)
        Import a model from file
        Input:
                file_path [Text] - Location of file.
        Returns:
                model_transform [Transform] - Model to world transform
                objects [Model Object] - Imported objects
                layers [Model Layer] - Imported layers
                linetypes [Model Linetype] - Imported Linetypes
                hatch_patterns [Model Hatch Pattern] - Imported Hatch Patterns
                annotation_styles [Model Annotation Style] - Imported Annotation Styles
                materials [Model Material] - Imported Materials
                block_definitions [Model Block Definition] - Block Definitions
    
    ImportCoordinates(*args, **kwargs)
        Import point coordinates from generic text files.
        Input:
                file [Text] - Location of point text file
                separator [Text] - Coordinate fragment separator
                comment (in, optional) [Text] - Optional comment line start
                x_index [Integer] - Index of point X coordinate
                y_index [Integer] - Index of point Y coordinate
                z_index [Integer] - Index of point Z coordinate
        Returns: [Point] - Imported points
    
    ImportHatchPattern(*args, **kwargs)
        Import Hatch Pattern
        Input:
                file_path [Text] - The path to a hatch pattern file (*.pat)
        Remove this input to load default "hatchpatterns.txt" file
        Returns: [Model Hatch Pattern] - The Rhino model hatch pattern.
    
    ImportImage(*args, **kwargs)
        Import image data from bmp, jpg or png files.
        Input:
                file [Text] - Location of image file
                rectangle (in, optional) [Rectangle] - Optional image destination rectangle
                x_samples (in, optional) [Integer] - Number of samples along image X direction
                y_samples (in, optional) [Integer] - Number of samples along image Y direction
        Returns: [Mesh] - A mesh representation of the image
    
    ImportModelBlockDefinition(*args, **kwargs)
        Import a file and create a new block definition.
        Input:
                file_path [Text] - Location of the file to use for the block definition.
                update_type [Integer] - Block Definition Update Type: 
        0) Embedded
        2) Linked and Embedded
        3) Linked
                name (in, optional) [Text] - The name of the block definition.
        Returns: [Model Block Definition] - Block Definition
    
    ImportModelEnvironment(*args, **kwargs)
        Import Model Environment
        Input:
                file_path [Text] - The path to a rhino environment file (*.renv)
        Relative paths are solved using Rhino suport folder.
        Returns: [Model Environment] - The Rhino model environtment.
    
    ImportModelMaterial(*args, **kwargs)
        Import Model Material
        Input:
                file_path [Text] - The path to a rhino material file (*.rmtl)
        Relative paths are solved using Rhino suport folder.
        Returns: [Model Material] - The Rhino model material.
    
    ImportPDB(*args, **kwargs)
        Import data from Protein Data Bank *.pdb files.
        Input:
                file [Text] - Location of *.pdb file
        Returns:
                atoms [Atom] - All atoms in the PDB file
                bonds [Line] - Bonds between atoms
    
    ImportSHP(*args, **kwargs)
        Import data from GIS *.shp files.
        Input:
                file [Text] - Location of *.shp file
        Returns:
                points [Point] - Points in file
                curves [Curve] - Curves in file
                regions [Brep] - Regions in file
    
    InCircle(*args, **kwargs)
        Create the incircle of a triangle.
        Input:
                corner_a [Point] - First corner of triangle
                corner_b [Point] - Second corner of triangle
                corner_c [Point] - Third corner of triangle
        Returns:
                circle [Circle] - Resulting circle
                plane [Plane] - Circle plane
                radius [Number] - Circle radius
    
    InEllipse(*args, **kwargs)
        Create the inscribed ellipse (Steiner ellipse) of a triangle.
        Input:
                corner_a [Point] - First corner of triangle
                corner_b [Point] - Second corner of triangle
                corner_c [Point] - Third corner of triangle
        Returns:
                ellipse [Curve] - Resulting ellipse
                plane [Plane] - Ellipse plane
    
    Incentre(*args, **kwargs)
        Generate the triangle incentre from angle bisectors.
        Input:
                point_a [Point] - First triangle corner
                point_b [Point] - Second triangle corner
                point_c [Point] - Third triangle corner
        Returns:
                incentre [Point] - Incentre point for triangle
                bisector_a [Line] - Perpendicular bisector line emanating from corner A
                bisector_b [Line] - Perpendicular bisector line emanating from corner B
                bisector_c [Line] - Perpendicular bisector line emanating from corner C
    
    Includes(*args, **kwargs)
        Test a numeric value to see if it is included in the domain
        Input:
                value [Number] - Value to test for inclusion
                domain [Domain] - Domain to test with
        Returns:
                includes [Boolean] - True if the value is included in the domain
                deviation [Number] - Distance between the value and the nearest value inside the domain
    
    InsertItems(*args, **kwargs)
        Insert a collection of items into a list.
        Input:
                list [Generic Data] - List to modify
                item (in, optional) [Generic Data] - Items to insert. If no items are supplied, nulls will be inserted.
                indices [Integer] - Insertion index for each item
                wrap [Boolean] - If true, indices will be wrapped
        Returns: [Generic Data] - List with inserted values
    
    IntegerDivision(*args, **kwargs)
        Mathematical integer division
        Input:
                a [Integer] - Item to divide (dividend)
                b [Integer] - Item to divide with (divisor)
        Returns: [Integer] - Result of integer division
    
    Interpolate(*args, **kwargs)
        Create an interpolated curve through a set of points.
        Input:
                vertices [Point] - Interpolation points
                degree [Integer] - Curve degree
                periodic [Boolean] - Periodic curve
                knotstyle [Integer] - Knot spacing (0=uniform, 1=chord, 2=sqrtchord)
        Returns:
                curve [Curve] - Resulting nurbs curve
                length [Number] - Curve length
                domain [Domain] - Curve domain
    
    InterpolateDate(*args, **kwargs)
        Interpolate between two dates or times.
        Input:
                date_a [Time] - First date
                date_b [Time] - Second date
                interpolation [Number] - Interpolation factor
        Returns: [Time] - Interpolated Date & Time
    
    Interpolatedata(*args, **kwargs)
        Interpolate a collection of data.
        Input:
                data [Generic Data] - Data to interpolate (simple data types only).
                parameter [Number] - Normalised interpolation parameter.
        Returns: [Generic Data] - Interpolated value.
    
    Interpolatet(*args, **kwargs)
        Create an interpolated curve through a set of points with tangents.
        Input:
                vertices [Point] - Interpolation points
                tangent_start [Vector] - Tangent at start of curve
                tangent_end [Vector] - Tangent at end of curve
                knotstyle [Integer] - Knot spacing (0=uniform, 1=chord, 2=sqrtchord)
        Returns:
                curve [Curve] - Resulting nurbs curve
                length [Number] - Curve length
                domain [Domain] - Curve domain
    
    IntersectionFilter(*args, **kwargs)
        Combine multiple filters together into an intersection which returns true only if all input filters evaluate to true.
        Input:
                filters [Predicate] - A list of filters to intersect.
        Returns: [Predicate] - A filter that returns true only if all input filters evalute to true.
    
    InverseTransform(*args, **kwargs)
        Invert a transformation.
        Input:
                transform [Transform] - Transformation to inverse
        Returns: [Transform] - Inversed transformation
    
    InvertMatrix(*args, **kwargs)
        Invert a matrix
        Input:
                matrix [Matrix] - Matrix to invert
                tolerance [Number] - Zero-tolerance for inversion
        Returns:
                matrix [Matrix] - Inverted matrix
                success [Boolean] - Boolean indicating inversion success
    
    IronPython2Script(*args, **kwargs)
        IronPython 2 scripting component
        Input:
                x (in, optional) [Generic Data] - No conversion
                y (in, optional) [Generic Data] - No conversion
        Returns:
                out [Text] - Standard output and error contents collected during script run
                a [Generic Data] - No conversion
    
    IsPlanar(*args, **kwargs)
        Test whether a surface is planar
        Input:
                surface [Surface] - Surface to test for planarity
                interior [Boolean] - Limit planarity test to the interior of trimmed surfaces
        Returns:
                planar [Boolean] - Planarity flag of surface
                plane [Plane] - Surface plane
    
    IsoCurve(*args, **kwargs)
        Construct {uv} isocurves on a surface.
        Input:
                surface [Surface] - Base surface
                uv_point [Point] - {uv} coordinate on surface for isocurve extraction.
        Returns:
                u_isocurve [Curve] - Isocurves in {u} direction
                v_isocurve [Curve] - Isocurves in {v} direction
    
    IsoVist(*args, **kwargs)
        Compute an isovist sampling at a location
        Input:
                plane [Plane] - Sampling plane and origin
                count [Integer] - Sample count
                radius [Number] - Sample radius
                obstacles [Geometry] - Obstacle outlines
        Returns:
                points [Point] - Intersection points of the sample rays with the obstacles
                distance [Number] - List of intersection distances
                index [Integer] - List of obstacle indices for each hit, or -1 if no obstacle was hit
    
    IsoVistRay(*args, **kwargs)
        Compute a single isovist sample at a location
        Input:
                sample [Line] - Sampling ray
                radius [Number] - Sample radius
                obstacles [Geometry] - Obstacle outlines (curves, planes, meshes and breps are allowed)
        Returns:
                point [Point] - Intersection point of the sample ray with the obstacles
                distance [Number] - Distance from ray start to intersection point
                index [Integer] - Obstacle index for hit, or -1 if no obstacle was hit
    
    Isothermic(*args, **kwargs)
        Make a quad mesh S-Isothermic, as described in the paper 'Quasiisothermic Mesh Layout' by Sechelmann, Rörig & Bobenko
        Input:
                mesh [Mesh] - A quad mesh to make isothermic
                strength [Number] - Strength
        Returns: [Generic Data] - Isothermic goals
    
    Isotrim(*args, **kwargs)
        Extract an isoparametric subset of a surface.
        Input:
                surface [Surface] - Base surface
                domain [Domain²] - Domain of subset
        Returns: [Surface] - Subset of base surface
    
    ItemIndex(*args, **kwargs)
        Retrieve the index of a certain item in a list.
        Input:
                list [Generic Data] - List to search
                item [Generic Data] - Item to search for
        Returns: [Integer] - The index of item in the list, or -1 if the item could not be found.
    
    Jitter(*args, **kwargs)
        Randomly shuffles a list of values.
        Input:
                list [Generic Data] - Values to shuffle
                jitter [Number] - Shuffling strength. (0.0 = no shuffling, 1.0 = complete shuffling)
                seed [Integer] - Seed of shuffling engine
        Returns:
                values [Generic Data] - Shuffled values
                indices [Integer] - Index map of shuffled items
    
    JoinCurves(*args, **kwargs)
        Join as many curves as possible
        Input:
                curves [Curve] - Curves to join
                preserve [Boolean] - Preserve direction of input curves
        Returns: [Curve] - Joined curves and individual curves that could not be joined.
    
    Kaleidoscope(*args, **kwargs)
        Apply a kaleidoscope transformation to an object.
        Input:
                geometry (in, optional) [Geometry] - Base geometry
                plane [Plane] - Kaleidoscope plane
                segments [Integer] - Kaleidoscope segments.
        Returns:
                geometry [Geometry] - Mirrored geometry
                transform [Transform] - Transformation data
    
    KeyValueSearch(*args, **kwargs)
        Extract an item from a collection using a key-value match
        Input:
                keys [Generic Data] - A list of key values.
                values [Generic Data] - A list of value data, one for each key.
                search [Generic Data] - A key value to search for
        Returns: [Generic Data] - Resulting item in the value list that matches the Search key
    
    KinkyCurve(*args, **kwargs)
        Construct an interpolated curve through a set of points with a kink angle threshold.
        Input:
                vertices [Point] - Interpolation points
                degree [Integer] - Curve degree
                angle [Number] - Kink angle threshold (in radians)
        Returns:
                curve [Curve] - Resulting nurbs curve
                length [Number] - Curve length
                domain [Domain] - Curve domain
    
    KnotVector(*args, **kwargs)
        Construct a nurbs curve knot vector.
        Input:
                count [Integer] - Control point count.
                degree [Integer] - Curve Degree.
                periodic [Boolean] - Curve periodicity
        Returns: [Number] - Nurbs Knot Vector.
    
    LargerThan(*args, **kwargs)
        Larger than (or equal to)
        Input:
                first_number [Number] - Number to test
                second_number [Number] - Number to test against
        Returns:
                larger_than [Boolean] - True if A > B
                …_or_equal_to [Boolean] - True if A >= B
    
    Leader(*args, **kwargs)
        Leader
        Input:
                leader (in, optional) [Leader] - The Rhino leader
                plane (in, optional) [Plane] - Plane that this annotation lies on.
                curve (in, optional) [Curve] - The curve used to convert into a leader
                text (in, optional) [Text] - The text used for the leader
                style (in, optional) [Model Annotation Style] - The annotation style.
        Returns:
                leader [Leader] - The Rhino leader
                plane [Plane] - Plane that this annotation lies on.
                curve [Curve] - The curve used to convert into a leader
                text [Text] - The text used for the leader
                style [Model Annotation Style] - The annotation style.
    
    Legend(*args, **kwargs)
        Display a legend consisting of Tags and Colours
        Input:
                colour (in, optional) [Colour] - Legend colours
                tags (in, optional) [Text] - Legend tags
                rectangle (in, optional) [Rectangle] - Optional legend rectangle in 3D space
    
    Length(*args, **kwargs)
        Measure the length of a curve.
        Input:
                curve [Curve] - Curve to measure
        Returns: [Number] - Curve length
    
    LengthDomain(*args, **kwargs)
        Measure the length of a curve subdomain.
        Input:
                curve [Curve] - Curve to measure
                domain [Domain] - Subdomain of curve to measure
        Returns: [Number] - Curve length on sub domain
    
    LengthLine(*args, **kwargs)
        Length(Line)
        Input:
                line (in, optional) [Curve] - Line
                length (in, optional) [Number] - Length - If none provided, starting length will be used
                strength [Number] - Strength
        Returns: [Generic Data] - Spring out
    
    LengthParameter(*args, **kwargs)
        Measure the length of a curve to and from a parameter.
        Input:
                curve [Curve] - Curve to measure
                parameter [Number] - Parameter along curve
        Returns:
                length [Number] - Curve length from start to parameter
                length [Number] - Curve length from parameter to end
    
    LengthRatio(*args, **kwargs)
        Maintain a fixed ratio between the lengths of a pair of lines
        Input:
                linea (in, optional) [Line] - First line segment
                lineb (in, optional) [Line] - Second line segment
                ratio (in, optional) [Number] - Length B divided by Length A
                strength [Number] - Strength
        Returns: [Generic Data] - Angle out
    
    LengthSnap(*args, **kwargs)
        Snap length to whole number multiples of a given number
        Input:
                line (in, optional) [Curve] - Line
                factor (in, optional) [Number] - Length will become an integer multiple of this
                strength [Number] - Strength
        Returns: [Generic Data] - Snap out
    
    LessThanFilter(*args, **kwargs)
        Create a filter that determines if a value is less than another
        Input:
                key [Text] - The key to use as a filtering criteria
                value [Generic Data] - The value to compare
        Returns:
                less_than [Predicate] - A filter that determines if a value is less than another
                …_or_equal [Predicate] - A filter that determines if a value is less than or equal to another
    
    LightAttributes(*args, **kwargs)
        Modify or inspect the attributes of a light.
        Input:
                light [Light] - The light
                enabled (in, optional) [Boolean] - Defines if the light is turned on (True) or off (False)
                colour (in, optional) [Colour] - Diffuse color
                intensity (in, optional) [Number] - Light intensity
        [0.0..∞)
                shadow_intensity (in, optional) [Number] - Shadow intensity
        [0.0..1.0]
                falloff (in, optional) [Integer] - Falloff: 
        0) Constant
        1) Linear
        2) Inverse Squared
        
        Returns:
                light [Light] - The light
                enabled [Boolean] - Defines if the light is turned on (True) or off (False)
                colour [Colour] - Diffuse color
                intensity [Number] - Light intensity
        [0.0..∞)
                shadow_intensity [Number] - Shadow intensity
        [0.0..1.0]
                falloff [Integer] - Falloff: 
        0) Constant
        1) Linear
        2) Inverse Squared
    
    Line(*args, **kwargs)
        Create a line between two points.
        Input:
                start_point [Point] - Line start point
                end_point [Point] - Line end point
        Returns: [Line] - Line segment
    
    Line2Plane(*args, **kwargs)
        Create a line between two planes.
        Input:
                line [Line] - Guide line.
                plane_a [Plane] - First plane to intersect with the guide.
                plane_b [Plane] - Second plane to intersect with the guide.
        Returns: [Line] - Line segment between A and B
    
    Line4Pt(*args, **kwargs)
        Create a line from four points.
        Input:
                line [Line] - Guide line.
                point_a [Point] - First point to project onto the guide.
                point_b [Point] - Second point to project onto the guide.
        Returns: [Line] - Line segment between A and B
    
    LineCharge(*args, **kwargs)
        Create a field due to a line charge
        Input:
                line [Line] - Geometry of line segment charge
                charge [Number] - Charge of point object
                bounds (in, optional) [Box] - Optional bounds for the field
        Returns: [Field] - Field due to line charge
    
    LineDimension(*args, **kwargs)
        Create a distance annotation along a line.
        Input:
                line [Line] - Dimension base line
                text [Text] - Dimension text
                size [Number] - Dimension size
    
    LineSDL(*args, **kwargs)
        Create a line segment defined by start point, tangent and length.}
        Input:
                start [Point] - Line start point
                direction [Vector] - Line tangent (direction)
                length [Number] - Line length
        Returns: [Line] - Line segment
    
    LineXLine(*args, **kwargs)
        Solve intersection events for two lines.
        Input:
                line_1 [Line] - First line for intersection
                line_2 [Line] - Second line for intersection
        Returns:
                param_a [Number] - Parameter on line A
                param_b [Number] - Parameter on line B
                point_a [Point] - Point on line A
                point_b [Point] - Point on line B
    
    LineXPlane(*args, **kwargs)
        Solve intersection event for a line and a plane.
        Input:
                line [Line] - Base line
                plane [Plane] - Intersection plane
        Returns:
                point [Point] - Intersection event
                param_l [Number] - Parameter {t} on infinite line
                param_p [Point] - Parameter {uv} on plane
    
    Line_Line(*args, **kwargs)
        Create a plane from two line segments.
        Input:
                line_a [Line] - First line constraint. Plane origin will be at line start.
                line_b [Line] - Second line constraint. Line B should be co-planar with but not parallel to Line A.
        Returns: [Plane] - Plane definition
    
    Line_Pt(*args, **kwargs)
        Create a plane from a line and a point.
        Input:
                line [Line] - Line constraint. Plane origin will be at line startpoint. Plane x-axis will be parallel to line direction.
                point [Point] - Point on plane. Point must not be co-linear with line.
        Returns: [Plane] - Plane definition
    
    LinearArray(*args, **kwargs)
        Create a linear array of geometry.
        Input:
                geometry (in, optional) [Geometry] - Base geometry
                direction [Vector] - Linear array direction and interval
                count [Integer] - Number of elements in array.
        Returns:
                geometry [Geometry] - Arrayed geometry
                transform [Transform] - Transformation data
    
    LinearDimension(*args, **kwargs)
        Linear Dimension
        Input:
                linear_dimension (in, optional) [Linear Dimension] - The Rhino linear dimension
                base_line (in, optional) [Line] - Dimension base line
                point_a (in, optional) [Point] - First dimension point
                point_b (in, optional) [Point] - Second dimension point
                style (in, optional) [Model Annotation Style] - The annotation style.
        Returns:
                linear_dimension [Linear Dimension] - The Rhino linear dimension
                base_line [Line] - Dimension base line
                point_a [Point] - First dimension point
                point_b [Point] - Second dimension point
                style [Model Annotation Style] - The annotation style.
    
    LinearLight(*args, **kwargs)
        Linear Light
        Input:
                linear_light (in, optional) [Light] - The Rhino linear light
                line (in, optional) [Line] - The axis of the linear light cylinder
        Returns:
                linear_light [Light] - The Rhino linear light
                line [Line] - The axis of the linear light cylinder
    
    ListItem(*args, **kwargs)
        Retrieve a specific item from a list.
        Input:
                list [Generic Data] - Base list
                index [Integer] - Item index
                wrap [Boolean] - Wrap index to list bounds
        Returns: [Generic Data] - Item at {i'}
    
    ListLength(*args, **kwargs)
        Measure the length of a list.
        Input:
                list [Generic Data] - Base list
        Returns: [Integer] - Number of items in L
    
    LiveSoap(*args, **kwargs)
        For generating minimal and CMC (zero and constant mean curvature respectively) meshes which adapt their connectivity during relaxation to maintain triangle quality
        Input:
                mesh [Mesh] - The mesh to minimize
                usevolume [Boolean] - If true this will find a CMC mesh with a given volume. If false it finds a minimal surface
                volumechange [Number] - Volume difference relative to starting mesh. Ignored if UseVolume is false
                strength [Number] - Strength
                reset [Boolean] - Reset the meshing
        Returns: [Generic Data] - LiveSoap out
    
    Load(*args, **kwargs)
        Load
        Input:
                point (in, optional) [Generic Data] - Point (as either index or Point)
                force_vector [Vector] - FV
                weighting [Number] - Scalar weighting factor (for most purposes you can leave this as the default 1.0)
        Returns: [Generic Data] - Unary out
    
    Loft(*args, **kwargs)
        Create a lofted surface through a set of section curves.
        Input:
                curves [Curve] - Section curves
                options [Loft Options] - Loft options
        Returns: [Brep] - Resulting Loft surfaces
    
    LoftOptions(*args, **kwargs)
        Create loft options from atomic inputs
        Input:
                closed [Boolean] - Closed loft
                adjust [Boolean] - Adjust seams
                rebuild [Integer] - Rebuild count (zero = no rebuild)
                refit [Number] - Refit tolerance (zero = no refit)
                type [Integer] - Loft type (0=Normal, 1=Loose, 2=Tight, 3=Straight, 5=Uniform)
        Returns: [Loft Options] - Loft options
    
    LogN(*args, **kwargs)
        Return the N-base logarithm of a number.
        Input:
                number [Number] - Value
                base [Number] - Logarithm base
        Returns: [Number] - Result
    
    Logarithm(*args, **kwargs)
        Compute the Base-10 logarithm of a value.
        Input:
                value [Generic Data] - Input value
        Returns: [Generic Data] - Output value
    
    LogicalAndFilter(*args, **kwargs)
        Combine two filters together using a logical AND operator
        Input:
                filter_a [Predicate] - The first filter
                filter_b [Predicate] - The second filter
        Returns: [Predicate] - A combined filter that determine if Filter A and Filter B pass
    
    LogicalNotFilter(*args, **kwargs)
        Create a filter as the logical NOT of another.
        Input:
                filter [Predicate] - The filter to negate
        Returns: [Predicate] - A combined filter that determine if input Filter does not pass
    
    LogicalOrFilter(*args, **kwargs)
        Combine two filters together using a logical OR operator.
        Input:
                filter_a [Predicate] - The first filter
                filter_b [Predicate] - The second filter
        Returns: [Predicate] - A combined filter that determine if Filter A or Filter B pass
    
    LongestList(*args, **kwargs)
        Grow a collection of lists to the longest length amongst them
        Input:
                list_(a) (in, optional) [Generic Data] - List (A) to operate on
                list_(b) (in, optional) [Generic Data] - List (B) to operate on
        Returns:
                list_(a) [Generic Data] - Adjusted list (A)
                list_(b) [Generic Data] - Adjusted list (B)
    
    Maelstrom(*args, **kwargs)
        Spirally deforms objects as if they were caught in a whirlpool
        Input:
                geometry [Geometry] - Base geometry
                plane [Plane] - Spiral base plane.
                first [Number] - First radius
                second [Number] - Second radius
                angle [Number] - Coil angle in radians
                rigid [Boolean] - Geometry will not be deformed as it is transformed
        Returns: [Geometry] - Morphed geometry
    
    MagnetSnap(*args, **kwargs)
        Snap points together according to proximity
        Input:
                points (in, optional) [Point] - List of points to apply snap between
                range [Number] - The distance at which the snap activates
                strength [Number] - Strength
        Returns: [Generic Data] - S
    
    Make2D(*args, **kwargs)
        Create a hidden line drawing from geometry
        Input:
                geometry [Geometry] - Geometry to include (Breps, Meshes and Curves only).
                clipping_planes (in, optional) [Plane] - Optional clipping planes.
                view [View] - Make2D projection details
                tangent_edges [Boolean] - Whether or not to compute tangent edges.
                tangent_seams [Boolean] - Whether or not to compute tangent seams.
        Returns:
                visible_curves [Curve] - List of visible curves
                visible_index [Integer] - For each visible curve, index of source object
                visible_type [Text] - For each visible curve, type description
                hidden_curves [Curve] - List of hidden curves
                hidden_index [Integer] - For each hidden curve, index of source object
                hidden_type [Text] - For each hidden curve, type description
    
    Make2DParallelView(*args, **kwargs)
        Define a parallel view for a Make2D solution
        Input:
                projection [Rectangle] - View projection.
        Returns: [View] - Parallel view
    
    Make2DPerspectiveView(*args, **kwargs)
        Define a perspective view for a Make2D solution
        Input:
                camera [Point] - Camera position
                frame [Rectangle] - Projection framing.
        Returns: [View] - Parallel view
    
    MaptoSurface(*args, **kwargs)
        Map a curve onto a surface via control points.
        Input:
                curve [Curve] - Curve to map
                source [Surface] - Base surface for initial coordinate space
                target [Surface] - Surface for target coordinate space
        Returns: [Curve] - Mapped curve
    
    MarkerDimension(*args, **kwargs)
        Create a text annotation at a point
        Input:
                line [Line] - Dimension base line
                text [Text] - Dimension text
                size [Number] - Dimension size
    
    MassAddition(*args, **kwargs)
        Perform mass addition of a list of items
        Input:
                input [Generic Data] - Input values for mass addition.
        Returns:
                result [Generic Data] - Result of mass addition
                partial_results [Generic Data] - List of partial results
    
    MassMultiplication(*args, **kwargs)
        Perform mass multiplication of a list of items
        Input:
                input [Generic Data] - Input values for mass multiplication.
        Returns:
                result [Generic Data] - Result of mass multiplication
                partial_results [Generic Data] - List of partial results
    
    MatchText(*args, **kwargs)
        Match a text against a pattern
        Input:
                text [Text] - Text to match
                pattern (in, optional) [Text] - Optional wildcard pattern for matching
                regex (in, optional) [Text] - Optional RegEx pattern for matching
                case [Boolean] - Compare using case-sensitive matching
        Returns: [Boolean] - True if the text adheres to all supplied patterns
    
    MatchTextFilter(*args, **kwargs)
        Create a filter that determines if a text value matches a pattern.
        Input:
                key [Text] - The key to use as a filtering criteria
                pattern [Text] - The text pattern to match
                case (in, optional) [Boolean] - Compare using case-sensitive matching
                culture (in, optional) [Culture] - Culture to use for string comparison
        Returns: [Predicate] - A filter that determine if a text matches a pattern
    
    MatchTree(*args, **kwargs)
        Match one data tree with another.
        Input:
                tree [Generic Data] - Data tree to modify
                guide [Generic Data] - Data tree to match
        Returns: [Generic Data] - Matched data tree containing the data of T but the layout of G
    
    Maximum(*args, **kwargs)
        Return the greater of two items.
        Input:
                a [Generic Data] - First item for comparison
                b [Generic Data] - Second item for comparison
        Returns: [Generic Data] - The greater of A and B
    
    MbiusTransformation(*args, **kwargs)
        3d Möbius Transformations of any geometry using 4d rotation
        Input:
                geometry [Generic Data] - Input Geometry to transform
                circle [Circle] - Circle defining the transformation. Points on this circle will stay on it, and all other points are pulled through and around it
                t [Number] - Amount of transformation. 2π brings it back to the original
                q [Number] - This parameter controls the rotation around the axis of the circle. Set to 1 for Isoclinic rotations
                fixsphere [Boolean] - If true, this transforms and scales the geometry so that points on the sphere defined by the input circle stay on that sphere
        Returns: [Geometry] - Transformed Geometry
    
    MemberIndex(*args, **kwargs)
        Find the occurences of a specific member in a set.
        Input:
                set [Generic Data] - Set to operate on.
                member [Generic Data] - Member to search for.
        Returns:
                index [Integer] - Indices of member.
                count [Integer] - Number of occurences of the member.
    
    Merge(*args, **kwargs)
        Merge a bunch of data streams
        Input:
                data_1 (in, optional) [Generic Data] - Data stream 1
                data_2 (in, optional) [Generic Data] - Data stream 2
        Returns: [Generic Data] - Result of merge
    
    MergeFaces(*args, **kwargs)
        Merge all adjacent co-planar faces in a brep
        Input:
                brep [Brep] - Brep to simplify
        Returns:
                breps [Brep] - Simplified Brep
                before [Integer] - Number of faces before simplification
                after [Integer] - Number of faces after simplification
    
    MergeFields(*args, **kwargs)
        Merge a collection of fields into one
        Input:
                fields [Field] - Fields to merge
        Returns: [Field] - Merged field
    
    MergeGroup(*args, **kwargs)
        Merge two geometry sets
        Input:
                group_a [Group] - First group
                group_b [Group] - Second group
        Returns: [Group] - Merged group
    
    MeshBox(*args, **kwargs)
        Create a mesh box.
        Input:
                base [Box] - Base box
                x_count [Integer] - Face count in {x} direction
                y_count [Integer] - Face count in {y} direction
                z_count [Integer] - Face count in {z} direction
        Returns: [Mesh] - The 3D mesh box
    
    MeshBrep(*args, **kwargs)
        Create a mesh that approximates Brep geometry
        Input:
                brep [Brep] - Brep geometry
                settings [MeshParameters] - Settings to be used by meshing algorithm
        Returns: [Mesh] - Mesh approximation
    
    MeshClosestPoint(*args, **kwargs)
        Finds the closest point on a mesh
        Input:
                point [Point] - Point to search from
                mesh [Mesh] - Mesh to search for closest point
        Returns:
                point [Point] - Location on mesh closest to search point
                index [Integer] - Face index of closest point
                parameter [Mesh Parameter] - Mesh parameter for closest point
    
    MeshColours(*args, **kwargs)
        Assign a repeating colour pattern to a mesh object.
        Input:
                mesh [Mesh] - Base mesh
                colours [Colour] - Colour pattern
        Returns: [Mesh] - Coloured mesh
    
    MeshCorners(*args, **kwargs)
        Extract corners sharper than some angle
        Input:
                mesh [Mesh] - Mesh
                angle [Number] - Interior angle below which a vertex is considered a corner
        Returns: [Point] - Corners
    
    MeshDifference(*args, **kwargs)
        Perform a solid difference on two sets of meshes
        Input:
                meshes_a [Mesh] - First mesh set
                meshes_b [Mesh] - Second mesh set
        Returns: [Mesh] - Difference result of A-B
    
    MeshDirection(*args, **kwargs)
        Sort the face directions of a mesh
        Input:
                mesh [Mesh] - Mesh to sort
        Returns: [Mesh] - Mesh with face directions sorted
    
    MeshEdges(*args, **kwargs)
        Get all the edges of a mesh
        Input:
                mesh [Mesh] - Mesh for edge extraction
        Returns:
                naked_edges [Line] - Edges with valence 1 (a single adjacent face)
                interior_edges [Line] - Edges with valence 2 (two adjacent faces)
                non-manifold_edges [Line] - Edges with valence 3 or higher
    
    MeshEval(*args, **kwargs)
        Evaluate a mesh at a given parameter
        Input:
                mesh [Mesh] - Mesh to evaluate
                parameter [Mesh Parameter] - Mesh parameter for evaluation
        Returns:
                point [Point] - Point at mesh parameter
                normal [Vector] - Normal vector at mesh parameter
                colour [Colour] - Colour at mesh parameter
    
    MeshInclusion(*args, **kwargs)
        Test a point for Mesh inclusion
        Input:
                mesh [Mesh] - Mesh for inclusion test (only closed meshes will be considered)
                point [Point] - Point for inclusion test
                strict [Boolean] - If true, then the inclusion is strict
        Returns: [Boolean] - Inside flag for point inclusion
    
    MeshIntersection(*args, **kwargs)
        Perform a solid intersection on a set of meshes
        Input:
                meshes_a [Mesh] - First mesh set
                meshes_b [Mesh] - Second mesh set
        Returns: [Mesh] - Intersection result of A&B
    
    MeshJoin(*args, **kwargs)
        Join a set of meshes into a single mesh
        Input:
                meshes [Mesh] - Meshes to join
        Returns: [Mesh] - Mesh join result
    
    MeshMap(*args, **kwargs)
        Map points from one mesh to another
        Input:
                sourcemesh [Mesh] - Mesh to map from
                targetmesh [Mesh] - Mesh to map to
                point [Point] - Point to map
                distance [Number] - maximum search distance
        Returns: [Point] - Mapped point
    
    MeshPlane(*args, **kwargs)
        Create a mesh plane.
        Input:
                boundary [Rectangle] - Rectangle describing boundary of plane
                width_count [Integer] - Number of faces along {x} direction
                height_count [Integer] - Number of faces along {y} direction
        Returns:
                mesh [Mesh] - Mesh plane
                area [Number] - Area of mesh plane
    
    MeshQuad(*args, **kwargs)
        Create a mesh quad.
        Input:
                corner_a [Integer] - Index of first face corner
                corner_b [Integer] - Index of second face corner
                corner_c [Integer] - Index of third face corner
                corner_d [Integer] - Index of fourth face corner
        Returns: [Mesh face] - Quadrangular mesh face
    
    MeshShadow(*args, **kwargs)
        Compute the shadow outline for a mesh object
        Input:
                mesh [Mesh] - Mesh for shadow casting
                light [Vector] - Direction of light rays
                plane [Plane] - Plane that receives the shadows
        Returns: [Curve] - Shadow contours
    
    MeshSphere(*args, **kwargs)
        Create a mesh sphere.
        Input:
                base [Plane] - Base plane
                radius [Number] - Radius of mesh sphere
                u_count [Integer] - Number of faces around sphere
                v_count [Integer] - Number of faces from pole to pole
        Returns: [Mesh] - Mesh sphere
    
    MeshSphereEx(*args, **kwargs)
        Create a mesh sphere from square patches.
        Input:
                base [Plane] - Base plane
                radius [Number] - Radius of mesh sphere
                count [Integer] - Number of faces along each patch edge
        Returns: [Mesh] - Mesh sphere
    
    MeshSplit(*args, **kwargs)
        Mesh Mesh split
        Input:
                mesh [Mesh] - Mesh to split
                splitters [Mesh] - Meshes to split with
        Returns: [Mesh] - Result of mesh split
    
    MeshSplitPlane(*args, **kwargs)
        Split a mesh with an infinite plane.
        Input:
                mesh [Mesh] - Mesh to split
                plane [Plane] - Splitting plane
        Returns:
                above [Mesh] - Pieces above the plane.
                below [Mesh] - Pieces below the plane.
    
    MeshSpray(*args, **kwargs)
        Assign colours to a mesh based on spray points.
        Input:
                mesh [Mesh] - Base mesh
                points [Point] - Spray points
                colours [Colour] - Colours of spray points
        Returns: [Mesh] - Sprayed mesh
    
    MeshSurface(*args, **kwargs)
        Create a Surface UV mesh
        Input:
                surface [Surface] - Surface geometry
                u_count [Integer] - Number of quads in U direction
                v_count [Integer] - Number of quads in V direction
                overhang [Boolean] - Allow faces to overhang trims
                equalize [Boolean] - Equalize span length
        Returns: [Mesh] - UV Mesh
    
    MeshTriangle(*args, **kwargs)
        Create a mesh triangle.
        Input:
                corner_a [Integer] - Index of first face corner
                corner_b [Integer] - Index of second face corner
                corner_c [Integer] - Index of third face corner
        Returns: [Mesh face] - Triangular mesh face
    
    MeshTurn(*args, **kwargs)
        Rotate the vertex order of each face
        Input:
                mesh [Mesh] - Mesh to turn faces
        Returns: [Mesh] - Mesh with faces turned
    
    MeshUnion(*args, **kwargs)
        Perform a solid union on a set of meshes
        Input:
                meshes [Mesh] - Meshes to union
        Returns: [Mesh] - Mesh solid union result
    
    MeshXCurve(*args, **kwargs)
        Mesh Curve intersection
        Input:
                mesh [Mesh] - Mesh to intersect
                curve [Curve] - Curve to intersect with
        Returns:
                points [Point] - Intersection points
                faces [Integer] - Intersection face index for each point
    
    MeshXMesh(*args, **kwargs)
        Mesh Mesh intersection
        Input:
                mesh_a [Mesh] - First mesh
                mesh_b [Mesh] - Second mesh
        Returns: [Curve] - Intersection polylines
    
    MeshXPlane(*args, **kwargs)
        Solve intersection events for a Mesh and a Plane (otherwise known as section).
        Input:
                mesh [Mesh] - Base Mesh
                plane [Plane] - Section plane
        Returns: [Curve] - Section polylines
    
    MeshXRay(*args, **kwargs)
        Intersect a mesh with a semi-infinite ray
        Input:
                mesh [Mesh] - Mesh to intersect
                point [Point] - Ray start point
                direction [Vector] - Ray direction
        Returns:
                point [Point] - First intersection point
                hit [Boolean] - Boolean indicating hit or miss
    
    MeshfromSubD(*args, **kwargs)
        Get the approximation mesh of a SubD.
        Input:
                subd [SubD] - SubD
                density [Integer] - Subdivision density [0-5]
        Returns: [Mesh] - Mesh approximation
    
    MetaBall(*args, **kwargs)
        2D Metaball isocurve through point
        Input:
                points [Point] - Point charge locations
                plane [Plane] - Metaball section plane
                point [Point] - Isocurve intersection
                accuracy (in, optional) [Number] - Isocurve sampling accuracy (leave blank for adaptive accuracy)
        Returns: [Curve] - Metaball isocurve
    
    MetaBallt(*args, **kwargs)
        2D Metaball isosurface by threshold
        Input:
                points [Point] - Point charge locations
                plane [Plane] - Metaball section plane
                threshold [Number] - Isocurve threshold value
                accuracy (in, optional) [Number] - Isocurve sampling accuracy (leave blank for default accuracy)
        Returns: [Curve] - Metaball isocurves
    
    MetaBalltCustom(*args, **kwargs)
        2D Metaball isosurface by threshold and custom charge values
        Input:
                points [Point] - Point charge locations
                charge [Number] - Point charges (positive values only)
                plane [Plane] - Metaball section plane
                threshold [Number] - Isocurve threshold value
                accuracy (in, optional) [Number] - Isocurve sampling accuracy (leave blank for default accuracy)
        Returns: [Curve] - Metaball isocurves
    
    Minimum(*args, **kwargs)
        Return the lesser of two items.
        Input:
                a [Generic Data] - First item for comparison
                b [Generic Data] - Second item for comparison
        Returns: [Generic Data] - The lesser of A and B
    
    Mirror(*args, **kwargs)
        Mirror an object.
        Input:
                geometry (in, optional) [Geometry] - Base geometry
                plane [Plane] - Mirror plane
        Returns:
                geometry [Geometry] - Mirrored geometry
                transform [Transform] - Transformation data
    
    MirrorCurve(*args, **kwargs)
        Mirror a shape in a freeform curve.
        Input:
                geometry [Geometry] - Geometry to mirror
                curve [Curve] - Mirror curve
                tangent [Boolean] - Mirror tangent (if true, mirror behaviour extends beyond curve ends)
        Returns: [Geometry] - Mirrored geometry
    
    MirrorSurface(*args, **kwargs)
        Mirror geometry in a freeform surface.
        Input:
                geometry [Geometry] - Geometry to mirror
                surface [Surface] - Mirror surface
                frame [Boolean] - Mirror frame (if true, mirror behaviour extends beyond surface edge)
        Returns: [Geometry] - Mirrored geometry
    
    ModelBasicEnvironment(*args, **kwargs)
        Model Basic Environment
        Input:
                environment (in, optional) [Model Environment] - Basic Environment
                name (in, optional) [Text] - Name
                background_colour (in, optional) [Colour] - Background Colour
                projection (in, optional) [Integer] - Projection:
        0) Planar
        1) Spherical
        2) Environment Map (Emap)
        3) Box
        4) Automatic
        5) Light Probe
        6) Cube Map
        7) Vertical Cross Cube Map
        8) Horizontal Cross Cube Map
        9) Hemispherical
        
        Returns:
                environment [Model Environment] - Basic Environment
                name [Text] - Name
                background_colour [Colour] - Background Colour
                projection [Integer] - Projection:
        0) Planar
        1) Spherical
        2) Environment Map (Emap)
        3) Box
        4) Automatic
        5) Light Probe
        6) Cube Map
        7) Vertical Cross Cube Map
        8) Horizontal Cross Cube Map
        9) Hemispherical
    
    ModelBlockDefinition(*args, **kwargs)
        Block Definition
        Input:
                block_definition (in, optional) [Model Block Definition] - Model Block Definition
                objects (in, optional) [Model Object] - Model objects used to define the block.
                name (in, optional) [Text] - The name of the block definition.
        Returns:
                block_definition [Model Block Definition] - Model Block Definition
                objects [Model Object] - Model objects used to define the block.
                name [Text] - The name of the block definition.
    
    ModelBlockInstance(*args, **kwargs)
        Block Instance
        Input:
                block_instance (in, optional) [Block Instance] - Block Instance
                transform (in, optional) [Transform] - Transform applied to Block Definition geometry
        Point and Plane are also accepted.
                block_definition (in, optional) [Model Block Definition] - Block Definition
        Returns:
                block_instance [Block Instance] - Block Instance
                transform [Transform] - Transform applied to Block Definition geometry
        Transform converts also to Point and Plane.
                block_definition [Model Block Definition] - Block Definition
    
    ModelEarthLocation(*args, **kwargs)
        Associates a model location and orientation with a latitude, longitude, and elevation value on Earth.
        Input:
                location (in, optional) [Earth Location] - Earth location
                name (in, optional) [Text] - Name of this Earth location
                anchor (in, optional) [Plane] - Plane in model coordinates to associate with the longitude, latitude, and elevation values. The origin of the plane represents the model base point, while the X-axis and Y-axis represent East and North compass directions respectively
                latitude (in, optional) [Number] - Latitude on Earth.
        -90 = South pole, 0 = Equator, +90 = North pole
                longitude (in, optional) [Number] - Longitude on Earth.
        [-180, +180]
                elevation (in, optional) [Number] - Elevation on Earth.
        In model units.
        Returns:
                location [Earth Location] - Earth location
                name [Text] - Name of this Earth location
                anchor [Plane] - Plane in model coordinates to associate with the longitude, latitude, and elevation values. The origin of the plane represents the model base point, while the X-axis and Y-axis represent East and North compass directions respectively
                latitude [Number] - Latitude on Earth.
        -90 = South pole, 0 = Equator, +90 = North pole
                longitude [Number] - Longitude on Earth.
        [-180, +180]
                elevation [Number] - Elevation on Earth.
        In model units.
    
    ModelFont(*args, **kwargs)
        Typography Font
        Input:
                font (in, optional) [Font] - Model font definition
                font_family (in, optional) [Text] - Font family name
                font_weight (in, optional) [Integer] - Font weight: 
        0) Unset
        1) Thin
        2) Ultralight
        3) Light
        4) Regular
        5) Medium
        6) Semibold
        7) Bold
        8) Ultrabold
        9) Heavy
                font_style (in, optional) [Integer] - Font style: 
        0) Unset
        1) Upright (Default style)
        2) Italic
        3) Oblique
        Returns:
                font [Font] - Model font definition
                font_family [Text] - Font family name
                font_weight [Integer] - Font weight: 
        0) Unset
        1) Thin
        2) Ultralight
        3) Light
        4) Regular
        5) Medium
        6) Semibold
        7) Bold
        8) Ultrabold
        9) Heavy
                font_style [Integer] - Font style: 
        0) Unset
        1) Upright (Default style)
        2) Italic
        3) Oblique
    
    ModelHatch(*args, **kwargs)
        Model Hatch
        Input:
                hatch (in, optional) [Hatch] - The Rhino hatch
                boundary (in, optional) [Surface] - The planar surface or curve which defines the boundaries of the hatch
                plane (in, optional) [Plane] - The hatch pattern base plane
                hatch_pattern (in, optional) [Model Hatch Pattern] - Hatch pattern style
                base_point (in, optional) [Point] - The hatch pattern base point
                rotation (in, optional) [Number] - Pattern rotation
                scale (in, optional) [Number] - Pattern scale
                show_boundary (in, optional) [Boolean] - Show Boundary
                background (in, optional) [Colour] - Background colour
                fill_style (in, optional) [Colour Gradient] - Fill style
        Returns:
                hatch [Hatch] - The Rhino hatch
                boundary [Curve] - The planar curves which define the boundaries of the hatch
                plane [Plane] - The hatch pattern base plane
                hatch_pattern [Model Hatch Pattern] - Hatch pattern style
                base_point [Point] - The hatch pattern base point
                rotation [Number] - Pattern rotation
                scale [Number] - Pattern scale
                show_boundary [Boolean] - Show Boundary
                background [Colour] - Background colour
                fill_style [Colour Gradient] - Fill style
    
    ModelHatchLine(*args, **kwargs)
        Hatch Line
        Input:
                hatch_line (in, optional) [Hatch Line] - The hatch pattern line.
                start (in, optional) [Point] - The start point of the hatch line.
                direction (in, optional) [Vector] - The tangent direction of the hatch line.
                shift (in, optional) [Number] - Sets this lines 2D shift for segment repetitions. Shift of pattern over from line to line.
                offset (in, optional) [Number] - Sets this lines 2D offset for line repetitions. Distance between each time the line you are defining repeats.
                segments (in, optional) [Number] - A list of segment lengths. Positive values are interpretted as a line. Negative values are interpretted as a gap.
        Returns:
                hatch_line [Hatch Line] - The hatch pattern line.
                start [Point] - The start point of the hatch line.
                direction [Vector] - The tangent direction of the hatch line.
                shift [Number] - Sets this lines 2D shift for segment repetitions. Shift of pattern over from line to line.
                offset [Number] - Sets this lines 2D offset for line repetitions. Distance between each time the line you are defining repeats.
                segments [Number] - A list of segment lengths. Positive values are interpretted as a line. Negative values are interpretted as a gap.
    
    ModelHatchPattern(*args, **kwargs)
        Model Hatch Pattern
        Input:
                hatch_pattern (in, optional) [Model Hatch Pattern] - The Rhino model hatch pattern.
                name (in, optional) [Text] - The name of the hatch pattern
                hatch_lines (in, optional) [Hatch Line] - A list of hatch lines which define the pattern.
        Returns:
                hatch_pattern [Model Hatch Pattern] - The Rhino model hatch pattern.
                name [Text] - The name of the hatch pattern
                hatch_lines [Hatch Line] - A list of hatch lines which define the pattern.
    
    ModelLayer(*args, **kwargs)
        Model Layer
        Input:
                layer (in, optional) [Model Layer] - Model Layer definition
                name (in, optional) [Text] - Layer name
                hidden (in, optional) [Boolean] - Hidden
                locked (in, optional) [Boolean] - Locked
                display_colour (in, optional) [Colour] - Display Colour
                material (in, optional) [Model Material] - Layer Material
                linetype (in, optional) [Model Linetype] - Linetype
        Returns:
                layer [Model Layer] - Model Layer definition
                name [Text] - Layer name
                hidden [Boolean] - Hidden
                locked [Boolean] - Locked
                display_colour [Colour] - Display Colour
                material [Model Material] - Layer Material
                linetype [Model Linetype] - Linetype
    
    ModelLinetype(*args, **kwargs)
        Model Linetype
        Input:
                linetype (in, optional) [Model Linetype] - The Rhino model linetype
                name (in, optional) [Text] - The name of the linetype
                segments (in, optional) [Number] - A list of segment lengths in millimeters. Positive values are interpretted as a line. Negative values are interpretted as a gap. If left empty or undefined, the linetype will be continuous.
                cap_style (in, optional) [Integer] - Cap Style: 
        0) Round
        1) Flat
        2) Square
                join_style (in, optional) [Integer] - Join Style: 
        0) Round
        1) Miter
        2) Bevel
                width (in, optional) [Number] - The linetype width when no taper points are defined
                width_units (in, optional) [Unit System] - The line width values will use these units to determine the size of the line on the screen.
        Returns:
                linetype [Model Linetype] - The Rhino model linetype
                name [Text] - The name of the linetype
                segments [Number] - A list of segment lengths in millimeters. Positive values are interpretted as a line. Negative values are interpretted as a gap. If the parameter is empty or undefined, the line will be continuous.
                cap_style [Integer] - Cap Style: 
        0) Round
        1) Flat
        2) Square
                join_style [Integer] - Join Style: 
        0) Round
        1) Miter
        2) Bevel
                width [Number] - The linetype width when no taper points are defined
                width_units [Unit System] - The line width values will use these units to determine the size of the line on the screen.
                scaling_style [Integer] - Display Scaling Style: 
        0) Drafting (Segments are scaled acording to the viewport scale)
        1) Model (No scaling is applied to the segments)
    
    ModelMaterial(*args, **kwargs)
        Model Material
        Input:
                material (in, optional) [Model Material] - The Rhino model material
                name (in, optional) [Text] - The name of the material
                shader (in, optional) [Shader] - The display material (ie. shader)
        Returns:
                material [Model Material] - The Rhino model material.
                name [Text] - The name of the material
                shader [Shader] - The display material (ie. shader)
    
    ModelObject(*args, **kwargs)
        Model Object
        Input:
                object (in, optional) [Model Object] - Model Object
                geometry (in, optional) [Geometry] - Geometry
                name (in, optional) [Text] - Name
                layer (in, optional) [Model Layer] - Layer
                visibility (in, optional) [Visibility Attributes] - Visibility
                display (in, optional) [Display Attributes] - Display Attributes
                drafting (in, optional) [Drafting Attributes] - Drafting Attributes
                render (in, optional) [Render Attributes] - Render Attributes
        Returns:
                object [Model Object] - Model Object
                geometry [Geometry] - Geometry
                name [Text] - Name
                layer [Model Layer] - Layer
                visibility [Visibility Attributes] - Visibility
                display [Display Attributes] - Display Attributes
                drafting [Drafting Attributes] - Drafting Attributes
                render [Render Attributes] - Render Attributes
    
    ModelView(*args, **kwargs)
        Model View
        Input:
                view (in, optional) [View] - The model view
                title (in, optional) [Text] - The title of the named view
                perspective (in, optional) [Boolean] - Determines whether the viewing projection is perspective (true) or parallel (false).
                location (in, optional) [Plane] - The camera location
                target (in, optional) [Number] - The target distance from the camera location
                x_extents (in, optional) [Domain] - Viewport frame width
                y_extents (in, optional) [Domain] - Viewport frame height
        Returns:
                view [View] - The model view
                title [Text] - The title of the named view
                perspective [Boolean] - Determines whether the viewing projection is perspective (true) or parallel (false).
                location [Plane] - The camera location
                target [Number] - The target distance from the camera location
                x_extents [Domain] - Viewport frame width
                y_extents [Domain] - Viewport frame height
    
    ModelViewport(*args, **kwargs)
        Model Viewport
        Input:
                viewport (in, optional) [Model Viewport] - The Rhino viewport
                name (in, optional) [Text] - The name of the viewport
                view (in, optional) [View] - The view orientation
                display_mode (in, optional) [Display Mode] - The viewport's display mode
        Returns:
                viewport [Model Viewport] - The Rhino viewport
                name [Text] - The name of the viewport
                view [View] - The view orientation
                display_mode [Display Mode] - The view's display mode
    
    ModifiedArc(*args, **kwargs)
        Create an arc based on another arc.
        Input:
                arc [Arc] - Base arc
                radius (in, optional) [Number] - Optional new radius
                angle (in, optional) [Domain] - Optional new angle domain
        Returns: [Arc] - Modified arc
    
    Modulus(*args, **kwargs)
        Divides two numbers and returns only the remainder.
        Input:
                a [Generic Data] - First number for modulo (dividend)
                b [Generic Data] - Second number for modulo (divisor)
        Returns: [Generic Data] - The remainder of A/B
    
    MorphToMesh(*args, **kwargs)
        Morph geometry from reference polygons to offset cells of a tri,quad or ngon mesh
        Input:
                geometry (in, optional) [Generic Data] - Geometry to transform
                mesh (in, optional) [Mesh] - Tri,Quad, or Ngon mesh to morph to
                offsets [Number] - Distance or distances per vertex
        Returns:
                geometry [Geometry] - Transformed Geometry
                reference_polygons [Curve] - Geometry placed inside these polygons will be mapped to faces of the mesh with the same number of sides
    
    Move(*args, **kwargs)
        Translate (move) an object along a vector.
        Input:
                geometry (in, optional) [Geometry] - Base geometry
                motion [Vector] - Translation vector
        Returns:
                geometry [Geometry] - Translated geometry
                transform [Transform] - Transformation data
    
    MoveAwayFrom(*args, **kwargs)
        Translate (move) an object away from another object.
        Input:
                geometry [Geometry] - Geometry to move
                emitter [Geometry] - Geometry to move away from
                distance [Number] - Distance to move (negative values move towards)
        Returns:
                geometry [Geometry] - Translated geometry
                transform [Transform] - Transformation data
    
    MoveToPlane(*args, **kwargs)
        Translate (move) an object onto a plane.
        Input:
                geometry [Geometry] - Base geometry
                plane [Plane] - Target plane
                above [Boolean] - Move when above plane
                below [Boolean] - Move when below plane
        Returns:
                geometry [Geometry] - Translated geometry
                transform [Transform] - Transformation data
    
    MultiPipe(*args, **kwargs)
        Create a branching pipe around a network of lines/curves
        Input:
                curves [Generic Data] - The curves to pipe. Also accepts meshes
                nodesize [Number] - Pipe radius. If one value given, it is applied to all. Alternatively, provide a list of radii corresponding to each point in SizePoints
                sizepoints (in, optional) [Point] - If you are supplying multiple radii for NodeSize, these points identify which node to set as which radius. If only some of the nodes have their radius set this way, the values will be interpolated across the shape
                endoffset [Number] - The distance of the first edge loop away from the node as a multiplier of NodeSize. If this is set to zero, no intermediate edge loop is added, to give a smoother shape.
                strutsize [Number] - The size of the struts between nodes as a multiplier of NodeSize. <1 gives tapering struts, >1 gives bulging struts
                segment [Number] - Approximate spacing of edge loops along each strut. If set to zero, no additional edge loops are added
                kinkangle [Number] - When the input to 'Curves' are smooth curves, this sets the maximum angle between consecutive segments when discretizing
                cubefit [Number] - If >0 this attempts to fit a cube at each node. Should be a value between 0 and 1, where 0 = never, and 1 = always, depending on how close to orthogonal its connected lines are.
                caps (in, optional) [Integer] - Cap option - 0:None, 1:Round, 2:Flat
        Returns: [SubD] - Resulting Pipe SubD
    
    MultipleCurves(*args, **kwargs)
        Solve intersection events for multiple curves.
        Input:
                curves [Curve] - Curves to intersect
        Returns:
                points [Point] - Intersection events
                index_a [Integer] - Index of first intersection curve
                index_b [Integer] - Index of second intersection curve
                param_a [Number] - Parameter on first curve
                param_b [Number] - Parameter on second curve
    
    Multiplication(*args, **kwargs)
        Mathematical multiplication
        Input:
                a (in, optional) [Generic Data] - First item for multiplication
                b (in, optional) [Generic Data] - Second item for multiplication
        Returns: [Generic Data] - Result of multiplication
    
    NakedVertices(*args, **kwargs)
        Sorts the vertices of a mesh into 2 lists according to whether or not they are surrounded by faces
        Input:
                mesh [Mesh] - Mesh
        Returns:
                clothedindex [Integer] - Indexes of vertices surrounded by faces
                nakedindex [Integer] - Indexes of vertices not surrounded by faces
                clothedpts [Point] - Point locations of vertices surrounded by faces
                nakedpts [Point] - Point locations of vertices not surrounded by faces
    
    NamedGroup(*args, **kwargs)
        Group a geometry set under a name
        Input:
                group (in, optional) [Group] - Geometry group
                geometry (in, optional) [Geometry] - Geometry to group
                name (in, optional) [Text] - Group name
        Returns:
                group [Group] - Geometry group
                geometry [Geometry] - Group geometry
                name [Text] - Group name
    
    Naturallogarithm(*args, **kwargs)
        Returns a factor of the natural number (e).
        Input:
                factor [Number] - Factor to be multiplied by e
        Returns: [Number] - Output value
    
    Negative(*args, **kwargs)
        Compute the negative of a value.
        Input:
                value [Generic Data] - Input value
        Returns: [Generic Data] - Output value
    
    NetworkSurface(*args, **kwargs)
        Create a surface from curve networks
        Input:
                curves_u [Curve] - Curves in U direction
                curves_v [Curve] - Curves in V direction
                continuity [Integer] - Surface continuity (0=loose, 1=position, 2=tangency, 3=curvature)
        Returns: [Surface] - Network surface
    
    NoFoldThrough(*args, **kwargs)
        To stop the sides of a hinge passing through each other
        Input:
                foldstart (in, optional) [Point] - FoldStart
                foldend (in, optional) [Point] - FoldEnd
                tip1 (in, optional) [Point] - Tip1
                tip2 (in, optional) [Point] - Tip2
                strength [Number] - Strength
        Returns: [Generic Data] - HingeLimit out
    
    NullItem(*args, **kwargs)
        Test a data item for null or invalidity
        Input:
                item (in, optional) [Generic Data] - Item to test
        Returns:
                null_flags [Boolean] - True if item is Null.
                invalid_flags [Boolean] - True if item is Invalid or Null.
                description [Text] - A textual description of the object state.
    
    NumberstoPoints(*args, **kwargs)
        Convert a list of numbers to a list of points
        Input:
                numbers [Number] - Numbers to merge into points
                mask [Coordinate Mask] - Mask for coordinate composition
        Returns: [Point] - Ordered list of points
    
    NurbsCurve(*args, **kwargs)
        Construct a nurbs curve from control points.
        Input:
                vertices [Point] - Curve control points
                degree [Integer] - Curve degree
                periodic [Boolean] - Periodic curve
        Returns:
                curve [Curve] - Resulting nurbs curve
                length [Number] - Curve length
                domain [Domain] - Curve domain
    
    NurbsCurvePWK(*args, **kwargs)
        Construct a nurbs curve from control points, weights and knots.
        Input:
                points [Point] - Curve control points
                weights (in, optional) [Number] - Optional control point weights
                knots [Number] - Nurbs knot vector
        Returns:
                curve [Curve] - Resulting nurbs curve
                length [Number] - Curve length
                domain [Domain] - Curve domain
    
    ObjectLinetype(*args, **kwargs)
        Object linetype attributes
        Input:
                linetype (in, optional) [Linetype] - Object Linetype
                source (in, optional) [Integer] - Linetype Source:
        0) By Layer
        1) By Object
        3) By Parent
                model_linetype (in, optional) [Model Linetype] - The Rhino model linetype
        Returns:
                linetype [Linetype] - Object Linetype
                source [Integer] - Linetype Source:
        0) By Layer
        1) By Object
        3) By Parent
                model_linetype [Model Linetype] - The Rhino model linetype
    
    OcTree(*args, **kwargs)
        A three-dimensional oc-tree structure
        Input:
                points [Point] - Input points
                square [Boolean] - Square leafs
                group [Integer] - Permitted content per leaf
        Returns:
                boxes [Box] - Oc-tree leave boxes
                points [Point] - Points per box
    
    Occlusion(*args, **kwargs)
        Solve occlusion for a collection of view rays and obstructions.
        Input:
                samples [Point] - Sample points for occlusion testing
                obstructions [Mesh] - Obstructing geometry
                rays [Vector] - View rays
        Returns:
                hits [Integer] - Number of occluded rays per sample.
                occlusion [Boolean] - Occlusion topology for every individual sample.
    
    OffsetCurve(*args, **kwargs)
        Offset a curve with a specified distance.
        Input:
                curve [Curve] - Curve to offset
                distance [Number] - Offset distance
                plane (in, optional) [Plane] - Plane for offset operation
                corners [Integer] - Corner type flag. Possible values:
        
        none = 0
        sharp = 1
        round = 2
        smooth = 3
        chamfer = 4
        Returns: [Curve] - Resulting offsets
    
    OffsetCurveLoose(*args, **kwargs)
        Offset the control-points of a curve with a specified distance.
        Input:
                curve [Curve] - Curve to offset
                distance [Number] - Offset distance
                plane (in, optional) [Plane] - Optional Plane for offset operation
        Returns: [Curve] - Resulting offset
    
    OffsetSurface(*args, **kwargs)
        Offset a surface by a fixed amount.
        Input:
                surface [Surface] - Base surface
                distance [Number] - Offset distance
                retrim [Boolean] - Retrim offset
        Returns: [Surface] - Offset result
    
    OffsetSurfaceLoose(*args, **kwargs)
        Offset a surface by moving the control points.
        Input:
                surface [Surface] - Base surface
                distance [Number] - Offset distance
                retrim [Boolean] - Retrim offset
        Returns: [Surface] - Offset result
    
    OffsetonSrf(*args, **kwargs)
        Offset a curve on a surface with a specified distance.
        Input:
                curve [Curve] - Curve to offset
                distance [Number] - Offset distance
                surface [Surface] - Surface for offset operation
        Returns: [Curve] - Resulting offsets
    
    OnCurve(*args, **kwargs)
        Keep a point on a given Curve
        Input:
                points (in, optional) [Point] - Points to keep on a Curve
                curve (in, optional) [Curve] - Curve
                strength [Number] - Strength
        Returns: [Generic Data] - P
    
    OnMesh(*args, **kwargs)
        Keep a point on a given Mesh
        Input:
                points (in, optional) [Point] - Points to keep on a Mesh
                mesh (in, optional) [Mesh] - Mesh
                strength [Number] - Strength
        Returns: [Generic Data] - P
    
    OnPlane(*args, **kwargs)
        Keep a point on a given plane
        Input:
                points (in, optional) [Point] - Points to keep on a plane
                plane (in, optional) [Plane] - Plane (default is WorldXY)
                strength [Number] - Strength
        Returns: [Generic Data] - P
    
    OneOverX(*args, **kwargs)
        Compute one over x.
        Input:
                value [Generic Data] - Input value
        Returns: [Generic Data] - Output value
    
    OrderContent(*args, **kwargs)
        Order content by key
        Input:
                content [Model Content] - The content to sort
                key [Text] - The key to use as the sorting criteria
        Returns:
                content [Model Content] - Input content sorted by value
                values [Generic Data] - The sorted list of values
    
    OrdinateDimension(*args, **kwargs)
        Ordinate Dimension
        Input:
                ordinate_dimension (in, optional) [Ordinate Dimension] - The Rhino ordinate dimension
                plane (in, optional) [Plane] - The base plane from which the dimension is measured from.
                direction (in, optional) [Integer] - Measurement Direction: 
        1) Base Plane X-axis
        2) Base Plane Y-axis
        
                feature_location (in, optional) [Point] - The location of the dimensioned feature.
                dimension_location (in, optional) [Point] - The location of the endpoint of the ordinate dimension leader
                offset_1 (in, optional) [Number] - Offset distance to the first jog (ie. kink) in the leader
                offset_2 (in, optional) [Number] - Offset distance to the second jog (ie. kink) in the leader
                style (in, optional) [Model Annotation Style] - The annotation style.
        Returns:
                ordinate_dimension [Ordinate Dimension] - The Rhino ordinate dimension
                plane [Plane] - The base plane from which the dimension is measured from.
                direction [Integer] - Measurement Direction: 
        1) Base Plane X-axis
        2) Base Plane Y-axis
        
                feature_location [Point] - The location of the dimensioned feature.
                dimension_location [Point] - The location of the endpoint of the ordinate dimension leader
                offset_1 [Number] - Offset distance to the first jog (ie. kink) in the leader
                offset_2 [Number] - Offset distance to the second jog (ie. kink) in the leader
                style [Model Annotation Style] - The annotation style.
    
    Orient(*args, **kwargs)
        Orient an object. Orientation is sometimes called a 'ChangeBasis tranformation'. It allows for remapping of geometry from one axis-system to another.
        Input:
                geometry (in, optional) [Geometry] - Base geometry
                source [Plane] - Initial plane
                target [Plane] - Final plane
        Returns:
                geometry [Geometry] - Reoriented geometry
                transform [Transform] - Transformation data
    
    OrientDirection(*args, **kwargs)
        Orient an object using directional constraints only.
        Input:
                geometry (in, optional) [Geometry] - Base geometry
                point_a [Point] - Reference point
                direction_a [Vector] - Reference direction
                point_b [Point] - Target point
                direction_b [Vector] - Target direction
        Returns:
                geometry [Geometry] - Reoriented geometry
                transform [Transform] - Transformation data
    
    Orthocentre(*args, **kwargs)
        Generate the triangle orthocentre from altitudes.
        Input:
                point_a [Point] - First triangle corner
                point_b [Point] - Second triangle corner
                point_c [Point] - Third triangle corner
        Returns:
                orthocentre [Point] - Orthocentre point for triangle
                altitude_ab [Line] - Altitude line connecting edge AB with corner C
                altitude_bc [Line] - Altitude line connecting edge BC with corner A
                altitude_ca [Line] - Altitude line connecting edge CA with corner B
    
    OsculatingCircles(*args, **kwargs)
        Calculate the principal osculating circles of a surface at a {uv} coordinate.
        Input:
                surface [Surface] - Base surface
                point [Point] - {uv} coordinate to evaluate
        Returns:
                point [Point] - Surface point at {uv} coordinate
                first_circle [Curve] - First osculating circle
                second_circle [Curve] - Second osculating circle
    
    PartitionList(*args, **kwargs)
        Partition a list into sub-lists
        Input:
                list [Generic Data] - List to partition
                size [Integer] - Size of partitions
        Returns: [Generic Data] - List chunks
    
    Patch(*args, **kwargs)
        Create a patch surface
        Input:
                curves (in, optional) [Curve] - Curves to patch
                points (in, optional) [Point] - Points to patch
                spans [Integer] - Number of spans
                flexibility [Number] - Patch flexibility (low number; less flexibility)
                trim [Boolean] - Attempt to trim the result
        Returns: [Surface] - Patch result
    
    PathCompare(*args, **kwargs)
        Compare a path to a mask pattern
        Input:
                path [Path] - Path to compare
                mask [Text] - Comparison mask
        Returns: [Boolean] - Comparison (True = Match, False = Mismatch)
    
    PatternHatch(*args, **kwargs)
        Create a patterned hatch
        Input:
                boundaries [Curve] - Boundary curves for hatch objects
                pattern [Integer] - Hatch pattern style
                scale [Number] - Pattern scale
                angle [Number] - Pattern angle
    
    PerpFrame(*args, **kwargs)
        Solve the perpendicular (zero-twisting) frame at a specified curve parameter.
        Input:
                curve [Curve] - Curve to evaluate
                parameter [Number] - Parameter on curve domain to evaluate
        Returns: [Plane] - Perpendicular curve frame at {t}
    
    PerpFrames(*args, **kwargs)
        Generate a number of equally spaced, perpendicular frames along a curve.
        Input:
                curve [Curve] - Curve to divide
                count [Integer] - Number of segments
                align [Boolean] - Align the frames
        Returns:
                frames [Plane] - Curve frames
                parameters [Number] - Parameter values at frame points
    
    PerpendicularDisplay(*args, **kwargs)
        Display the perpendicularity of a field through a section
        Input:
                field [Field] - Field to evaluate
                section [Rectangle] - Rectangle describing section
                samples [Integer] - Section sample count indicator
                positive_colour [Colour] - Colour for positive (straight up) forces
                negative_colour [Colour] - Colour for negative (straight down) forces
        Returns: [Mesh] - Section display mesh
    
    Pi(*args, **kwargs)
        Returns a factor of Pi.
        Input:
                factor [Number] - Factor to be multiplied by Pi
        Returns: [Number] - Output value
    
    PicknChoose(*args, **kwargs)
        Pick and choose from a set of input data.
        Input:
                pattern [Integer] - Pick pattern of input indices
                stream_0 (in, optional) [Generic Data] - Input stream 0
                stream_1 (in, optional) [Generic Data] - Input stream 1
        Returns: [Generic Data] - Picked result
    
    Pipe(*args, **kwargs)
        Create a pipe surface around a rail curve.
        Input:
                curve [Curve] - Base curve
                radius [Number] - Pipe radius
                caps [Integer] - Specifies the type of caps (0=None, 1=Flat, 2=Round)
        Returns: [Brep] - Resulting Pipe
    
    PipeVariable(*args, **kwargs)
        Create a pipe surface with variable radii around a rail curve.
        Input:
                curve [Curve] - Base curve
                parameters [Number] - Curve parameters for radii
                radii [Number] - A list of radii for every defined parameter
                caps [Integer] - Specifies the type of caps (0=None, 1=Flat, 2=Round)
        Returns: [Brep] - Resulting Pipe
    
    Planar(*args, **kwargs)
        Test a curve for planarity.
        Input:
                curve [Curve] - Curve to evaluate
        Returns:
                planar [Boolean] - Planarity of curve
                plane [Plane] - Curve plane
                deviation [Number] - Deviation from curve plane
    
    PlanarityAnalysis(*args, **kwargs)
        Display face planarity as a coloured mesh
        Input:
                mesh [Mesh] - Mesh to analyze
                max [Number] - Value to map to red in display
        Returns:
                m [Mesh] - Mesh coloured by deviation from planarity, with green=planar and red=max
                p [Number] - Planarity deviation per face - as shortest between diagonals divided by average diagonal length.
    
    Planarize(*args, **kwargs)
        Planarize
        Input:
                m [Mesh] - M
                strength [Number] - Strength
        Returns: [Generic Data] - Planarize out
    
    Plane3Pt(*args, **kwargs)
        Create a plane through three points.
        Input:
                point_a [Point] - Origin point
                point_b [Point] - X-direction point
                point_c [Point] - Orientation point
        Returns: [Plane] - Plane definition
    
    PlaneClosestPoint(*args, **kwargs)
        Find the closest point on a plane.
        Input:
                point [Point] - Sample point
                plane [Plane] - Projection plane
        Returns:
                point [Point] - Projected point
                uv_point [Point] - {uv} coordinates of projected point
                distance [Number] - Signed distance between point and plane
    
    PlaneCoordinates(*args, **kwargs)
        Get the coordinates of a point in a plane axis system.
        Input:
                point [Point] - Input point
                system [Plane] - Local coordinate system
        Returns:
                x_coordinate [Number] - Point {x} coordinate
                y_coordinate [Number] - Point {y} coordinate
                z_coordinate [Number] - Point {z} coordinate
    
    PlaneFit(*args, **kwargs)
        Fit a plane through a set of points.
        Input:
                points [Point] - Points to fit
        Returns:
                plane [Plane] - Plane definition
                deviation [Number] - Maximum deviation between points and plane
    
    PlaneNormal(*args, **kwargs)
        Create a plane perpendicular to a vector.
        Input:
                origin [Point] - Origin of plane
                z-axis [Vector] - Z-Axis direction of plane
        Returns: [Plane] - Plane definition
    
    PlaneOffset(*args, **kwargs)
        Offset a plane.
        Input:
                base_plane [Plane] - Base plane for offset
                offset [Number] - Offset distance (along base plane z-axis
        Returns: [Plane] - Offset plane
    
    PlaneOrigin(*args, **kwargs)
        Change the origin point of a plane
        Input:
                base [Plane] - Base plane
                origin [Point] - New origin point of plane
        Returns: [Plane] - Plane definition
    
    PlaneRegion(*args, **kwargs)
        Create a bounded region from intersecting planes.
        Input:
                plane [Plane] - Region plane and origin
                bounds [Plane] - Region bounding planes
        Returns: [Curve] - Bounded region
    
    PlaneSurface(*args, **kwargs)
        Create a plane surface
        Input:
                plane [Plane] - Surface base plane
                x_size [Domain] - Dimensions in X direction
                y_size [Domain] - Dimensions in Y direction
        Returns: [Surface] - Resulting plane surface
    
    PlaneThroughShape(*args, **kwargs)
        Make a rectangular surface that is larger than a given shape.
        Input:
                plane [Plane] - Surface plane
                shape [Geometry] - Shape to exceed
                inflate [Number] - Boundary inflation amount
        Returns: [Surface] - Resulting planar surface
    
    PlaneXPlane(*args, **kwargs)
        Solve the intersection event of two planes.
        Input:
                plane_a [Plane] - First plane
                plane_b [Plane] - Second plane
        Returns: [Line] - Intersection line
    
    PlaneXPlaneXPlane(*args, **kwargs)
        Solve the intersection events of three planes.
        Input:
                plane_a [Plane] - First plane
                plane_b [Plane] - Second plane
                plane_c [Plane] - Third plane
        Returns:
                point [Point] - Intersection point
                line_ab [Line] - Intersection line between A and B
                line_ac [Line] - Intersection line between A and C
                line_bc [Line] - Intersection line between B and C
    
    PlasticAnchor(*args, **kwargs)
        PlasticAnchor
        Input:
                point (in, optional) [Point] - Point to anchor
                limit [Number] - Distance at which target point starts to slide
                strength [Number] - Strength
                reset [Boolean] - Reset plastic positions
        Returns: [Generic Data] - A out
    
    PlasticHinge(*args, **kwargs)
        Like Hinge, except folding beyond the plastic/elastic threshold will alter the rest angle
        Input:
                foldstart (in, optional) [Point] - FoldStart
                foldend (in, optional) [Point] - FoldEnd
                tip1 (in, optional) [Point] - Tip1
                tip2 (in, optional) [Point] - Tip2
                restangle (in, optional) [Number] - Rest angle(in radians) - if none supplied, current angle will be used
                limit [Number] - Maximum elastic deformation angle in radians
                strength [Number] - Strength
        Returns: [Generic Data] - Hinge out
    
    PlasticLength(*args, **kwargs)
        This tries to preserve the length of the line elastically, until it is deformed beyond the limit, then its rest length gets changed
        Input:
                line (in, optional) [Curve] - Line
                limit [Number] - Maximum elastic deformation distance
                strength [Number] - Strength
        Returns: [Generic Data] - Spring out
    
    PointCharge(*args, **kwargs)
        Create a field due to a point charge
        Input:
                point [Point] - Location of point charge
                charge [Number] - Charge of point object
                decay [Number] - Decay of charge potential
                bounds (in, optional) [Box] - Optional bounds for the field
        Returns: [Field] - Field due to point charge
    
    PointCloudAttributes(*args, **kwargs)
        Point Cloud Attributes
        Input:
                cloud (in, optional) [Point Cloud] - Point Cloud
                locations (in, optional) [Point] - The locations of the points in the point cloud
                normals (in, optional) [Vector] - The normal vectors for the point cloud
                colours (in, optional) [Colour] - The colours for the point cloud
                extra (in, optional) [Number] - The extra value can be used to store a user-defined numeric value, such as intensity, with each point in the point cloud
                hidden (in, optional) [Boolean] - The visibility flags for the point cloud.
        Returns:
                cloud [Point Cloud] - Point Cloud
                locations [Point] - The locations of the points in the point cloud
                normals [Vector] - The normal vectors for the point cloud
                colours [Colour] - The colours for the point cloud
                extra [Number] - The extra value can be used to store a user-defined numeric value, such as intensity, with each point in the point cloud
                hidden [Boolean] - The visibility flags for the point cloud.
    
    PointCloudClosestPoint(*args, **kwargs)
        Find the closest point in a point cloud
        Input:
                point [Point] - The point to search from
                cloud [Point Cloud] - Point Cloud to search
        Returns:
                closest_point [Point] - The point in the cloud that is closest to the input point
                index [Integer] - The index of the closest point in the cloud
                distance [Number] - The distance between the closest point in the cloud and the input point
    
    PointCloudContour(*args, **kwargs)
        Create a series of planar curves by intersecting planes with a cloud of points
        Input:
                cloud [Point Cloud] - Point Cloud
                start (in, optional) [Point] - Contour start point
                direction (in, optional) [Vector] - Contour normal direction
                distance (in, optional) [Number] - Distance between contours
                limit (in, optional) [Boolean] - Limit contours to the range specified by the normal vector. If false, contours will be generated for the whole point cloud
        Returns: [Curve] - The section curves
    
    PointCloudSection(*args, **kwargs)
        Create a planar section by intersecting a plane with a cloud of points
        Input:
                cloud [Point Cloud] - Point Cloud
                plane [Plane] - The intersecting plane
        Returns: [Curve] - The section curves
    
    PointCylindrical(*args, **kwargs)
        Create a point from cylindrical {angle,radius,elevation} coordinates.
        Input:
                base_plane [Plane] - Plane defining cylindrical coordinate space
                angle [Number] - Angle in radians for P(x,y) rotation
                radius [Number] - Radius of cylinder
                elevation [Number] - Elevation of point
        Returns: [Point] - Cylindrical point coordinate
    
    PointDeform(*args, **kwargs)
        Deform a shape by moving control-points individually
        Input:
                geometry [Geometry] - Geometry to deform
                points [Point] - Control-point locations to deform.
                motion [Vector] - Motion vector for each control-point
        Returns: [Geometry] - Deformed geometry
    
    PointGroups(*args, **kwargs)
        Create groups from nearby points
        Input:
                points [Point] - Points to group
                distance [Number] - Distance threshold for group inclusion
        Returns:
                groups [Point] - Point groups
                indices [Integer] - Group indices
    
    PointInBrep(*args, **kwargs)
        Test whether a point is inside a closed brep
        Input:
                brep [Brep] - Brep for inclusion test
                point [Point] - Point for inclusion test
                strict [Boolean] - If true, then the inclusion is strict
        Returns: [Boolean] - True if point is on the inside of the Brep.
    
    PointInBreps(*args, **kwargs)
        Test whether a point is inside a collection of closed breps
        Input:
                brep [Brep] - Breps for inclusion test
                point [Point] - Point for inclusion test
                strict [Boolean] - If true, then the inclusion is strict
        Returns:
                inside [Boolean] - True if point is on the inside at least one of the Breps.
                index [Integer] - Index of first brep that contains the point, or -1
    
    PointInCurve(*args, **kwargs)
        Test a point for closed curve containment.
        Input:
                point [Point] - Point for region inclusion test
                curve [Curve] - Boundary region (closed curves only)
        Returns:
                relationship [Integer] - Point/Region relationship (0 = outside, 1 = coincident, 2 = inside)
                point [Point] - Point projected on region plane.
    
    PointInTrim(*args, **kwargs)
        Test whether a {uv} coordinate is inside the trimmed portion of a surface
        Input:
                surface [Surface] - Base surface
                uv_point [Point] - UV point to test for trim inclusion
        Returns: [Boolean] - Inclusion flag. TRUE if point is inside the trim boundaries.
    
    PointLight(*args, **kwargs)
        Point Light
        Input:
                point_light (in, optional) [Light] - The Rhino point light
                location (in, optional) [Point] - Location of the point light
        Returns:
                point_light [Light] - The Rhino point light
                location [Point] - Location of the point light
    
    PointList(*args, **kwargs)
        Displays details about lists of points
        Input:
                points (in, optional) [Point] - Points to display
                size (in, optional) [Number] - Optional text size (in Rhino units)
    
    PointOrder(*args, **kwargs)
        Displays the order of a list of points
        Input:
                points (in, optional) [Point] - Points to display
    
    PointOriented(*args, **kwargs)
        Create a point from plane {u,v,w} coordinates.
        Input:
                base_plane [Plane] - Plane defining coordinate space
                u_component [Number] - U parameter on plane
                v_component [Number] - V parameter on plane
                w_component [Number] - W parameter on plane (elevation)
        Returns: [Point] - Oriented point coordinate
    
    PointPolar(*args, **kwargs)
        Create a point from polar {phi,theta,offset} coordinates.
        Input:
                base_plane [Plane] - Plane defining polar coordinate space
                xy_angle [Number] - Angle in radians for P(x,y) rotation
                z_angle [Number] - Angle in radians for P(z) rotation
                offset [Number] - Offset distance for point
        Returns: [Point] - Polar point coordinate
    
    PointinCurves(*args, **kwargs)
        Test a point for multiple closed curve containment.
        Input:
                point [Point] - Point for inclusion test
                curves [Curve] - Boundary regions (closed curves only)
        Returns:
                relationship [Integer] - Point/Region relationship (0 = outside, 1 = coincident, 2 = inside)
                index [Integer] - Index of first region that contains the point
                point [Point] - Point projected on region plane.
    
    PointstoNumbers(*args, **kwargs)
        Convert a list of points to a list of numbers
        Input:
                points [Point] - Points to parse
                mask [Coordinate Mask] - Mask for coordinate extraction
        Returns: [Number] - Ordered list of coordinates
    
    PolarArray(*args, **kwargs)
        Create a polar array of geometry.
        Input:
                geometry (in, optional) [Geometry] - Base geometry
                plane [Plane] - Polar array plane
                count [Integer] - Number of elements in array.
                angle [Number] - Sweep angle in radians (counter-clockwise, starting from plane x-axis)
        Returns:
                geometry [Geometry] - Arrayed geometry
                transform [Transform] - Transformation data
    
    PolyArc(*args, **kwargs)
        Create a polycurve consisting of arc and line segments.
        Input:
                vertices [Point] - Polyarc vertex coordinates
                tangent (in, optional) [Vector] - Optional tangent vector at start.
                closed [Boolean] - Close the polyarc curve.
        Returns: [Curve] - Resulting polyarc curve
    
    PolyLine(*args, **kwargs)
        Create a polyline connecting a number of points.
        Input:
                vertices [Point] - Polyline vertex points
                closed [Boolean] - Close polyline
        Returns: [Curve] - Resulting polyline
    
    Polygon(*args, **kwargs)
        Create a polygon with optional round edges.
        Input:
                plane [Plane] - Polygon base plane
                radius [Number] - Radius of polygon (distance from center to tip).
                segments [Integer] - Number of segments
                fillet_radius [Number] - Polygon corner fillet radius
        Returns:
                polygon [Curve] - Polygon
                length [Number] - Length of polygon curve
    
    PolygonArea(*args, **kwargs)
        PolygonArea
        Input:
                polyline (in, optional) [Curve] - Polyline
                area (in, optional) [Number] - Area
                strength [Number] - Strength
        Returns: [Generic Data] - A
    
    PolygonCenter(*args, **kwargs)
        Find the center point (average) for a polyline.
        Input:
                polyline [Curve] - Polyline to average.
        Returns:
                center(v) [Point] - Average of polyline vertices.
                center(e) [Point] - Average of polyline edges
                center(a) [Point] - Area centroid of polyline shape
    
    PolygonEdge(*args, **kwargs)
        Create a polygon from a single edge.
        Input:
                edge_start [Point] - Start point of polygon edge.
                edge_end [Point] - End point of polygon edge.
                plane_point [Point] - Point on polygon plane.
                segments [Integer] - Number of segments
        Returns:
                polygon [Curve] - Polygon
                centre [Point] - Centre of polygon
                corner_radius [Number] - Distance from centre to polygon corner.
                edge_radius [Number] - Distance from centre to edge mid-points.
    
    PolylineCollapse(*args, **kwargs)
        Collapse short segments in a polyline curve.
        Input:
                polyline [Curve] - Polyline curve
                tolerance [Number] - Segment length tolerance
        Returns:
                polyline [Curve] - Resulting polyline
                count [Integer] - Number of segments that were collapsed
    
    Populate2D(*args, **kwargs)
        Populate a 2-Dimensional region with points
        Input:
                region [Rectangle] - Rectangle that defines the 2D region for point insertion
                count [Integer] - Number of points to add
                seed [Integer] - Random seed for insertion
                points (in, optional) [Point] - Optional pre-existing population
        Returns: [Point] - Population of inserted points
    
    Populate3D(*args, **kwargs)
        Populate a 3-Dimensional region with points
        Input:
                region [Box] - Box that defines the 3D region for point insertion
                count [Integer] - Number of points to add
                seed [Integer] - Random seed for insertion
                points (in, optional) [Point] - Optional pre-existing population
        Returns: [Point] - Population of inserted points
    
    PopulateGeometry(*args, **kwargs)
        Populate generic geometry with points
        Input:
                geometry [Geometry] - Geometry to populate (curves, surfaces, breps and meshes only)
                count [Integer] - Number of points to add
                seed [Integer] - Random seed for insertion
                points (in, optional) [Point] - Optional pre-existing population
        Returns: [Point] - Population of inserted points
    
    Power(*args, **kwargs)
        Raise a value to a power.
        Input:
                a [Generic Data] - The item to be raised
                b [Generic Data] - The exponent
        Returns: [Generic Data] - A raised to the B power
    
    Powerof10(*args, **kwargs)
        Raise 10 to the power of N.
        Input:
                value [Generic Data] - Input value
        Returns: [Generic Data] - Output value
    
    Powerof2(*args, **kwargs)
        Raise 2 to the power of N.
        Input:
                value [Generic Data] - Input value
        Returns: [Generic Data] - Output value
    
    PowerofE(*args, **kwargs)
        Raise E to the power of N.
        Input:
                value [Generic Data] - Input value
        Returns: [Generic Data] - Output value
    
    Pressure(*args, **kwargs)
        A force normal to each triangle, and proportional to its area
        Input:
                m [Mesh] - M
                strength [Number] - Strength
        Returns: [Generic Data] - out
    
    PrincipalCurvature(*args, **kwargs)
        Evaluate the principal curvature of a surface at a {uv} coordinate.
        Input:
                surface [Surface] - Base surface
                point [Point] - {uv} coordinate to evaluate
        Returns:
                frame [Plane] - Surface frame at (uv) coordinate
                maximum [Number] - Maximum (absolute) principal curvature
                minimum [Number] - Minimum (absolute) principal curvature
                max_direction [Vector] - Principal curvature direction corresponding to C¹.
                min_direction [Vector] - Principal curvature direction corresponding to C².
    
    PrintColour(*args, **kwargs)
        Object print colour attributes
        Input:
                print_colour (in, optional) [Print Colour] - Object Print Colour
                source (in, optional) [Integer] - Colour Source:
        0) By Layer
        1) By Object
        2) By Display
        3) By Parent
                colour (in, optional) [Colour] - Colour
        Returns:
                print_colour [Print Colour] - Object Print Colour
                source [Integer] - Colour Source:
        0) By Layer
        1) By Object
        2) By Display
        3) By Parent
                colour [Colour] - Colour
    
    PrintWidth(*args, **kwargs)
        Object print width attributes
        Input:
                print_width (in, optional) [Print Width] - Object Print Width
                source (in, optional) [Integer] - Print Width Source:
        0) By Layer
        1) By Object
        3) By Parent
                width (in, optional) [Print Width] - Print Width
        Returns:
                print_width [Print Width] - Object Print Width
                source [Integer] - Print Width Source:
        0) By Layer
        1) By Object
        3) By Parent
                width [Print Width] - Print Width
    
    Project(*args, **kwargs)
        Project an object onto a plane.
        Input:
                geometry (in, optional) [Generic Data] - Geometry to project
                plane [Plane] - Projection plane
        Returns:
                geometry [Generic Data] - Projected geometry
                transform [Transform] - Transformation data
    
    ProjectAlong(*args, **kwargs)
        Project an object onto a plane along a direction.
        Input:
                geometry (in, optional) [Generic Data] - Geometry to project
                plane [Plane] - Projection plane
                direction [Vector] - Projection direction
        Returns:
                geometry [Generic Data] - Projected geometry
                transform [Transform] - Transformation data
    
    ProjectCurve(*args, **kwargs)
        Project a curve onto a Brep.
        Input:
                curve [Curve] - Curve to project
                brep [Brep] - Brep to project onto
                direction [Vector] - Projection direction
        Returns: [Curve] - Projected curves
    
    ProjectPoint(*args, **kwargs)
        Project a point onto a collection of shapes
        Input:
                point [Point] - Point to project
                direction [Vector] - Projection direction
                geometry [Geometry] - Geometry to project onto
        Returns:
                point [Point] - Projected point
                index [Integer] - Index of object that was projected onto
    
    Proximity2D(*args, **kwargs)
        Search for two-dimensional proximity within a point list
        Input:
                points [Point] - Input points
                plane [Plane] - Optional base plane. If null, the best fit plane is used
                group [Integer] - Maximum number of closest points to find
                min_radius (in, optional) [Number] - Optional minimum search radius.
                max_radius (in, optional) [Number] - Optional maximum search radius.
        Returns:
                links [Line] - Proximity links
                topology [Integer] - Proximity topology
    
    Proximity3D(*args, **kwargs)
        Search for three-dimensional proximity within a point list
        Input:
                points [Point] - Input points
                group [Integer] - Maximum number of closest points to find
                min_radius (in, optional) [Number] - Optional minimum search radius.
                max_radius (in, optional) [Number] - Optional maximum search radius.
        Returns:
                links [Line] - Proximity links
                topology [Integer] - Proximity topology
    
    PruneTree(*args, **kwargs)
        Remove small branches from a Data Tree.
        Input:
                tree [Generic Data] - Data tree to prune
                minimum [Integer] - Remove branches with fewer than N0 items.
                maximum [Integer] - Remove branches with more than N1 items (use zero to ignore upper limit).
        Returns: [Generic Data] - Pruned tree
    
    PullCurve(*args, **kwargs)
        Pull a curve onto a surface.
        Input:
                curve [Curve] - Curve to pull
                surface [Surface] - Surface that pulls
        Returns: [Curve] - Curve pulled onto the surface
    
    PullPoint(*args, **kwargs)
        Pull a point to a variety of geometry.
        Input:
                point [Point] - Point to search from
                geometry [Geometry] - Geometry that pulls
        Returns:
                closest_point [Point] - Point on [G] closest to [P]
                distance [Number] - Distance between [P] and its projection onto [G]
                index [Integer] - Index on [G]
    
    Python3Script(*args, **kwargs)
        Python 3 scripting component
        Input:
                x (in, optional) [Generic Data] - No conversion
                y (in, optional) [Generic Data] - No conversion
        Returns:
                out [Text] - Standard output and error contents collected during script run
                a [Generic Data] - No conversion
    
    QuadRemesh(*args, **kwargs)
        Perform quad-remeshing on a shape.
        Input:
                geometry [Geometry] - Geometry to operate on
                guides (in, optional) [Curve] - Guide curves
                settings [Quad meshing settings] - Remeshing settings
        Returns: [Mesh] - Resulting mesh with quad faces only.
    
    QuadRemeshSettings(*args, **kwargs)
        Create setting for Quad-remeshing.
        Input:
                target_count [Integer] - Number of quads to aim for in the result.
                adaptive_size [Number] - A number in the range [0, 100] controlling how the quad sizes change depending on curvature.
                adaptive_count [Boolean] - True if the number of quads is allowed to be higher for high-curvature areas.
                target_edge_length (in, optional) [Number] - Optional target edge length. When set, the 'Target Count' will be ignored.
                hard_edges [Boolean] - Detect and retain hard edges in the input mesh.
                seam_edges [Integer] - Detect and retain brep-face boundary edges (0=Off, 1=Smart, 2=Strict).
                symmetry [Integer] - Symmetry axis (0=none, 1=X, 2=Y, 3=Z).
                guide_curves [Integer] - Guide curve influence. (0=approximate, 1=edge-ring, 2=edge-loop).
        Returns: [Quad meshing settings] - Quad-remesher settings
    
    QuadSphere(*args, **kwargs)
        Create a spherical brep made from quad nurbs patches.
        Input:
                base [Plane] - Base plane
                radius [Number] - Sphere radius
        Returns: [Brep] - Resulting quad sphere
    
    QuadTree(*args, **kwargs)
        A two-dimensional quadtree structure
        Input:
                points [Point] - Input points
                plane (in, optional) [Plane] - Optional base plane. If omitted, the best fit plane is used
                square [Boolean] - Square leafs
                group [Integer] - Permitted content per leaf
        Returns:
                quads [Curve] - Quad tree leaves
                points [Point] - Points per quad
    
    Quadrangulate(*args, **kwargs)
        Quadrangulate as many triangles as possible in a mesh
        Input:
                mesh [Mesh] - Mesh to quadrangulate
                angle [Number] - Angle threshold. Triangles that exceed this kink-angle will not be merged.
                ratio [Number] - Ratio threshold. Quads that have a ratio (shortest diagonal/longest diagonal) that exceed the threshold, will not be considered.
        Returns:
                mesh [Mesh] - Quadrangulated mesh (not all triangles are guaranteed to be converted).
                count [Integer] - Number of triangles that were quadrangulated
    
    QueryAnnotationStyles(*args, **kwargs)
        Query a Rhino document for all available annotation styles
        Input:
                name (in, optional) [Text Pattern] - Name filter. Right-click on this parameter to set the matching method.
        Returns: [Model Annotation Style] - The resultant list of available annotation styles in the model.
    
    QueryDirectory(*args, **kwargs)
        Query on the file system under the specified directory path.
        Input:
                directory [Text] - A file system directory path.
        Relative paths are solved on the Grasshopper document directory.
                max_depth (in, optional) [Integer] - Maximum query depth inside the input Directory.
                name (in, optional) [Text Pattern] - A name pattern used to filter results.
        Right-click on this parameter to set the matching method.
        Returns:
                directory [Text] - The absolute file system directory path
                directories [Text] - The resultant list of available subdirectories
                files [Text] - The resultant list of available files
    
    QueryInstalledFonts(*args, **kwargs)
        Query for all available fonts
        Input:
                font_family (in, optional) [Text Pattern] - An optional font family name to filter. A wildcard (*) input will return all available fonts.
                font_weight (in, optional) [Integer] - An optional font weight value to filter.
                font_style (in, optional) [Integer] - An optional font style value to filter.
                font_stretch (in, optional) [Integer] - An optional font stretch value to filter.
                symbol (in, optional) [Boolean] - Symbol
                single_stroke (in, optional) [Boolean] - Single Stroke
                engraving (in, optional) [Boolean] - Engraving
        Returns: [Font] - The resultant list of available fonts
    
    QueryLayouts(*args, **kwargs)
        Query a Rhino document for all available layout viewports
        Input:
                name (in, optional) [Text Pattern] - Name filter. Right-click on this parameter to set the matching method.
        Returns: [Layout Viewport] - The resultant list of available layout viewports
    
    QueryModelBlockDefinitions(*args, **kwargs)
        Query a Rhino document for all available block definitions
        Input:
                name (in, optional) [Text Pattern] - Name filter. Right-click on this parameter to set the matching method.
        Returns: [Model Block Definition] - The resultant list of available block definitions in the model.
    
    QueryModelEnvironments(*args, **kwargs)
        Query a Rhino document for all available render environments
        Input:
                name (in, optional) [Text Pattern] - Name filter. Right-click on this parameter to set the matching method.
        Returns: [Model Environment] - The resultant list of available environments in the model.
    
    QueryModelHatchPatterns(*args, **kwargs)
        Query a Rhino document for all available hatch patterns
        Input:
                name (in, optional) [Text Pattern] - Name filter. Right-click on this parameter to set the matching method.
        Returns: [Model Hatch Pattern] - The resultant list of available hatch patterns in the model.
    
    QueryModelLayers(*args, **kwargs)
        Query a Rhino document for all available layers
        Input:
                name (in, optional) [Text Pattern] - Name filter. Right-click on this parameter to set the matching method.
        Returns: [Model Layer] - The resultant list of available layers in the model.
    
    QueryModelLights(*args, **kwargs)
        Query a Rhino document for all available lights
        Input:
                name (in, optional) [Text Pattern] - Name filter. Right-click on this parameter to set the matching method.
                layer (in, optional) [Text Pattern] - An optional layer name filter. Right-click on this parameter to set the matching method.
        Returns: [Model Object] - The resultant list of available lights in the model.
    
    QueryModelLinetypes(*args, **kwargs)
        Query a Rhino document for all available linetypes
        Input:
                name (in, optional) [Text Pattern] - Name filter. Right-click on this parameter to set the matching method.
        Returns: [Model Linetype] - The resultant list of available linetypes in the model.
    
    QueryModelLocation(*args, **kwargs)
        Query a Rhino document for its location on earth
        Input:
        Returns: [Earth Location] - The model location on earth
    
    QueryModelMaterials(*args, **kwargs)
        Query a Rhino document for all available render materials
        Input:
                name (in, optional) [Text Pattern] - Name filter. Right-click on this parameter to set the matching method.
        Returns: [Model Material] - The resultant list of available materials in the model.
    
    QueryModelObjects(*args, **kwargs)
        Query a Rhino document for all available model objects
        Input:
                name (in, optional) [Text Pattern] - An optional object name filter.
        Right-click on this parameter to set the matching method.
                layer (in, optional) [Text Pattern] - An optional layer name filter.
        Right-click on this parameter to set the matching method.
                group (in, optional) [Text Pattern] - An optional group name filter.
        Right-click on this parameter to set the matching method.
                locked [Boolean] - Include locked objects.
                hidden [Boolean] - Include hidden objects.
        Returns: [Model Object] - The resultant list of available Rhino objects.
    
    QueryNamedViews(*args, **kwargs)
        Query a Rhino document for all available named views
        Input:
                name (in, optional) [Text Pattern] - Name filter. Right-click on this parameter to set the matching method.
        Returns: [Model Content] - The resultant list of available model named views
    
    QueryRenderOptions(*args, **kwargs)
        Query a Rhino document for its render options
        Input:
        Returns:
                sun [Model Content] - The Rhino sun light
                skylight [Model Content] - The Rhino skylight
    
    QueryViewports(*args, **kwargs)
        Query a Rhino document for all available viewports
        Input:
                name (in, optional) [Text Pattern] - Name filter. Right-click on this parameter to set the matching method.
        Returns: [Model Viewport] - The resultant list of available model viewports
    
    Radial(*args, **kwargs)
        2D radial grid
        Input:
                plane [Plane] - Base plane for grid
                size [Number] - Distance between concentric grid loops
                extent_r [Integer] - Number of grid cells in radial direction
                extent_p [Integer] - Number of grid cells in polar direction
        Returns:
                cells [Curve] - Grid cell outlines
                points [Point] - Points at grid nodes
    
    RadialDimension(*args, **kwargs)
        Radial Dimension
        Input:
                radial_dimension (in, optional) [Radial Dimension] - The Rhino radial dimension
                plane (in, optional) [Plane] - Plane that this annotation lies on.
                curve (in, optional) [Curve] - The planar curve to assign the radius dimension.
                curve_point (in, optional) [Point] - The point on the curve to measure the radius or diameter from.
        If the point does not fall on the curve, the closest point on the curve will be used.
                dimension_location (in, optional) [Point] - The location of the end of the dimension leader.
        Radius or diameter will be measured on this plane.
                dimension_type (in, optional) [Integer] - Dimension type: 
        3) Diameter
        4) Radius
                style (in, optional) [Model Annotation Style] - The annotation style.
        Returns:
                radial_dimension [Radial Dimension] - The Rhino radial dimension
                plane [Plane] - Plane that this annotation lies on.
                center_point [Point] - The center point of the radius dimension.
                curve_point [Point] - The point on the curve to measure the radius or diameter from.
                dimension_location [Point] - The location of the end of the dimension leader.
                dimension_type [Integer] - Dimension type: 
        3) Diameter
        4) Radius
                style [Model Annotation Style] - The annotation style.
    
    Radians(*args, **kwargs)
        Convert an angle specified in degrees to radians
        Input:
                degrees [Number] - Angle in degrees
        Returns: [Number] - Angle in radians
    
    RailRevolution(*args, **kwargs)
        Create a surface of revolution using a sweep rail.
        Input:
                curve [Curve] - Profile curve
                rail [Curve] - Rail curve
                axis [Line] - Revolution axis
                scale [Boolean] - Scale height of profile curve
        Returns: [Brep] - Brep representing the Rail-Revolve result.
    
    Random(*args, **kwargs)
        Generate a list of pseudo random numbers.
        Input:
                range [Domain] - Domain of random numeric range
                number [Integer] - Number of random values
                seed [Integer] - Seed of random engine
        Returns: [Generic Data] - Random numbers
    
    RandomReduce(*args, **kwargs)
        Randomly remove N items from a list
        Input:
                list [Generic Data] - List to reduce
                reduction [Integer] - Number of items to remove
                seed [Integer] - Random Generator Seed value
        Returns: [Generic Data] - Reduced list
    
    Range(*args, **kwargs)
        Create a range of numbers.
        Input:
                domain [Domain] - Domain of numeric range
                steps [Integer] - Number of steps
        Returns: [Number] - Range of numbers
    
    ReadFile(*args, **kwargs)
        Read the contents of a file
        Input:
                file [Text] - Uri of file to read
        Returns: [Generic Data] - File content
    
    RebuildCurve(*args, **kwargs)
        Rebuild a curve with a specific number of control-points.
        Input:
                curve [Curve] - Curve to rebuild
                degree (in, optional) [Integer] - Optional degree of curve (if omitted, input degree is used)
                count [Integer] - Number of control points
                tangents [Boolean] - Preserve curve end tangents
        Returns: [Curve] - Rebuild curve
    
    Rectangle(*args, **kwargs)
        Create a rectangle on a plane
        Input:
                plane [Plane] - Rectangle base plane
                x_size [Domain] - Dimensions of rectangle in plane X direction.
                y_size [Domain] - Dimensions of rectangle in plane Y direction.
                radius [Number] - Rectangle corner fillet radius
        Returns:
                rectangle [Generic Data] - Rectangle
                length [Number] - Length of rectangle curve
    
    Rectangle2Pt(*args, **kwargs)
        Create a rectangle from a base plane and two points
        Input:
                plane [Plane] - Rectangle base plane
                point_a [Point] - First corner point.
                point_b [Point] - Second corner point.
                radius [Number] - Rectangle corner fillet radius
        Returns:
                rectangle [Generic Data] - Rectangle defined by P, A and B
                length [Number] - Length of rectangle curve
    
    Rectangle3Pt(*args, **kwargs)
        Create a rectangle from three points
        Input:
                point_a [Point] - First corner of rectangle
                point_b [Point] - Second corner of rectangle
                point_c [Point] - Point along rectangle edge opposite to AB
        Returns:
                rectangle [Rectangle] - Rectangle defined by A, B and C.
                length [Number] - Length of rectangle curve
    
    RectangleMapping(*args, **kwargs)
        Transform geometry from one rectangle into another.
        Input:
                geometry (in, optional) [Geometry] - Base geometry
                source [Rectangle] - Rectangle to map from
                target [Rectangle] - Rectangle to map into
        Returns:
                geometry [Geometry] - Mapped geometry
                transform [Transform] - Transformation data
    
    Rectangular(*args, **kwargs)
        2D grid with rectangular cells
        Input:
                plane [Plane] - Base plane for grid
                size_x [Number] - Size of grid cells in base plane x-direction
                size_y [Number] - Size of grid cells in base plane y-direction
                extent_x [Integer] - Number of grid cells in base plane x direction
                extent_y [Integer] - Number of grid cells in base plane y direction
        Returns:
                cells [Rectangle] - Grid cell outlines
                points [Point] - Points at grid corners
    
    RectangularArray(*args, **kwargs)
        Create a rectangular array of geometry.
        Input:
                geometry (in, optional) [Geometry] - Base geometry
                cell [Rectangle] - Rectangular array cell
                x_count [Integer] - Number of elements in the array x-direction.
                y_count [Integer] - Number of elements in the array y-direction.
        Returns:
                geometry [Geometry] - Arrayed geometry
                transform [Transform] - Transformation data
    
    RectangularLight(*args, **kwargs)
        Rectangular Light
        Input:
                rectangular_light (in, optional) [Light] - The Rhino rectangular light
                plane (in, optional) [Plane] - The plane of the rectangular light
                length (in, optional) [Number] - Length dimension of the rectangular light
                width (in, optional) [Number] - Width dimension of the rectangular light
        Returns:
                rectangular_light [Light] - The Rhino rectangular light
                plane [Plane] - The plane of the rectangular light
                length [Number] - Length dimension of the rectangular light
                width [Number] - Width dimension of the rectangular light
    
    Reduce(*args, **kwargs)
        Reduce a polyline by removing least significant vertices.
        Input:
                polyline [Curve] - Polyline to reduce
                tolerance [Number] - Tolerance (allowed deviation between original and reduction)
        Returns:
                polyline [Curve] - Reduced polyline
                reduction [Integer] - Number of vertices removed during reduction
    
    ReducePointCloud(*args, **kwargs)
        Reduce the number of points in a point cloud
        Input:
                cloud [Point Cloud] - Point Cloud to reduce
                samples [Integer] - The number of points the new point cloud should contain
        Returns: [Point Cloud] - A subsample of the original point cloud
    
    Refine(*args, **kwargs)
        Divide each quad into 4 quads, and each triangle into 4 triangles
        Input:
                mesh [Mesh] - Mesh to refine
                level [Integer] - Level of subdivision
        Returns: [Mesh] - Refined Mesh
    
    RefineStrips(*args, **kwargs)
        Directional subdivision, refines quads in one direction only
        Input:
                mesh [Mesh] - Mesh to refine
                level [Integer] - Level of subdivision
        Returns: [Mesh] - Refined Mesh
    
    RegionDifference(*args, **kwargs)
        Difference between two sets of planar closed curves (regions)
        Input:
                curves_a [Curve] - Curves to subtract from.
                curves_b [Curve] - Curves to subtract.
                plane (in, optional) [Plane] - Optional plane for boolean solution
        Returns: [Curve] - Result outlines of boolean difference (A - B)
    
    RegionIntersection(*args, **kwargs)
        Intersection between two sets of planar closed curves (regions)
        Input:
                curves_a [Curve] - First set of regions.
                curves_b [Curve] - Second set of regions.
                plane (in, optional) [Plane] - Optional plane for boolean solution
        Returns: [Curve] - Result outlines of boolean intersection (A and B)
    
    RegionSlits(*args, **kwargs)
        Add slits to a collection of intersecting planar regions
        Input:
                regions [Curve] - Planar regions to intersect
                width [Number] - Width of slits
                gap [Number] - Additional gap size at slit meeting points
        Returns:
                regions [Surface] - Regions with slits
                topology [Integer] - Slit topology
    
    RegionUnion(*args, **kwargs)
        Union of a set of planar closed curves (regions)
        Input:
                curves [Curve] - Curves for boolean union operation
                plane (in, optional) [Plane] - Optional plane for boolean solution
        Returns: [Curve] - Result outlines of boolean union
    
    RelativeDifferences(*args, **kwargs)
        Compute relative differences for a list of data
        Input:
                values [Generic Data] - List of data to operate on (numbers or points or vectors allowed)
        Returns: [Generic Data] - Differences between consecutive items
    
    RelativeItem(*args, **kwargs)
        Retrieve a relative item combo from a data tree
        Input:
                tree [Generic Data] - Tree to operate on
                offset [Text] - Relative offset for item combo
                wrap_paths [Boolean] - Wrap paths when the shift is out of bounds
                wrap_items [Boolean] - Wrap items when the shift is out of bounds
        Returns:
                item_a [Generic Data] - Tree item
                item_b [Generic Data] - Tree item relative to A
    
    RelativeItems(*args, **kwargs)
        Retrieve a relative item combo from two data trees
        Input:
                tree_a [Generic Data] - First Data Tree
                tree_b [Generic Data] - Second Data Tree
                offset [Text] - Relative offset for item combo
                wrap_paths [Boolean] - Wrap paths when the shift is out of bounds
                wrap_items [Boolean] - Wrap items when the shift is out of bounds
        Returns:
                item_a [Generic Data] - Item in tree A
                item_b [Generic Data] - Relative item in tree B
    
    RemapNumbers(*args, **kwargs)
        Remap numbers into a new numeric domain
        Input:
                value [Number] - Value to remap
                source [Domain] - Source domain
                target [Domain] - Target domain
        Returns:
                mapped [Number] - Remapped number
                clipped [Number] - Remapped and clipped number
    
    RemeshByColour(*args, **kwargs)
        Remeshing with edge lengths dependent on the vertex colours of the input mesh
        Input:
                mesh [Mesh] - Input coloured Mesh
                lengthinterval [Domain] - Edge length interval from black to white
                fixcurves (in, optional) [Curve] - Curves which will be kept sharp during remeshing. Can be boundary or internal curves
                fixvertices (in, optional) [Point] - Points to keep fixed during remeshing
                flip [Integer] - Criterion used to decide when to flip edges (0 for valence based, 1 for angle based)
                iterations [Integer] - Number of steps between outputs
                reset [Boolean] - True to initialize, false to run remeshing. Connect a timer for continuous remeshing
        Returns: [Mesh] - Remeshed result
    
    RenderAttributes(*args, **kwargs)
        Object render attributes
        Input:
                render (in, optional) [Render Attributes] - Object Render Attributes
                object_material (in, optional) [Object Material] - Object Render Material
                casts_shadows (in, optional) [Boolean] - Casts Shadows
                receives_shadows (in, optional) [Boolean] - Receives Shadows
        Returns:
                render [Render Attributes] - Object Render Attributes
                object_material [Object Material] - Object Render Material
                casts_shadows [Boolean] - Casts Shadows
                receives_shadows [Boolean] - Receives Shadows
    
    RenderMaterial(*args, **kwargs)
        Object render material attributes
        Input:
                object_material (in, optional) [Object Material] - Object Render Material
                source (in, optional) [Integer] - Material Source:
        0) By Layer
        1) By Object
        3) By Parent
                material (in, optional) [Model Material] - Model Material
        Returns:
                object_material [Object Material] - Object Render Material
                source [Integer] - Material Source:
        0) By Layer
        1) By Object
        3) By Parent
                material [Model Material] - Model Material
    
    RepeatData(*args, **kwargs)
        Repeat a pattern until it reaches a certain length.
        Input:
                data [Generic Data] - Pattern to repeat
                length [Integer] - Length of final pattern
        Returns: [Generic Data] - Repeated data
    
    ReplaceItems(*args, **kwargs)
        Replace certain items in a list.
        Input:
                list [Generic Data] - List to modify
                item (in, optional) [Generic Data] - Items to replace with. If no items are supplied, nulls will be inserted.
                indices (in, optional) [Integer] - Replacement index for each item
                wrap [Boolean] - If true, indices will be wrapped
        Returns: [Generic Data] - List with replaced values
    
    ReplaceMembers(*args, **kwargs)
        Replace members in a set.
        Input:
                set [Generic Data] - Set to operate on.
                find [Generic Data] - Item(s) to replace.
                replace (in, optional) [Generic Data] - Item(s) to replace with.
        Returns: [Generic Data] - Sets with replaced members.
    
    ReplaceNulls(*args, **kwargs)
        Replace nulls or invalid data with other data
        Input:
                items [Generic Data] - Items to test for null
                replacements [Generic Data] - Items to replace nulls with
        Returns:
                items [Generic Data] - List without any nulls
                count [Integer] - Number of items replaced
    
    ReplacePaths(*args, **kwargs)
        Find & replace paths in a data tree
        Input:
                data [Generic Data] - Data stream to process
                search [Text] - Search masks
                replace [Path] - Respective replacement paths
        Returns: [Generic Data] - Processed tree data
    
    ReplaceText(*args, **kwargs)
        Replace all occurences of a specific text fragment with another
        Input:
                text [Text] - Text to operate on.
                find (in, optional) [Text] - Fragment to replace.
                replace (in, optional) [Text] - Optional fragment to replace with. If blank, all occurences of F will be removed.
        Returns: [Text] - Result of text replacement
    
    Retrim(*args, **kwargs)
        Retrim a surface based on 3D trim data from another surface.
        Input:
                source [Surface] - Source surface providing the UV trim data.
                target [Surface] - Target surface to be trimmed
        Returns: [Surface] - Retrimmed surface
    
    Reverse(*args, **kwargs)
        Reverse a vector (multiply by -1).
        Input:
                vector [Vector] - Base vector
        Returns: [Vector] - Reversed vector
    
    ReverseList(*args, **kwargs)
        Reverse the order of a list.
        Input:
                list [Generic Data] - Base list
        Returns: [Generic Data] - Reversed list
    
    ReverseSurface(*args, **kwargs)
        Reverse directions of surface parameterization (U, V, and W)
        Input:
                surface [Surface] - Surface to reverse
                u [Boolean] - Reverse the {u} direction of the surface parameterization.
                v [Boolean] - Reverse the {v} direction of the surface parameterization.
                w [Boolean] - Reverse the {w} direction (also known as the normal) of the surface parameterization.
        Returns: [Surface] - Reversed surface
    
    Revolution(*args, **kwargs)
        Create a surface of revolution.
        Input:
                curve [Curve] - Profile curve
                axis [Line] - Revolution axis
                domain [Domain] - Angle domain (in radians)
        Returns: [Brep] - Brep representing the revolution result.
    
    RightTrigonometry(*args, **kwargs)
        Right triangle trigonometry
        Input:
                alpha (in, optional) [Number] - Optional alpha angle
                beta (in, optional) [Number] - Optional beta angle
                p_length (in, optional) [Number] - Optional length of P edge
                q_length (in, optional) [Number] - Optional length of Q edge
                r_length (in, optional) [Number] - Optional length of R edge
        Returns:
                alpha [Number] - Computed alpha angle
                beta [Number] - Computed beta angle
                p_length [Number] - Computed length of P edge
                q_length [Number] - Computed length of Q edge
                r_length [Number] - Computed length of R edge
    
    RigidBody(*args, **kwargs)
        RigidBody
        Input:
                part (in, optional) [Generic Data] - Part as a Mesh or Brep
                plane (in, optional) [Plane] - The initial frame of the body. If none supplied, an XY aligned plane at the centroid will be used
                points (in, optional) [Point] - Optional points to attach to the rigid body
                strength [Number] - Strength
        Returns:
                rigidbody [Generic Data] - RB
                planes [Plane] - The planes of the rigid bodies
    
    RigidBodyCollide(*args, **kwargs)
        Collision between a pair of rigid bodies
        Input:
                mesha (in, optional) [Mesh] - MeshA
                meshb (in, optional) [Mesh] - MeshB
                planea (in, optional) [Plane] - The initial frame of meshA
                planeb (in, optional) [Plane] - The initial frame of meshB
                strength [Number] - Strength
        Returns: [Generic Data] - SC
    
    RigidPointSet(*args, **kwargs)
        A set of points which maintain their relative positions
        Input:
                points [Point] - Rigid point set
                plane (in, optional) [Plane] - The initial frame of the body. If none supplied, an XY aligned plane at the centroid will be used
                strength [Number] - Strength
        Returns:
                rigidbody [Generic Data] - RB
                planes [Plane] - The planes of the rigid bodies
    
    Rod(*args, **kwargs)
        Bending and stretching resistant rod
        Input:
                polyline [Curve] - Polyline to turn into rod
                lengthfactor [Number] - Target edge length as a multiple of current length
                anglefactor [Number] - Target angle as a multiple of current angle
                axialstrength [Number] - Axial Strength
                bendstrength [Number] - Bending Strength
        Returns: [Generic Data] - out
    
    Rotate(*args, **kwargs)
        Rotate an object in a plane.
        Input:
                geometry (in, optional) [Geometry] - Base geometry
                angle [Number] - Rotation angle in radians
                plane [Plane] - Rotation plane
        Returns:
                geometry [Geometry] - Rotated geometry
                transform [Transform] - Transformation data
    
    Rotate3D(*args, **kwargs)
        Rotate an object around a center point and an axis vector.
        Input:
                geometry (in, optional) [Geometry] - Base geometry
                angle [Number] - Rotation angle in radians
                center [Point] - Center of rotation
                axis [Vector] - Axis of rotation
        Returns:
                geometry [Geometry] - Rotated geometry
                transform [Transform] - Transformation data
    
    RotateAxis(*args, **kwargs)
        Rotate an object around an axis.
        Input:
                geometry (in, optional) [Geometry] - Base geometry
                angle [Number] - Rotation angle in radians
                axis [Line] - Rotation axis
        Returns:
                geometry [Geometry] - Rotated geometry
                transform [Transform] - Transformation data
    
    RotateDirection(*args, **kwargs)
        Rotate an object from one direction to another.
        Input:
                geometry (in, optional) [Geometry] - Base geometry
                center [Point] - Rotation center point
                from [Vector] - Initial direction
                to [Vector] - Final direction
        Returns:
                geometry [Geometry] - Rotated geometry
                transform [Transform] - Transformation data
    
    RotatePlane(*args, **kwargs)
        Perform plane rotation around plane z-axis
        Input:
                plane [Plane] - Plane to rotate
                angle [Number] - Rotation (counter clockwise) around plane z-axis in radians
        Returns: [Plane] - Rotated plane
    
    Round(*args, **kwargs)
        Round a floating point value.
        Input:
                number [Number] - Number to round
        Returns:
                nearest [Integer] - Integer nearest to x
                floor [Integer] - First integer smaller than or equal to x
                ceiling [Integer] - First integer larger than or equal to x
    
    RuledSurface(*args, **kwargs)
        Create a surface between two curves.
        Input:
                curve_a [Curve] - First curve
                curve_b [Curve] - Second curve
        Returns: [Surface] - Ruled surface between A and B
    
    ScalarDisplay(*args, **kwargs)
        Display the scalar values of a field section
        Input:
                field [Field] - Field to evaluate
                section [Rectangle] - Rectangle describing section
                samples [Integer] - Section sample count indicator
        Returns: [Mesh] - Section display mesh
    
    Scale(*args, **kwargs)
        Scale an object uniformly in all directions.
        Input:
                geometry (in, optional) [Geometry] - Base geometry
                center [Point] - Center of scaling
                factor [Number] - Scaling factor
        Returns:
                geometry [Geometry] - Scaled geometry
                transform [Transform] - Transformation data
    
    ScaleNU(*args, **kwargs)
        Scale an object with non-uniform factors.
        Input:
                geometry (in, optional) [Geometry] - Base geometry
                plane [Plane] - Base plane
                scale_x [Number] - Scaling factor in {x} direction
                scale_y [Number] - Scaling factor in {y} direction
                scale_z [Number] - Scaling factor in {z} direction
        Returns:
                geometry [Geometry] - Scaled geometry
                transform [Transform] - Transformation data
    
    Script(*args, **kwargs)
        Scripting component
        Input:
                x (in, optional) [Generic Data] - No conversion
                y (in, optional) [Generic Data] - No conversion
        Returns:
                out [Text] - Standard output and error contents collected during script run
                a [Generic Data] - No conversion
    
    Seam(*args, **kwargs)
        Adjust the seam of a closed curve.
        Input:
                curve [Curve] - Curve to adjust
                seam [Number] - Parameter of new seam
        Returns: [Curve] - Adjusted curve
    
    Secant(*args, **kwargs)
        Compute the secant (reciprocal of the Cosine) of an angle.
        Input:
                value [Generic Data] - Input value
        Returns: [Generic Data] - Output value
    
    SegmentLengths(*args, **kwargs)
        Finds the shortest and longest segments of a curve.
        Input:
                curve [Curve] - Curve to measure
        Returns:
                shortest_length [Number] - Length of shortest segment
                shortest_domain [Domain] - Curve domain of shortest segment
                longest_length [Number] - Length of longest segment
                longest_domain [Domain] - Curve domain of longest segment
    
    Sequence(*args, **kwargs)
        Generate a sequence of numbers
        Input:
                notation [Text] - Sequence notation
                length [Integer] - Final length of sequence
                initial [Number] - Initial values in sequence
        Returns: [Number] - Sequence
    
    SerialDimension(*args, **kwargs)
        Create a distance annotation between multiple points, projected to a line.
        Input:
                line [Line] - Dimension base line
                points [Point] - Dimension points, the first one marks the zero point
                text [Text] - Dimension text
                size [Number] - Dimension size
    
    Series(*args, **kwargs)
        Create a series of numbers.
        Input:
                start [Number] - First number in the series
                step [Number] - Step size for each successive number
                count [Integer] - Number of values in the series
        Returns: [Number] - Series of numbers
    
    SetDifference(*args, **kwargs)
        Create the difference of two sets (the collection of objects present in A but not in B).
        Input:
                set_a [Generic Data] - Set to subtract from.
                set_b [Generic Data] - Substraction set.
        Returns: [Generic Data] - The Set Difference of A minus B
    
    SetDifferenceS(*args, **kwargs)
        Create the symmetric difference of two sets (the collection of objects present in A or B but not both).
        Input:
                set_a [Generic Data] - First set for symmetric difference.
                set_b [Generic Data] - Second set for symmetric difference.
        Returns: [Generic Data] - The symmetric difference between A and B.
    
    SetIntersection(*args, **kwargs)
        Creates the intersection of two sets (the collection of unique objects present in both sets).
        Input:
                set_a (in, optional) [Generic Data] - Data for set Intersection
                set_b (in, optional) [Generic Data] - Data for set Intersection
        Returns: [Generic Data] - The Set Union of all input sets
    
    SetMajority(*args, **kwargs)
        Determine majority member presence amongst three sets.
        Input:
                set_a [Generic Data] - First set.
                set_b [Generic Data] - Second set.
                set_c [Generic Data] - Third set.
        Returns: [Generic Data] - Set containing all unique elements in that occur in at least two of the input sets.
    
    SetUnion(*args, **kwargs)
        Creates the union of two sets (the collection of unique objects present in either set).
        Input:
                set_a (in, optional) [Generic Data] - Data for set Union.
                set_b (in, optional) [Generic Data] - Data for set Union.
        Returns: [Generic Data] - The Set Union of A and B.
    
    SettingsCustom(*args, **kwargs)
        Represents custom mesh settings.
        Input:
                stitch_seams [Boolean] - Edges of adjacent faces are matched up if True.
                simple_planes [Boolean] - Planar faces are meshed with a minimum amount of triangles.
                refine [Boolean] - Refine the initial grid if it exceeds tolerance accuracy.
                min_count [Integer] - Minimum number of quads in the initial grid per face.
                max_count [Integer] - Maximum number of quads in the initial grid per face.
                aspect_ratio [Number] - Maximum aspect ratio of quads in the initial grid.
                max_distance [Number] - Maximum allowed distance between center of edges and underlying surface.
                max_angle [Number] - Maximum allowed angle (in degrees) between the normals of two adjacent quads.
                min_edge [Number] - Minimum allowed edge length.
                max_edge [Number] - Maximum allowed edge length.
        Returns: [MeshParameters] - Smooth mesh settings
    
    SettingsQuality(*args, **kwargs)
        Represents 'Smooth & slower' mesh settings.
        Input:
        Returns: [MeshParameters] - Smooth mesh settings
    
    SettingsSpeed(*args, **kwargs)
        Represents 'Jagged & faster' mesh settings.
        Input:
        Returns: [MeshParameters] - Coarse mesh settings
    
    ShapeInBrep(*args, **kwargs)
        Tests whether a shape is inside a brep
        Input:
                brep [Brep] - Closed brep for inside/outside testing
                shape [Geometry] - Shape for inside/outside testing
        Returns: [Integer] - Relationship of shape to brep (0=inside, 1=intersecting, 2=outside)
    
    Shatter(*args, **kwargs)
        Shatter a curve into segments.
        Input:
                curve [Curve] - Curve to trim
                parameters [Number] - Parameters to split at
        Returns: [Curve] - Shattered remains
    
    Shear(*args, **kwargs)
        Shear an object based on a shearing vector.
        Input:
                geometry (in, optional) [Geometry] - Base geometry
                base [Plane] - Base plane
                grip [Point] - Reference point
                target [Point] - Target point
        Returns:
                geometry [Geometry] - Sheared geometry
                transform [Transform] - Transformatio data
    
    ShearAngle(*args, **kwargs)
        Shear an object based on tilt angles.
        Input:
                geometry (in, optional) [Geometry] - Base geometry
                base [Plane] - Base plane
                angle_x [Number] - Rotation around {x} axis in radians
                angle_y [Number] - Rotation around {y} axis in radians
        Returns:
                geometry [Geometry] - Sheared geometry
                transform [Transform] - Transformation data
    
    ShiftList(*args, **kwargs)
        Offset all items in a list.
        Input:
                list [Generic Data] - List to shift
                shift [Integer] - Shift offset
                wrap [Boolean] - Wrap values
        Returns: [Generic Data] - Shifted list
    
    ShiftPaths(*args, **kwargs)
        Shift the indices in all data tree paths
        Input:
                data [Generic Data] - Data to modify
                offset [Integer] - Offset to apply to each branch
        Returns: [Generic Data] - Shifted data
    
    ShortestList(*args, **kwargs)
        Shrink a collection of lists to the shortest length amongst them
        Input:
                list_(a) (in, optional) [Generic Data] - List (A) to operate on
                list_(b) (in, optional) [Generic Data] - List (B) to operate on
        Returns:
                list_(a) [Generic Data] - Adjusted list (A)
                list_(b) [Generic Data] - Adjusted list (B)
    
    Show(*args, **kwargs)
        Show
        Input:
                g (in, optional) [Generic Data] - Geometry
        Returns: [Generic Data] - Connect to GoalFunctions input
    
    ShrinkWrap(*args, **kwargs)
        ShrinkWrap a mesh or point cloud object
        Input:
                geometry [Geometry] - Geometry to ShrinkWrap
                edge_length (in, optional) [Number] - The desired target edge length in document units. Smaller values equal more mesh resolution at the expense of larger mesh sizes. If no edge length is provided, a value will be calculated based on heuristics to provide a loose shrinkwrapped mesh.
                offset [Number] - Distance to offset outward or inward
                smoothing [Integer] - The number of times to apply smoothing
                optimization [Integer] - Percentage [0-100%] of polygon optimization desired. Polygons will be reduced in areas of lower curvature. Lower values result in better feature preservation at the cost of more polygons.
                fill_holes [Boolean] - Should mesh inputs have holes filled prior to being ShrinkWrapped. This value is ignored when input objects are Point Clouds
        Returns: [Mesh] - Resulting ShrinkWrap mesh
    
    SiftPattern(*args, **kwargs)
        Sift elements in a list using a repeating index pattern.
        Input:
                list [Generic Data] - List to sift
                sift_pattern [Integer] - Sifting pattern
        Returns:
                output_0 [Generic Data] - Output for sift index 0
                output_1 [Generic Data] - Output for sift index 1
    
    Similarity(*args, **kwargs)
        Test for similarity of two numbers
        Input:
                first_number [Number] - Number to compare
                second_number [Number] - Number to compare to
                threshold [Number] - Percentage (0% ~ 100%) of A and B below which similarity is assumed
        Returns:
                similarity [Boolean] - True if A ≈ B
                absolute_difference [Number] - The absolute difference between A and B
    
    SimpleMesh(*args, **kwargs)
        Create a mesh that represents a Brep as simply as possible
        Input:
                brep [Brep] - Brep to mesh, only breps with triangle or quad faces are supported.
        Returns: [Mesh] - Mesh
    
    SimplifyCurve(*args, **kwargs)
        Simplify a curve.
        Input:
                curve [Curve] - Curve to simplify
                tolerance (in, optional) [Number] - Optional deviation tolerance (if omitted, the current document tolerance is used)
                angle_tolerance (in, optional) [Number] - Optional angle tolerance (if omitted, the current document tolerance is used)
        Returns:
                curve [Curve] - Simplified curve
                simplified [Boolean] - True if curve was modified in any way
    
    SimplifyTree(*args, **kwargs)
        Simplify a data tree by removing the overlap shared amongst all branches.
        Input:
                tree [Generic Data] - Data tree to simplify.
                front [Boolean] - Limit path collapse to indices at the start of the path only.
        Returns: [Generic Data] - Simplified data tree.
    
    Sinc(*args, **kwargs)
        Compute the sinc (Sinus Cardinalis) of a value.
        Input:
                value [Generic Data] - Input value
        Returns: [Generic Data] - Output value
    
    Sine(*args, **kwargs)
        Compute the sine of a value
        Input:
                value [Generic Data] - Input value
        Returns: [Generic Data] - Output value
    
    Skylight(*args, **kwargs)
        The Rhino skylight
        Input:
                skylight (in, optional) [Model Content] - The Rhino skylight
                enabled (in, optional) [Boolean] - Defines if the skylight is turned on (True) or off (False)
                custom_environment (in, optional) [Boolean] - Defines if the skylight uses a custom environment for reflections.
                environment (in, optional) [Model Environment] - Skylight Environment
        Returns:
                skylight [Model Content] - The Rhino skylight
                enabled [Boolean] - Defines if the skylight is turned on (True) or off (False)
                custom_environment [Boolean] - Defines if the skylight uses a custom environment for reflections.
                environment [Model Environment] - Skylight Environment
    
    SmallerThan(*args, **kwargs)
        Smaller than (or equal to)
        Input:
                first_number [Number] - Number to test
                second_number [Number] - Number to test against
        Returns:
                smaller_than [Boolean] - True if A < B
                …_or_equal_to [Boolean] - True if A <= B
    
    Smooth(*args, **kwargs)
        Smooth
        Input:
                m [Mesh] - M
                strength [Number] - Strength
        Returns: [Generic Data] - out
    
    SmoothMesh(*args, **kwargs)
        Smooth the vertices of a mesh
        Input:
                mesh [Mesh] - Mesh to smooth
                strength [Number] - Smoothing strength (0.0=none, 1.0=max)
                skip_naked [Boolean] - Skip naked vertices
                iterations [Integer] - Number of successive smoothing steps
                limit (in, optional) [Number] - Optional maximum displacement per point
        Returns: [Mesh] - Smoothed mesh
    
    SmoothNumbers(*args, **kwargs)
        Smooth out changing numbers over time
        Input:
                numbers (in, optional) [Number] - Changing numbers
        Returns: [Number] - Smoothened numbers
    
    SmoothPolyline(*args, **kwargs)
        Smooth the vertices of a polyline curve.
        Input:
                polyline [Curve] - Polyline to smooth
                strength [Number] - Smoothing strength (0 = none, 1 = maximum)
                times [Integer] - Number of times to apply the smoothing operation
        Returns: [Curve] - Smoothed polyline
    
    SoapFilm(*args, **kwargs)
        For generating zero mean curvature meshes
        Input:
                mesh [Mesh] - The mesh to minimize
                strength [Number] - Strength
        Returns: [Generic Data] - Soap out
    
    SoftBodyCollide(*args, **kwargs)
        Collisions between a collection of deformable meshes
        Input:
                meshes (in, optional) [Mesh] - Meshes to collide with each other
                strength [Number] - Strength
        Returns: [Generic Data] - SB
    
    SoftHardSolver(*args, **kwargs)
        Solver with separate inputs for soft goals, and hard constraint type goals
        Input:
                softgoals (in, optional) [Generic Data] - These goals will be met only if they do not conflict with the hard goals
                hardgoals (in, optional) [Generic Data] - These goals will override the soft goals
                harditerations [Integer] - The number of hard iterations performed after each soft step
                softmultiplier [Number] - Multiplier for the soft movement. This can be decreased to zero at the end if you want maximum accuracy
                reset [Boolean] - Hard Reset (completely rebuild the particle list and indexing)
                threshold [Number] - Stop when average movement is less than this (default is 1e-15)
                tolerance [Number] - Points closer than this distance will be combined into a single particle
                on [Boolean] - If true, Kangaroo will continue to iterate until reaching the given threshold value
        Returns:
                i [Integer] - Iterations
                v [Point] - V
                o [Generic Data] - GoalFunction Output tree
    
    SolidDifference(*args, **kwargs)
        Perform a solid difference on two Brep sets.
        Input:
                breps_a [Brep] - First Brep set
                breps_b [Brep] - Second Brep set
        Returns: [Brep] - Difference result
    
    SolidIntersection(*args, **kwargs)
        Perform a solid intersection on two Brep sets.
        Input:
                breps_a [Brep] - First Brep set
                breps_b [Brep] - Second Brep set
        Returns: [Brep] - Intersection result
    
    SolidPlaneCollide(*args, **kwargs)
        Collision between a plane and a solid
        Input:
                solid (in, optional) [Mesh] - Solid
                solidplane (in, optional) [Plane] - The initial frame of the solid
                collisionplane (in, optional) [Plane] - The plane to collide with
                strength [Number] - Strength
        Returns: [Generic Data] - SP
    
    SolidPointCollide(*args, **kwargs)
        Keep a set of points outside or inside a given Mesh
        Input:
                points (in, optional) [Point] - Points to affect
                solid (in, optional) [Mesh] - A closed solid (Brep or mesh)
                interior [Boolean] - If false, points will be kept outside the solid. If true they will be kept inside
                unidirectional [Boolean] - If true the mesh is used only as input, and is not itself affected by the collisions
                strength [Number] - Strength
        Returns: [Generic Data] - S
    
    SolidUnion(*args, **kwargs)
        Perform a solid union on a set of Breps.
        Input:
                breps [Brep] - Breps to union
        Returns: [Brep] - Union result
    
    Solver(*args, **kwargs)
        The main component where Goals are combined and applied
        Input:
                goalobjects (in, optional) [Generic Data] - GoalObjects
                reset [Boolean] - Hard Reset (completely rebuild the particle list and indexing)
                threshold [Number] - Stop when average movement is less than this (default is 1e-15)
                tolerance [Number] - Points closer than this distance will be combined into a single particle
                on [Boolean] - If true, Kangaroo will continue to iterate until reaching the given threshold value
        Returns:
                i [Integer] - Iterations
                v [Point] - V
                o [Generic Data] - GoalFunction Output tree
    
    SortAlongCurve(*args, **kwargs)
        Sort points along a curve
        Input:
                points [Point] - Points to sort
                curve [Curve] - Curve to sort along
        Returns:
                points [Point] - Sorted points
                indices [Integer] - Point index map
    
    SortList(*args, **kwargs)
        Sort a list of numeric keys.
        Input:
                keys [Number] - List of sortable keys
                values_a (in, optional) [Generic Data] - Optional list of values to sort synchronously
        Returns:
                keys [Number] - Sorted keys
                values_a [Generic Data] - Synchronous values in A
    
    SortPoints(*args, **kwargs)
        Sort points by Euclidean coordinates (first x, then y, then z)
        Input:
                points [Point] - Points to sort
        Returns:
                points [Point] - Sorted points
                indices [Integer] - Point index map
    
    SortText(*args, **kwargs)
        Sort a collection of text fragments
        Input:
                keys [Text] - Text fragments to sort (sorting key)
                values (in, optional) [Generic Data] - Optional values to sort synchronously
                culture [Culture] - Cultural sorting rules
        Returns:
                keys [Text] - Sorted text fragments
                values [Generic Data] - Sorted values
    
    SpatialDeform(*args, **kwargs)
        Perform spatial deformation based on custom space syntax.
        Input:
                geometry [Geometry] - Geometry to deform
                syntax [Point] - Points describing space syntax.
                forces [Vector] - Forces (one for each point in space
        Returns: [Geometry] - Deformed geometry
    
    SpatialDeformcustom(*args, **kwargs)
        Perform spatial deformation based on custom space syntax.
        Input:
                geometry [Geometry] - Geometry to deform
                syntax [Point] - Points describing space syntax.
                forces [Vector] - Forces (one for each point in space
                falloff [Text] - Falloff function (for variable 'x')
        Returns: [Geometry] - Deformed geometry
    
    Sphere(*args, **kwargs)
        Create a spherical surface.
        Input:
                base [Plane] - Base plane
                radius [Number] - Sphere radius
        Returns: [Surface] - Resulting sphere
    
    Sphere4Pt(*args, **kwargs)
        Create a spherical surface from 4 points.
        Input:
                point_1 [Point] - First point
                point_2 [Point] - Second point (cannot be coincident with P1)
                point_3 [Point] - Third point (cannot be colinear with P1 & P2)
                point_4 [Point] - Fourth point (cannot be coplanar with P1, P2 & P3)
        Returns:
                center [Point] - Center of sphere
                radius [Number] - Radius of sphere
                sphere [Surface] - Sphere fitted to P1~P4
    
    SphereCollide(*args, **kwargs)
        Collisions between large numbers of equal sized spheres
        Input:
                points (in, optional) [Point] - List of points at the centres of the spheres to collide
                radius [Number] - The radius of the spheres
                strength [Number] - Strength
        Returns: [Generic Data] - S
    
    SphereFit(*args, **kwargs)
        Fit a sphere to a 3D collection of points
        Input:
                points [Point] - Points to fit
        Returns:
                center [Point] - Center of fitted sphere
                radius [Number] - Radius of fitted sphere
                sphere [Surface] - Sphere surface
    
    SpinForce(*args, **kwargs)
        Create a field due to a spin force
        Input:
                plane [Plane] - Center and orientation of spin disc
                strength [Number] - Strength of spin force at center of disc
                radius [Number] - Radius unit of spin disc
                decay [Number] - Decay of spin force
                bounds (in, optional) [Box] - Optional bounds for the field
        Returns: [Field] - Field due to vector force
    
    Split(*args, **kwargs)
        Split a compound transformation into fragments.
        Input:
                transform [Transform] - Compound transformation
        Returns: [Transform] - Fragments making up the compound transformation
    
    SplitAHSL(*args, **kwargs)
        Split a colour into floating point {AHSL} channels
        Input:
                colour [Colour] - Input colour
        Returns:
                alpha [Number] - Alpha channel
                hue [Number] - Hue
                saturation [Number] - Saturation
                luminance [Number] - Luminance
    
    SplitAHSV(*args, **kwargs)
        Split a colour into floating point {AHSV} channels
        Input:
                colour [Colour] - Input colour
        Returns:
                alpha [Number] - Alpha channel
                hue [Number] - Hue
                saturation [Number] - Saturation
                value [Number] - Value (Brightness)
    
    SplitARGB(*args, **kwargs)
        Split a colour into floating point {ARGB} channels.
        Input:
                colour [Colour] - Input colour
        Returns:
                alpha [Number] - Alpha channel
                red [Number] - Red channel
                green [Number] - Green channel
                blue [Number] - Blue channel
    
    SplitAtCorners(*args, **kwargs)
        Break a polyline into multiple parts based on angle
        Input:
                poly [Curve] - The polyline to split
                angle [Number] - Angle in radians to split at
        Returns:
                corners [Point] - Points at which the angle exceeded the threshold
                parts [Curve] - A list of separate polylines
    
    SplitBrep(*args, **kwargs)
        Split one brep with another.
        Input:
                brep [Brep] - Brep to split
                cutter (in, optional) [Brep] - Cutting shape
        Returns: [Brep] - Brep fragments
    
    SplitBrepMultiple(*args, **kwargs)
        Split one brep with a bunch of others.
        Input:
                brep [Brep] - Brep to split
                cutters (in, optional) [Brep] - Cutting shapes
        Returns: [Brep] - Brep fragments
    
    SplitGroup(*args, **kwargs)
        Split a group
        Input:
                group [Group] - Group to split
                indices [Integer] - Split indices
                wrap [Boolean] - Wrap indices
        Returns:
                group_a [Group] - Group including all the indices
                group_b [Group] - Group excluding all the indices (hidden)
    
    SplitList(*args, **kwargs)
        Split a list into separate parts.
        Input:
                list [Generic Data] - Base list
                index [Integer] - Splitting index
        Returns:
                list_a [Generic Data] - Items to the left of (i)
                list_b [Generic Data] - Items to the right of and including (i)
    
    SplitTree(*args, **kwargs)
        Split a data tree into two parts using path masks.
        Input:
                data [Generic Data] - Tree to split
                masks [Text] - Splitting masks
        Returns:
                positive [Generic Data] - Positive set of data (all branches that match any of the masks)
                negative [Generic Data] - Negative set of data (all branches that do not match any of the masks
    
    SplitwithBrep(*args, **kwargs)
        Split a curve with a Brep.
        Input:
                curve [Curve] - Curve to split
                brep [Brep] - Brep to split with
        Returns:
                curve [Curve] - Split curves
                points [Point] - Split points
    
    SplitwithBreps(*args, **kwargs)
        Split a curve with multiple Breps.
        Input:
                curve [Curve] - Curve to trim
                brep [Brep] - Brep to trim against
        Returns:
                curve [Curve] - Split curves
                points [Point] - Split points
    
    Splop(*args, **kwargs)
        Wraps geometry onto a surface.
        Input:
                geometry [Geometry] - Geometry to deform
                plane [Plane] - Source plane of deformation
                surface [Surface] - Surface to wrap geometry onto
                parameter [Point] - U,V parameter on surface used for orienting
                angle [Number] - Rotation angle in radians
                rigid [Boolean] - Geometry will not be deformed as it is transformed
        Returns: [Geometry] - Morphed geometry
    
    Sporph(*args, **kwargs)
        Deforms an object from a source surface to a target surface
        Input:
                geometry [Geometry] - Base geometry
                base [Surface] - Base surface
                base_uv (in, optional) [Point] - U,V parameter on base surface used for orienting.
                target [Surface] - Target surface
                target_uv (in, optional) [Point] - U,V parameter on target surface used for orienting.
                rigid [Boolean] - Geometry will not be deformed as it is transformed
        Returns: [Geometry] - Morphed geometry
    
    Spotlight(*args, **kwargs)
        Spotlight
        Input:
                spotlight (in, optional) [Light] - The Rhino spotlight
                location (in, optional) [Point] - Location of the spotlight
                target (in, optional) [Point] - Location of the spotlight target
                spotlight_hardness (in, optional) [Number] - Spotlight hardness
        [0.0..1.0]
                spotlight_angle (in, optional) [Number] - Spotlight angle
        [0..π/2.0] or [0°..90°]
        Returns:
                spotlight [Light] - The Rhino spotlight
                location [Point] - Location of the spotlight
                target [Point] - Location of the spotlight target
                spotlight_hardness [Number] - Spotlight hardness
        [0.0..1.0]
                spotlight_angle [Number] - Spotlight angle
        [0..π/2.0] or [0°..90°]
    
    Square(*args, **kwargs)
        2D grid with square cells
        Input:
                plane [Plane] - Base plane for grid
                size [Number] - Size of grid cells
                extent_x [Integer] - Number of grid cells in base plane x direction
                extent_y [Integer] - Number of grid cells in base plane y direction
        Returns:
                cells [Rectangle] - Grid cell outlines
                points [Point] - Points at grid corners
    
    SquareRoot(*args, **kwargs)
        Compute the square root of a value
        Input:
                value [Generic Data] - Input value
        Returns: [Generic Data] - Output value
    
    StackData(*args, **kwargs)
        Duplicate individual items in a list of data
        Input:
                data [Generic Data] - Data to stack
                stack [Integer] - Stacking pattern
        Returns: [Generic Data] - Stacked data
    
    StepSolver(*args, **kwargs)
        Solver which advances only when input refreshed. Useful for making animations
        Input:
                goalobjects (in, optional) [Generic Data] - GoalObjects
                tolerance [Number] - Points closer than this distance will be combined into a single particle
                momentum [Boolean] - If false, the simulation tries to converge as quickly as possible. If true, the dynamics are more physically based
                damping [Number] - Value between 0 and 1, for how much velocity is preserved between iterations. Only used if Momentum is on
                subiterations [Integer] - Number of iterations per frame
                animate [Boolean] - If false, simulation resets. If true the solution will advance by one frame each time this input is received
        Returns:
                i [Integer] - Iterations
                v [Point] - V
                o [Generic Data] - GoalFunction Outputs
    
    StreamFilter(*args, **kwargs)
        Filters a collection of input streams
        Input:
                gate [Integer] - Index of Gate stream
                stream_0 (in, optional) [Generic Data] - Input stream at index 0
                stream_1 (in, optional) [Generic Data] - Input stream at index 1
        Returns: [Generic Data] - Filtered stream
    
    StreamGate(*args, **kwargs)
        Redirects a stream into specific outputs.
        Input:
                stream [Generic Data] - Input stream
                gate [Integer] - Gate index of output stream
        Returns:
                target_0 [Generic Data] - Output for Gate index 0
                target_1 [Generic Data] - Output for Gate index 1
    
    Stretch(*args, **kwargs)
        Deforms objects by stretching them along a finite axis.
        Input:
                geometry [Geometry] - Base geometry
                axis [Line] - Stretch axis
                length [Number] - Length of new stretch axis.
                rigid [Boolean] - Geometry will not be deformed as it is transformed
        Returns: [Geometry] - Morphed geometry
    
    Stripper(*args, **kwargs)
        Divide a mesh into strips
        Input:
                mesh [Mesh] - Input Mesh
        Returns: [Mesh] - List of Mesh Strips
    
    SubCurve(*args, **kwargs)
        Construct a curve from the sub-domain of a base curve.
        Input:
                base_curve [Curve] - Base curve
                domain [Domain] - Sub-domain to extract
        Returns: [Curve] - Resulting sub curve
    
    SubDControlPolygon(*args, **kwargs)
        Extract the control polygon from a SubD.
        Input:
                subd [SubD] - SubD
        Returns: [Mesh] - Control mesh
    
    SubDEdgeTags(*args, **kwargs)
        Set the edge tags of a SubD shape.
        Input:
                subd [SubD] - SubD to modify.
                edge_tag [Text] - Edge tag descriptor.
                edge_ids [Integer] - Edge identifiers.
        Returns: [SubD] - Modified SuD shape.
    
    SubDEdges(*args, **kwargs)
        Extract all edge data from a SubD.
        Input:
                subd [SubD] - SubD
        Returns:
                line [Line] - Edge line
                edge [Curve] - Edge curve
                tag [Text] - Edge tag
                id [Text] - Edge identifier
    
    SubDFuse(*args, **kwargs)
        Combine 2 SubD objects
        Input:
                subd_a [Mesh] - First SubD or Mesh object to be fused
                subd_b [Mesh] - Second SubD or Mesh object to be fused
                boolean_option [Integer] - Boolean type: 0=Union, 1=Intersection, 2=A-B, 3=B-A
                smoothing [Integer] - Number of smoothing steps to perform on the join
        Returns: [SubD] - Fused result
    
    SubDVertexTags(*args, **kwargs)
        Set the vertex tags of a SubD shape.
        Input:
                subd [SubD] - SubD to modify.
                vertex_tag [Text] - Vertex tag descriptor. (S=smooth, C=crease, L=corner, D=dart)
                vertex_ids [Integer] - Vertex identifiers.
        Returns: [SubD] - Modified SuD shape.
    
    SubDVertices(*args, **kwargs)
        Extract all vertex data from a SubD.
        Input:
                subd [SubD] - SubD
        Returns:
                point [Point] - Vertex location on control net.
                id [Text] - Vertex identifier.
                tag [Text] - Vertex tag type.
    
    SubDfromMesh(*args, **kwargs)
        Create a SubD from a control mesh
        Input:
                mesh [Mesh] - Control Mesh
                creases [Integer] - Subdivision crease option
                corners [Integer] - Subdivision corner option
                interpolate [Boolean] - Interpolate mesh vertices
        Returns: [SubD] - SubD
    
    SubList(*args, **kwargs)
        Extract a subset from a list.
        Input:
                list [Generic Data] - Base list
                domain [Domain] - Domain of indices to copy
                wrap [Boolean] - Remap indices that overshoot list domain
        Returns:
                list [Generic Data] - Subset of base list
                index [Integer] - Indices of subset items
    
    SubSet(*args, **kwargs)
        Test two sets for inclusion.
        Input:
                set_a [Generic Data] - Super set.
                set_b [Generic Data] - Sub set.
        Returns: [Boolean] - True if all items in B are present in A.
    
    Substrate(*args, **kwargs)
        Substrate algorithm inspired by Jared Tarbell (Complexification.net)
        Input:
                border [Rectangle] - Border for substrate
                count [Integer] - Number of lines in substrate
                angles [Number] - Base angles (in radians) in substrate
                deviation [Number] - Angular deviation (in radians) of new lines
                seed [Integer] - Random seed for solution
        Returns: [Line] - Substrate diagram
    
    Subtraction(*args, **kwargs)
        Mathematical subtraction
        Input:
                a (in, optional) [Generic Data] - First operand for subtraction
                b (in, optional) [Generic Data] - Second operand for subtraction
        Returns: [Generic Data] - Result of subtraction
    
    SumSurface(*args, **kwargs)
        Create a sum surface from two edge curves.
        Input:
                curve_a [Curve] - First curve
                curve_b [Curve] - Second curve
        Returns: [Brep] - BRep representing the sum-surface
    
    Sun(*args, **kwargs)
        Sun from Earth anchor point and date/time.
        Input:
                sun (in, optional) [Model Content] - The Rhino sun
                enabled (in, optional) [Boolean] - Defines if the sun is turned on (True) or off (False)
                intensity (in, optional) [Number] - Light intensity
                date_time (in, optional) [Time] - The observer's date and time. Note: This date and time are stored as the local sun time, i.e., the time you see in the Rhino UI under 'Local'.
                latitude (in, optional) [Number] - Latitude on Earth. 
        +90 = North pole, 0 = Equator, -90 = South pole
                longitude (in, optional) [Number] - Longitude on Earth.
        [-180..+180]
        Returns:
                sun [Model Content] - The Rhino sun
                enabled [Boolean] - Defines if the sun is turned on (True) or off (False)
                intensity [Number] - Light intensity
                date_time [Time] - The observer's date and time. Note: This date and time are stored as the local sun time, i.e., the time you see in the Rhino UI under 'Local'.
                latitude [Number] - Latitude on Earth. 
        +90 = North pole, 0 = Equator, -90 = South pole
                longitude [Number] - Longitude on Earth.
        [-180..+180]
    
    SunManualControl(*args, **kwargs)
        Sun from North angle, azimuth, and altitude values.
        Input:
                sun (in, optional) [Model Content] - The Rhino sun
                enabled (in, optional) [Boolean] - Defines if the sun is turned on (True) or off (False)
                intensity (in, optional) [Number] - Light intensity
                azimuth (in, optional) [Number] - The Azimuth angle. Azimuth is the compass angle from North.
        [0..+360]
                altitude (in, optional) [Number] - The Altitude angle. Altitude is the angle above the ground plane.
        [-90..+90]
        Returns:
                sun [Model Content] - The Rhino sun
                enabled [Boolean] - Defines if the sun is turned on (True) or off (False)
                intensity [Number] - Light intensity
                azimuth [Number] - The Azimuth angle. Azimuth is the compass angle from North.
        [0..+360]
                altitude [Number] - The Altitude angle. Altitude is the angle above the ground plane.
        [-90..+90]
    
    SunPreview(*args, **kwargs)
        Preview a sun or its related moon.
        Input:
                sun [Model Content] - The sun to preview
                location (in, optional) [Earth Location] - Observer location
                distance (in, optional) [Number] - Sun distance from origin
                scale (in, optional) [Number] - Sun radius scale
    
    Support(*args, **kwargs)
        Set support conditions for a beam end or rigid body
        Input:
                frame (in, optional) [Plane] - The plane to restrain
                target (in, optional) [Plane] - Target plane. If none supplied, the initial Frame will be used
                x [Boolean] - Translation in X
                y [Boolean] - Translation in Y
                z [Boolean] - Translation in Z
                xx [Boolean] - Rotation about X
                yy [Boolean] - Rotation about Y
                zz [Boolean] - Rotation about Z
                strength [Number] - Strength
        Returns: [Generic Data] - S
    
    SurfaceBox(*args, **kwargs)
        Create a twisted box on a surface patch.
        Input:
                surface [Surface] - Base surface
                domain [Domain²] - Surface domain
                height [Number] - Height of surface box
        Returns: [Twisted Box] - Resulting surface box
    
    SurfaceClosestPoint(*args, **kwargs)
        Find the closest point on a surface.
        Input:
                point [Point] - Sample point
                surface [Surface] - Base surface
        Returns:
                point [Point] - Closest point
                uv_point [Point] - {uv} coordinates of closest point
                distance [Number] - Distance between sample point and surface
    
    SurfaceCurvature(*args, **kwargs)
        Evaluate the surface curvature at a {uv} coordinate.
        Input:
                surface [Surface] - Base surface
                point [Point] - {uv} coordinate to evaluate
        Returns:
                frame [Plane] - Surface frame at {uv} coordinate
                gaussian [Number] - Gaussian curvature
                mean [Number] - Mean curvature
    
    SurfaceFrames(*args, **kwargs)
        Generate a grid of {uv} frames on a surface
        Input:
                surface [Surface] - Surface to divide
                u_count [Integer] - Number of segments in U-direction
                v_count [Integer] - Number of segments in V-direction
        Returns:
                frames [Plane] - Surface Frames
                parameters [Point] - Parameter coordinates at division points
    
    SurfaceFromPoints(*args, **kwargs)
        Create a nurbs surface from a grid of points.
        Input:
                points [Point] - Grid of points
                u_count [Integer] - Number of points in {u} direction
                interpolate [Boolean] - Interpolate samples
        Returns: [Surface] - Resulting surface
    
    SurfaceMorph(*args, **kwargs)
        Morph geometry into surface UVW coordinates
        Input:
                geometry [Geometry] - Geometry to deform
                reference [Box] - Reference box to map from
                surface [Surface] - Surface to map onto
                u_domain [Domain] - Surface space U extents
                v_domain [Domain] - Surface space V extents
                w_domain [Domain] - Surface space W extents
        Returns: [Geometry] - Deformed geometry
    
    SurfacePoints(*args, **kwargs)
        Get the control-points of a Nurbs Surface
        Input:
                surface [Surface] - Surface for control-point extraction
        Returns:
                points [Point] - Control point locations
                weights [Number] - Control point weights
                greville [Point] - Greville uv points
                u_count [Integer] - Number of points along U direction
                v_count [Integer] - Number of points along V direction
    
    SurfaceSplit(*args, **kwargs)
        Split a surface with a bunch of curves.
        Input:
                surface [Surface] - Base surface
                curves (in, optional) [Curve] - Splitting curves
        Returns: [Surface] - Splitting fragments
    
    SurfaceXCurve(*args, **kwargs)
        Solve intersection events for a surface and a curve.
        Input:
                surface [Surface] - Base surface
                curve [Curve] - Intersection curve
        Returns:
                curves [Curve] - Intersection overlap curves
                points [Point] - Intersection points
                uv_points [Point] - Surface {uv} coordinates at intersection events
                normals [Vector] - Surface normal vector at intersection events
                parameters [Number] - Curve parameter at intersection events
                tangents [Vector] - Curve tangent vector at intersection events
    
    SurfaceXLine(*args, **kwargs)
        Solve intersection events for a surface and a line.
        Input:
                surface [Surface] - Base surface
                line [Line] - Intersection line
        Returns:
                curves [Curve] - Intersection overlap curves
                points [Point] - Intersection points
                uv_points [Point] - Surface {uv} coordinates at intersection events
                normal [Vector] - Surface normal vector at intersection events
    
    SwapColumns(*args, **kwargs)
        Swap two columns in a matrix
        Input:
                matrix [Matrix] - Matrix for column swap
                column_a [Integer] - First column index
                column_b [Integer] - Second column index
        Returns: [Matrix] - Matrix with swapped rows
    
    SwapRows(*args, **kwargs)
        Swap two rows in a matrix
        Input:
                matrix [Matrix] - Matrix for row swap
                row_a [Integer] - First row index
                row_b [Integer] - Second row index
        Returns: [Matrix] - Matrix with swapped rows
    
    Sweep1(*args, **kwargs)
        Create a sweep surface with one rail curve.
        Input:
                rail [Curve] - Rail curve
                sections [Curve] - Section curves
                miter [Integer] - Kink miter type (0=None, 1=Trim, 2=Rotate)
        Returns: [Brep] - Resulting Brep
    
    Sweep2(*args, **kwargs)
        Create a sweep surface with two rail curves.
        Input:
                rail_1 [Curve] - First rail curve
                rail_2 [Curve] - Second rail curve
                sections [Curve] - Section curves
                same_height [Boolean] - Create a sweep with same-height properties.
        Returns: [Brep] - Resulting Brep
    
    SymbolAdvanced(*args, **kwargs)
        Advanced symbol display properties
        Input:
                style [Integer] - Symbol style
                size_primary [Number] - Symbol size
                size_secondary [Number] - Alternative size or offset (depending on style).
                rotation [Number] - Rotation angle
                fill [Colour] - Fill colour
                edge [Colour] - Edge colour
                width [Number] - Edge width
                adjust [Boolean] - Adjust apparent size based on view
        Returns: [Symbol Display] - Symbol display properties
    
    SymbolDisplay(*args, **kwargs)
        Display symbols
        Input:
                location [Point] - Symbol location
                display [Symbol Display] - Symbol display properties
    
    SymbolSimple(*args, **kwargs)
        Simple symbol display properties
        Input:
                style [Integer] - Symbol style
                size [Number] - Primary radius or outer size
                rotation [Number] - Rotation angle
                colour [Colour] - Main colour
        Returns: [Symbol Display] - Symbol display properties
    
    Tangent(*args, **kwargs)
        Compute the tangent of a value
        Input:
                value [Generic Data] - Input value
        Returns: [Generic Data] - Output value
    
    TangentArcs(*args, **kwargs)
        Create tangent arcs between circles
        Input:
                circle_a [Circle] - First base circle
                circle_b [Circle] - Second base circle
                radius [Number] - Radius of tangent arcs
        Returns:
                arc_a [Arc] - First tangent arc solution
                arc_b [Arc] - Second tangent arc solution
    
    TangentCircles(*args, **kwargs)
        Generate face incircles, circle packing centred on vertices, or incircular dual
        Input:
                mesh [Mesh] - Mesh
        Returns:
                incircles [Circle] - Incircles
                circle_packing [Circle] - C
                dual [Curve] - Dual based on incircle centers
    
    TangentCurve(*args, **kwargs)
        Create a curve through a set of points with tangents.
        Input:
                vertices [Point] - Interpolation points
                tangents [Vector] - Tangent vectors for all interpolation points
                blend [Number] - Blend factor
                degree [Integer] - Curve degree (only odd degrees are supported)
        Returns:
                curve [Curve] - Resulting nurbs curve
                length [Number] - Curve length
                domain [Domain] - Curve domain
    
    TangentIncircles(*args, **kwargs)
        TangentIncircles
        Input:
                mesh (in, optional) [Mesh] - Triangular mesh
                boundary (in, optional) [Curve] - Optional boundary curve
                strength [Number] - Strength
        Returns: [Generic Data] - TI out
    
    TangentLines(*args, **kwargs)
        Create tangent lines between a point and a circle
        Input:
                point [Point] - Point for tangent lines
                circle [Circle] - Base circle
        Returns:
                tangent_1 [Line] - Primary tangent
                tangent_2 [Line] - Secondary tangent
    
    TangentLinesEx(*args, **kwargs)
        Create external tangent lines between circles
        Input:
                circle_a [Circle] - First base circle
                circle_b [Circle] - Second base circle
        Returns:
                tangent_1 [Line] - Primary exterior tangent
                tangent_2 [Line] - Secondary exterior tangent
    
    TangentLinesIn(*args, **kwargs)
        Create internal tangent lines between circles
        Input:
                circle_a [Circle] - First base circle
                circle_b [Circle] - Second base circle
        Returns:
                tangent_1 [Line] - Primary interior tangent
                tangent_2 [Line] - Secondary interior tangent
    
    TangentialSmooth(*args, **kwargs)
        Smooth a mesh only in the local tangent planes. Used in conjunction with SoapFilm
        Input:
                m [Mesh] - M
                strength [Number] - Strength
        Returns: [Generic Data] - out
    
    Taper(*args, **kwargs)
        Deforms objects toward or away from an axis
        Input:
                geometry [Geometry] - Base geometry
                axis [Line] - Taper axis
                start [Number] - Radius at start of taper axis
                end [Number] - Radius at end of taper axis
                flat [Boolean] - If true, then a one-directional, one-dimensional taper is created.
                infinite [Boolean] - If true, the deformation happens throughout the geometry, even if the axis is shorter. If false, the deformation takes place only the length of the axis.
                rigid [Boolean] - Geometry will not be deformed as it is transformed
        Returns: [Geometry] - Morphed geometry
    
    TensorDisplay(*args, **kwargs)
        Display the tensor vectors of a field section
        Input:
                field [Field] - Field to evaluate
                section [Rectangle] - Rectangle describing section
                samples [Integer] - Section sample count indicator
    
    TextCase(*args, **kwargs)
        Change the CaSiNg of a piece of text
        Input:
                text [Text] - Text to modify
                culture [Culture] - Cultural rules for text casing
        Returns:
                upper_case [Text] - Upper case representation of T
                lower_case [Text] - Lower case representation of T
    
    TextDistance(*args, **kwargs)
        Compute the Levenshtein distance between two fragments of text.
        Input:
                text_a [Text] - First text fragment
                text_b [Text] - Second text fragment
                case [Boolean] - Compare using case-sensitive matching
        Returns: [Integer] - Levenshtein distance between the two fragments
    
    TextEntity(*args, **kwargs)
        Text Entity
        Input:
                text_entity (in, optional) [Text Entity] - The Rhino text entity
                plane (in, optional) [Plane] - Plane that this text entity lies on
                text (in, optional) [Text] - Plain text to be displayed in the text entity
                style (in, optional) [Model Annotation Style] - The annotation style.
        Returns:
                text_entity [Text Entity] - The Rhino text entity
                plane [Plane] - Plane that this text entity lies on
                text [Text] - Plain text to be displayed in the text entity
                style [Model Annotation Style] - The annotation style.
    
    TextFieldExpression(*args, **kwargs)
        Build a field expression which can be used as a text field on annotations or as a user text value.
        Input:
                object [Model Object] - Object to extract its user text
                key [Text] - User Text Key
        Returns: [Text] - The formatted text field expression
    
    TextFragment(*args, **kwargs)
        Extract a fragment (subset) of some text
        Input:
                text [Text] - Text to operate on.
                start [Integer] - Zero based index of first character to copy.
                count (in, optional) [Integer] - Optional number of characters to copy. If blank, the entire remainder will be copied.
        Returns: [Text] - The resulting text fragment
    
    TextJoin(*args, **kwargs)
        Join a collection of text fragments into one
        Input:
                text [Text] - Text fragments to join.
                join (in, optional) [Text] - Fragment separator.
        Returns: [Text] - Resulting text
    
    TextLength(*args, **kwargs)
        Get the length (character count) of some text
        Input:
                text [Text] - Text to measure.
        Returns: [Integer] - Number of characters
    
    TextOnSurface(*args, **kwargs)
        Create a collection of textual symbols aligned on a surface.
        Input:
                text [Text] - Text to create.
                font [Text] - Font name, with optional 'Bold' or 'Italic' tags.
                height [Number] - Height of text shapes.
                depth [Number] - Depth of text shapes.
                base_line [Curve] - Base line for text.
                base_surface (in, optional) [Generic Data] - Optional base surface for text orientation. Surfaces, meshes and SubDs are all allowed.
        Returns: [Brep] - Symbols making up the text shapes.
    
    TextSplit(*args, **kwargs)
        Split some text into fragments using separators
        Input:
                text [Text] - Text to split.
                separators [Text] - Separator characters.
        Returns: [Text] - Resulting text fragments
    
    TextTag(*args, **kwargs)
        Represents a list of text tags in a Rhino viewport
        Input:
                location [Point] - Location of text tag
                text [Text] - The text to display
                colour (in, optional) [Colour] - Optional colour for tag
    
    TextTag3D(*args, **kwargs)
        Represents a list of 3D text tags in a Rhino viewport
        Input:
                location [Plane] - Location and orientation of text tag
                text (in, optional) [Text] - The text to display
                size [Number] - Size of text
                colour (in, optional) [Colour] - Optional colour of tag
                justification [Integer] - Text justification
    
    TextTrim(*args, **kwargs)
        Remove whitespace characters from the start and end of some text.
        Input:
                text [Text] - Text to split.
                start [Boolean] - Trim whitespace at start.
                end [Boolean] - Trim whitespace at end.
        Returns: [Text] - Trimmed text.
    
    ToPolar(*args, **kwargs)
        Convert a 3D point to plane polar coordinates.
        Input:
                point [Point] - 3D point to transcribe
                system [Plane] - Plane defining polar coordinate space
        Returns:
                phi [Number] - Planar angle in radians (counter-clockwise starting at the plane X-axis)
                theta [Number] - Vertical angle in radians
                radius [Number] - Distance from system origin to point
    
    Torsion(*args, **kwargs)
        Evaluate the torsion of a curve at a specified parameter.
        Input:
                curve [Curve] - Curve to evaluate
                parameter [Number] - Parameter on curve domain to evaluate
        Returns:
                point [Point] - Point on curve at {t}
                torsion [Number] - Curvature torsion at {t}
    
    Transform(*args, **kwargs)
        Transform an object.
        Input:
                geometry [Geometry] - Base geometry
                transform [Transform] - Transformation
        Returns: [Geometry] - Transformed geometry
    
    TransposeMatrix(*args, **kwargs)
        Transpose a matrix (swap rows and columns)
        Input:
                matrix [Matrix] - A newly created matrix
        Returns: [Matrix] - Transposed matrix
    
    TransposeSurface(*args, **kwargs)
        Transpose surface parameterization (swap U and V)
        Input:
                surface [Surface] - Surface to transpose
        Returns:
                surface [Surface] - Transposed surface
                u [Domain] - {u} domain of transposed surface
                v [Domain] - {v} domain of transposed surface
    
    TreeBranch(*args, **kwargs)
        Retrieve a specific branch from a data tree.
        Input:
                tree [Generic Data] - Data Tree
                path [Path] - Data tree branch path
        Returns: [Generic Data] - Branch at {P}
    
    TreeItem(*args, **kwargs)
        Retrieve a specific item from a data tree.
        Input:
                tree [Generic Data] - Data Tree
                path [Path] - Data tree branch path
                index [Integer] - Item index
                wrap [Boolean] - Wrap index to list bounds
        Returns: [Generic Data] - Item at {P:i'}
    
    TreeStatistics(*args, **kwargs)
        Get some statistics regarding a data tree.
        Input:
                tree [Generic Data] - Data Tree to analyze
        Returns:
                paths [Path] - All the paths of the tree
                length [Integer] - The length of each branch in the tree
                count [Integer] - Number of paths and branches in the tree
    
    TriRemesh(*args, **kwargs)
        Convert a Brep or Mesh into a mesh of near equilateral triangles
        Input:
                geometry [Geometry] - Initial Mesh, Brep, Surface or Curve to remesh
                target (in, optional) [Mesh] - Optional different target mesh to pull to. If none given, initial mesh is used.
                sharp (in, optional) [Boolean] - Preserve sharp features
                features (in, optional) [Generic Data] - Optional additional curves or points to preserve
                length (in, optional) [Number] - Target edge length
                iterations [Integer] - Number of remeshing steps to perform
        Returns:
                triangulation [Mesh] - Remeshed result
                dual [Mesh] - Dual Ngon mesh
                creases [Line] - Edge lines of sharp features
    
    TriangleMapping(*args, **kwargs)
        Transform geometry from one triangle into another.
        Input:
                geometry (in, optional) [Geometry] - Base geometry
                source [Curve] - Triangle to map from
                target [Curve] - Triangle to map into
        Returns:
                geometry [Geometry] - Mapped geometry
                transform [Transform] - Transformation data
    
    TriangleTrigonometry(*args, **kwargs)
        Generic triangle trigonometry
        Input:
                alpha (in, optional) [Number] - Optional alpha angle
                beta (in, optional) [Number] - Optional beta angle
                gamma (in, optional) [Number] - Optional gamma angle
                a_length (in, optional) [Number] - Optional length of A edge (opposite alpha)
                b_length (in, optional) [Number] - Optional length of B edge (opposite beta)
                c_length (in, optional) [Number] - Optional length of C edge (opposite gamma)
        Returns:
                alpha [Number] - Computed alpha angle
                beta [Number] - Computed beta angle
                gamma [Number] - Computed gamma angle
                a_length [Number] - Computed length of A edge
                b_length [Number] - Computed length of B edge
                c_length [Number] - Computed length of C edge
    
    Triangular(*args, **kwargs)
        2D grid with triangular cells
        Input:
                plane [Plane] - Base plane for grid
                size [Number] - Size of triangle edges
                extent_x [Integer] - Number of grid cells in base plane x directions
                extent_y [Integer] - Number of grid cells in base plane y directions
        Returns:
                cells [Curve] - Grid cell outlines
                points [Point] - Points at grid centers
    
    Triangulate(*args, **kwargs)
        Triangulate all quads in a mesh
        Input:
                mesh [Mesh] - Mesh to triangulate
        Returns:
                mesh [Mesh] - Mesh with only triangle faces
                count [Integer] - Number of quads that were triangulated
    
    TrimSolid(*args, **kwargs)
        Cut holes into a shape with a set of solid cutters.
        Input:
                shape [Brep] - Shape to trim
                cutters [Brep] - Trimming shapes
        Returns: [Brep] - Shape with holes
    
    TrimTree(*args, **kwargs)
        Reduce the complexity of a tree by merging the outermost branches.
        Input:
                tree [Generic Data] - Data tree to flatten
                depth [Integer] - Number of outermost branches to merge
        Returns: [Generic Data] - Trimmed data tree
    
    TrimwithBrep(*args, **kwargs)
        Trim a curve with a Brep.
        Input:
                curve [Curve] - Curve to trim
                brep [Brep] - Brep to trim against
        Returns:
                inside [Curve] - Split curves inside the Brep
                outside [Curve] - Split curves outside the Brep
    
    TrimwithBreps(*args, **kwargs)
        Trim a curve with multiple Breps.
        Input:
                curve [Curve] - Curve to trim
                brep [Brep] - Breps to trim against
        Returns:
                inside [Curve] - Split curves on the inside of the trimming Breps
                outside [Curve] - Split curves on the outside of the trimming Breps
    
    TrimwithRegion(*args, **kwargs)
        Trim a curve with a region.
        Input:
                curve [Curve] - Curve to trim
                region [Curve] - Region to trim against
                plane (in, optional) [Plane] - Optional solution plane. If omitted the curve best-fit plane is used.
        Returns:
                inside [Curve] - Split curves inside the region
                outside [Curve] - Split curves outside the region
    
    TrimwithRegions(*args, **kwargs)
        Trim a curve with multiple regions.
        Input:
                curve [Curve] - Curve to trim
                regions [Curve] - Regions to trim against
                plane (in, optional) [Plane] - Optional solution plane. If omitted the curve best-fit plane is used.
        Returns:
                inside [Curve] - Split curves inside the regions
                outside [Curve] - Split curves outside the regions
    
    Truncate(*args, **kwargs)
        Perform truncation of numerical extremes
        Input:
                input [Generic Data] - Input values for truncation
                truncation_factor [Number] - Truncation factor. Must be between 0.0 (no trucation) and 1.0 (full truncation)
        Returns: [Generic Data] - Truncated set
    
    TweenCurve(*args, **kwargs)
        Tween between two curves.
        Input:
                curve_a [Curve] - Curve to tween from.
                curve_b [Curve] - Curve to tween to
                factor [Number] - Tween factor (0.0=Curve A, 1.0=Curve B
        Returns: [Curve] - Resulting tween curve
    
    Twist(*args, **kwargs)
        Deforms objects by twisting them around an axis.
        Input:
                geometry [Geometry] - Base geometry
                axis [Line] - Twist axis
                angle [Number] - Twist angle in radians
                infinite [Boolean] - If true, the deformation is constant throughout the object, even if the axis is shorter than the object.
                rigid [Boolean] - Geometry will not be deformed as it is transformed
        Returns: [Geometry] - Morphed geometry
    
    TwistedBox(*args, **kwargs)
        Create a twisted box from corner points.
        Input:
                corner_a [Point] - First corner (0,0,0)
                corner_b [Point] - Second corner (1,0,0)
                corner_c [Point] - Third corner (1,1,0)
                corner_d [Point] - Fourth corner (0,1,0)
                corner_e [Point] - Fifth corner (0,0,1)
                corner_f [Point] - Sixth corner (1,0,1)
                corner_g [Point] - Seventh corner (1,1,1)
                corner_h [Point] - Last corner (0,1,1)
        Returns: [Twisted Box] - Twisted box connecting all corners
    
    UnflattenTree(*args, **kwargs)
        Unflatten a data tree by moving items back into branches.
        Input:
                tree [Generic Data] - Data tree to unflatten
                guide [Generic Data] - Guide data tree that defines the path layout
        Returns: [Generic Data] - Unflattened data tree
    
    Ungroup(*args, **kwargs)
        Ungroup a geometry set
        Input:
                group [Group] - Group to break up
        Returns: [Geometry] - Geometry inside the set
    
    UnifyMesh(*args, **kwargs)
        Unify the normals of a mesh
        Input:
                mesh [Mesh] - Mesh to unify
        Returns:
                result [Mesh] - Unified mesh
                count [Integer] - Number of faces that were flipped
    
    UnionFilter(*args, **kwargs)
        Combine multiple filters together into a union which returns true if at least one input filter evaluates to true.
        Input:
                filters [Predicate] - A list of filters to union.
        Returns: [Predicate] - A filter that returns true if at least one input filter evalutes to true.
    
    UnitSystem(*args, **kwargs)
        Unit System
        Input:
                unit_system [Unit System] - A unit system
                name (in, optional) [Text] - The unit system name.
                factor (in, optional) [Number] - Unit factor
        Returns:
                unit_system [Unit System] - A unit system
                name [Text] - The unit system name.
                meters [Number] - Meters per unit
    
    UnitVector(*args, **kwargs)
        Unitize vector.
        Input:
                vector [Vector] - Base vector
        Returns: [Vector] - Unit vector
    
    UnitX(*args, **kwargs)
        Unit vector parallel to the world {x} axis.
        Input:
                factor [Number] - Unit multiplication
        Returns: [Vector] - World {x} vector
    
    UnitY(*args, **kwargs)
        Unit vector parallel to the world {y} axis.
        Input:
                factor [Number] - Unit multiplication
        Returns: [Vector] - World {y} vector
    
    UnitZ(*args, **kwargs)
        Unit vector parallel to the world {z} axis.
        Input:
                factor [Number] - Unit multiplication
        Returns: [Vector] - World {z} vector
    
    Unroller(*args, **kwargs)
        Unroll a strip of quads
        Input:
                strip [Mesh] - Mesh to unroll (must be a non looping strip of quads)
                unroll [Number] - How much to unroll (0 keeps original, 1 is completely unrolled
        Returns: [Mesh] - Unrolled Mesh
    
    Untrim(*args, **kwargs)
        Remove all trim curves from a surface.
        Input:
                surface [Surface] - Base surface
        Returns: [Surface] - Untrimmed surface
    
    UnweldMesh(*args, **kwargs)
        Unweld (split) creases in a mesh
        Input:
                mesh [Mesh] - Mesh to unweld
                angle [Number] - Unweld angle
        Returns: [Mesh] - Unwelded mesh
    
    UserText(*args, **kwargs)
        Modify the key/value pair text collection of a model element.
        Input:
                content [Model Content] - Model Content
                keys (in, optional) [Text] - Keys
                values (in, optional) [Generic Data] - Values
        Returns:
                content [Model Content] - Model Content
                keys [Text] - Keys
                values [Text] - Values
    
    VBScript(*args, **kwargs)
        A VB.NET scriptable component
        Input:
                x (in, optional) [Generic Data] - Script Variable x
                y (in, optional) [Generic Data] - Script Variable y
        Returns:
                out [Text] - Print, Reflect and Error streams
                a [Generic Data] - Output parameter A
    
    Vector2Pt(*args, **kwargs)
        Create a vector between two points.
        Input:
                point_a [Point] - Base point
                point_b [Point] - Tip point
                unitize [Boolean] - Unitize output
        Returns:
                vector [Vector] - Vector
                length [Number] - Vector length
    
    VectorDisplay(*args, **kwargs)
        Preview vectors in the viewport
        Input:
                anchor (in, optional) [Point] - Anchor point for preview vector
                vector (in, optional) [Vector] - Vector to preview
    
    VectorDisplayEx(*args, **kwargs)
        Preview vectors in the viewport
        Input:
                point (in, optional) [Point] - Start point of vector
                vector (in, optional) [Vector] - Vector to display
                colour (in, optional) [Colour] - Colour of vector
                width (in, optional) [Integer] - Width of vector lines
    
    VectorForce(*args, **kwargs)
        Create a field due to a vector force
        Input:
                line [Line] - Geometry of line segment charge
                bounds (in, optional) [Box] - Optional bounds for the field
        Returns: [Field] - Field due to vector force
    
    VectorLength(*args, **kwargs)
        Compute the length (amplitude) of a vector.
        Input:
                vector [Vector] - Vector to measure
        Returns: [Number] - Vector length
    
    VectorXYZ(*args, **kwargs)
        Create a vector from {xyz} components.
        Input:
                x_component [Number] - Vector {x} component
                y_component [Number] - Vector {y} component
                z_component [Number] - Vector {z} component
        Returns:
                vector [Vector] - Vector construct
                length [Number] - Vector length
    
    VertexLoads(*args, **kwargs)
        Apply equal vertical loads to all vertices of a mesh
        Input:
                mesh [Mesh] - Mesh to apply loads to
                strength [Number] - Strength
        Returns: [Generic Data] - out
    
    VertexNeighbours(*args, **kwargs)
        Returns the positions of the vertices connected the given vertex by an edge
        Input:
                mesh [Mesh] - Mesh
                vertex_number [Integer] - The integer of the central vertex to get neighbours for
        Returns:
                vertex [Point] - The position of the central vertex
                neighbours [Point] - Positions of neighbouring vertices
                normal [Vector] - The mesh normal at the central vertex
    
    VisibilityAttributes(*args, **kwargs)
        Object visibility attributes
        Input:
                visibility (in, optional) [Visibility Attributes] - Visibility
                hidden (in, optional) [Boolean] - Hidden
                locked (in, optional) [Boolean] - Locked
        Returns:
                visibility [Visibility Attributes] - Visibility
                hidden [Boolean] - Hidden
                locked [Boolean] - Locked
    
    Volume(*args, **kwargs)
        Solve volume properties for closed breps and meshes.
        Input:
                geometry [Geometry] - Closed brep or mesh for volume computation
        Returns:
                volume [Number] - Volume of geometry
                centroid [Point] - Volume centroid of geometry
    
    VolumeMoments(*args, **kwargs)
        Solve volume properties for closed breps and meshes.
        Input:
                geometry [Geometry] - Closed brep or mesh for volume computation
        Returns:
                volume [Number] - Volume of geometry
                centroid [Point] - Volume centroid of geometry
                inertia [Vector] - Moments of inertia around the centroid
                secondary [Vector] - Secondary moments of inertia around the centroid
                gyration [Vector] - Radii of gyration
    
    Voronoi(*args, **kwargs)
        Planar voronoi diagram for a collection of points
        Input:
                points [Point] - Points for Voronoi diagram
                radius (in, optional) [Number] - Optional cell radius
                boundary (in, optional) [Rectangle] - Optional containment boundary for diagram.
                plane (in, optional) [Plane] - Optional base plane. If no plane is provided, then the best-fit plane will be used.
        Returns: [Curve] - Cells of the voronoi diagram.
    
    Voronoi3D(*args, **kwargs)
        Volumetric voronoi diagram for a collection of points
        Input:
                points [Point] - Points for Voronoi diagram
                box (in, optional) [Box] - Optional diagram boundary
        Returns:
                cells [Brep] - Cells of the 3D Voronoi diagram
                boundary [Boolean] - List of boolean values indicating for each cell whether it is part of the original boundary
    
    VoronoiCell(*args, **kwargs)
        Compute a single 3D Voronoi cell
        Input:
                point [Point] - Seed point for voronoi cell
                neighbours [Point] - Neighbour points
                box (in, optional) [Box] - Optional cell boundary
        Returns: [Brep] - Voronoi 3D cell
    
    VoronoiGroups(*args, **kwargs)
        Compute a custom set of nested voronoi diagrams.
        Input:
                boundary [Rectangle] - Diagram boundary
                generation_1 (in, optional) [Point] - Points in generation 1
                generation_2 (in, optional) [Point] - Points in generation 2
        Returns:
                diagram_1 [Curve] - Voronoi diagram for generation 1
                diagram_2 [Curve] - Voronoi diagram for generation 2
    
    WarpWeft(*args, **kwargs)
        Separate the edges of a mesh into 2 lists according to Warp and Weft direction
        Input:
                mesh [Mesh] - Input Mesh
        Returns:
                warp [Line] - Lines in first direction
                weft [Line] - Lines in first direction
                nakeda [Boolean] - List of booleans for whether each line in A lies on the mesh boundary
                nakedb [Boolean] - List of booleans for whether each line in B lies on the mesh boundary
    
    Weave(*args, **kwargs)
        Weave a set of input data using a custom pattern.
        Input:
                pattern [Integer] - Weave pattern of input indices
                stream_0 [Generic Data] - Input stream  0
                stream_1 [Generic Data] - Input stream  1
        Returns: [Generic Data] - Weave result
    
    WeightedAverage(*args, **kwargs)
        Solve the arithmetic weighted average for a set of items
        Input:
                input [Generic Data] - Input values for averaging
                weights [Number] - Collection of weights for each value
        Returns: [Generic Data] - Arithmetic mean (average) of all input values
    
    WeldMesh(*args, **kwargs)
        Weld (merge) creases in a mesh
        Input:
                mesh [Mesh] - Mesh to weld
                angle [Number] - Weld angle
        Returns: [Mesh] - Welded mesh
    
    Wind(*args, **kwargs)
        Wind
        Input:
                mesh [Mesh] - Mesh to apply wind to
                windvector [Vector] - Direction and strength of wind
        Returns: [Generic Data] - out
    
    XYPlane(*args, **kwargs)
        World XY plane.
        Input:
                origin [Point] - Origin of plane
        Returns: [Plane] - World XY plane
    
    XZPlane(*args, **kwargs)
        World XZ plane.
        Input:
                origin [Point] - Origin of plane
        Returns: [Plane] - World XZ plane
    
    YZPlane(*args, **kwargs)
        World YZ plane.
        Input:
                origin [Point] - Origin of plane
        Returns: [Plane] - World YZ plane
    
    ZombieSolver(*args, **kwargs)
        A version of the solver component which keeps all iterations internal, and outputs the final result
        Input:
                goalobjects (in, optional) [Generic Data] - GoalObjects
                threshold [Number] - Stop when average movement is less than this (default is 1e-10)
                tolerance [Number] - Points closer than this distance will be combined into a single particle
                maxiterations [Integer] - If the energy threshold has not been reached, it will stop after this many iterations
        Returns:
                i [Integer] - Iterations
                v [Point] - V
                o [Generic Data] - GoalFunction Outputs
    
    ZoomExtents(*args, **kwargs)
        Zoom view to show all objects
        Input:
                view [View] - The view to adjust
                extents [Geometry] - Geometry to be included in the zoom extents
                border (in, optional) [Number] - Border factor. If border > 1.0, then the frustum in enlarged by this factor to provide a border around the view. A factor of 1.1 works well for parallel projections; 0.0 is suggested for perspective projections.
        Returns:
                view [View] - The view to adjust
                extents [Geometry] - Geometry to be included in the zoom extents
                border [Number] - Border factor. If border > 1.0, then the frustum in enlarged by this factor to provide a border around the view. A factor of 1.1 works well for parallel projections; 0.0 is suggested for perspective projections.
    
    __make_function__(info, inputnames, outputnames, keep_tree)
    
    interconnectPoints(*args, **kwargs)
        Draws one line between every pair of points in a list
        Input:
                pts [Point] - list of points to interconnect
        Returns: [Curve] - interconnection lines
    
    removeDuplicateLines(*args, **kwargs)
        Removes similar lines from a list.
        Input:
                lines [Line] - list of lines to clean
                tolerance (in, optional) [Number] - lines with start/endpoints closer than this distance will be combined
        Returns: [Line] - list of unique lines
    
    removeDuplicatePts(*args, **kwargs)
        Removes similar points from a list
        Input:
                points [Point] - list of points to clean
                tolerance (in, optional) [Number] - If any points are less than this distance apart along all axes x,y and z, they will be combined
        Returns: [Point] - list of unique points
    
    x4PointSurface(*args, **kwargs)
        Create a surface connecting three or four corner points.
        Input:
                corner_a [Point] - First corner
                corner_b [Point] - Second corner
                corner_c [Point] - Third corner
                corner_d (in, optional) [Point] - Optional fourth corner
        Returns: [Surface] - Resulting surface

DATA
    ClimateStudioGH = <ghpythonlib.components.namespace_object object>
        Third-party add-on: ClimateStudioGH
    
    ClipperComponents = <ghpythonlib.components.namespace_object object>
        Third-party add-on: ClipperComponents
    
    DecodingSpacesAssembly = <ghpythonlib.components.namespace_object obje...
        Third-party add-on: DecodingSpacesAssembly
    
    Kangaroo2Component = <ghpythonlib.components.namespace_object object>
        Third-party add-on: Kangaroo2Component
    
    Ladybug = <ghpythonlib.components.namespace_object object>
        Third-party add-on: Ladybug
    
    Pufferfish = <ghpythonlib.components.namespace_object object>
        Third-party add-on: Pufferfish
    
    System = <module 'System'>
        Namespace containing types from the following assemblies:
        
        - System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e
        - System.ComponentModel, Version=7.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
        - System.Console, Version=7.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
        - System.Private.Uri, Version=7.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
        - System.ComponentModel.TypeConverter, Version=7.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
        - System.Configuration.ConfigurationManager, Version=7.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51
        - System.Memory, Version=7.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51
    
    gh = <module 'Grasshopper'>
        Namespace containing types from the following assemblies:
        
        - Grasshopper, Version=8.19.25132.1001, Culture=neutral, PublicKeyToken=dda4f5ec2cd80803
    
    otepad = <ghpythonlib.components.namespace_object object>
        Third-party add-on: otepad
    
    topoBuilding = <ghpythonlib.components.namespace_object object>
        Third-party add-on: topoBuilding
    
    topoContour = <ghpythonlib.components.namespace_object object>
        Third-party add-on: topoContour
    
    topoGraphy = <ghpythonlib.components.namespace_object object>
        Third-party add-on: topoGraphy
    
    topoROK = <ghpythonlib.components.namespace_object object>
        Third-party add-on: topoROK
    
    topoRiver = <ghpythonlib.components.namespace_object object>
        Third-party add-on: topoRiver
    
    topoSmooth = <ghpythonlib.components.namespace_object object>
        Third-party add-on: topoSmooth
    
    topoStreet = <ghpythonlib.components.namespace_object object>
        Third-party add-on: topoStreet
    
    trees = <ghpythonlib.components.namespace_object object>
        Functions in this module accept and always return datatrees.

FILE
    c:\users\bsh96\.rhinocode\py39-rh8\site-rhinoghpython\ghpythonlib\components.py



