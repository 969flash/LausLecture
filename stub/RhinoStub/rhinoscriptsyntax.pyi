# rhinoscriptsyntax stub file for type hints and autocomplete
from typing import List, Tuple, Optional, Union, Any, Sequence
import Rhino.Geometry as rg

# Points
def AddPoint(point: Union[List[float], Tuple[float, float, float], rg.Point3d], 
             group_name: Optional[str] = None) -> str: ...

def AddPoints(points: List[Union[List[float], Tuple[float, float, float], rg.Point3d]], 
              group_name: Optional[str] = None) -> List[str]: ...

def PointCoordinates(point_id: str, point: Optional[Union[List[float], Tuple[float, float, float], rg.Point3d]] = None) -> Union[List[float], bool]: ...

def IsPoint(object_id: str) -> bool: ...

def MovePoint(object_id: str, translation: Union[List[float], Tuple[float, float, float], rg.Vector3d]) -> bool: ...

# Lines
def AddLine(start: Union[List[float], Tuple[float, float, float], rg.Point3d], 
            end: Union[List[float], Tuple[float, float, float], rg.Point3d]) -> str: ...

def AddPolyline(points: List[Union[List[float], Tuple[float, float, float], rg.Point3d]], 
                replace_id: Optional[str] = None) -> str: ...

def CurveStartPoint(object_id: str, segment_index: int = -1, point: Optional[Union[List[float], Tuple[float, float, float], rg.Point3d]] = None) -> Union[List[float], bool]: ...

def CurveEndPoint(object_id: str, segment_index: int = -1, point: Optional[Union[List[float], Tuple[float, float, float], rg.Point3d]] = None) -> Union[List[float], bool]: ...

def CurveLength(object_id: str, segment_index: int = -1, sub_domain: Optional[List[float]] = None) -> float: ...

def IsCurve(object_id: str) -> bool: ...

def IsLine(object_id: str) -> bool: ...

def IsPolyline(object_id: str) -> bool: ...

# Circles and Arcs
def AddCircle(plane_or_center: Union[rg.Plane, List[float], Tuple[float, float, float], rg.Point3d], 
              radius: float) -> str: ...

def AddArc(plane: rg.Plane, radius: float, angle_degrees: float) -> str: ...

def AddArc3Pt(start: Union[List[float], Tuple[float, float, float], rg.Point3d], 
               end: Union[List[float], Tuple[float, float, float], rg.Point3d], 
               point_on_arc: Union[List[float], Tuple[float, float, float], rg.Point3d]) -> str: ...

def IsCircle(object_id: str) -> bool: ...

def IsArc(object_id: str) -> bool: ...

# Surfaces
def AddSrfPt(points: List[Union[List[float], Tuple[float, float, float], rg.Point3d]]) -> str: ...

def AddPlanarSrf(object_ids: List[str]) -> str: ...

def IsSurface(object_id: str) -> bool: ...

def SurfaceArea(object_id: str) -> Tuple[float, float]: ...

def SurfaceVolume(object_id: str) -> Tuple[float, float, float]: ...

# Polysurfaces and Breps
def IsBrep(object_id: str) -> bool: ...

def IsPolysurface(object_id: str, types: int = 0) -> bool: ...

def BrepClosestPoint(object_id: str, point: Union[List[float], Tuple[float, float, float], rg.Point3d]) -> Tuple[List[float], List[int], float]: ...

# Meshes
def AddMesh(vertices: List[Union[List[float], Tuple[float, float, float], rg.Point3d]], 
            faces: List[List[int]], 
            vertex_normals: Optional[List[List[float]]] = None, 
            texture_coordinates: Optional[List[List[float]]] = None, 
            vertex_colors: Optional[List[List[int]]] = None) -> str: ...

def IsMesh(object_id: str) -> bool: ...

def MeshVertices(object_id: str) -> List[Tuple[float, float, float]]: ...

def MeshFaces(object_id: str, face_type: bool = True) -> List[Tuple[int, ...]]: ...

# Object Selection
def GetObject(message: Optional[str] = None, filter: int = 0, preselect: bool = False, select: bool = False, custom_filter: Optional[Any] = None, subobjects: bool = False) -> str: ...

def GetObjects(message: Optional[str] = None, filter: int = 0, group: bool = True, preselect: bool = True, select: bool = False, objects: Optional[List[str]] = None, minimum_count: int = 1, maximum_count: int = 0, custom_filter: Optional[Any] = None) -> List[str]: ...

def GetPoint(message: Optional[str] = None, base_point: Optional[Union[List[float], Tuple[float, float, float], rg.Point3d]] = None, distance: Optional[float] = None, in_plane: bool = False) -> List[float]: ...

def GetPoints(draw_lines: bool = False, in_plane: bool = False, message1: Optional[str] = None, message2: Optional[str] = None, max_points: Optional[int] = None, base_point: Optional[Union[List[float], Tuple[float, float, float], rg.Point3d]] = None) -> List[List[float]]: ...

# Object Properties
def ObjectName(object_id: str, name: Optional[str] = None) -> Union[str, bool]: ...

def ObjectLayer(object_id: str, layer: Optional[str] = None) -> Union[str, bool]: ...

def ObjectColor(object_id: str, color: Optional[Union[int, Tuple[int, int, int]]] = None) -> Union[int, bool]: ...

def IsObjectHidden(object_id: str) -> bool: ...

def IsObjectLocked(object_id: str) -> bool: ...

def IsObjectSelected(object_id: str) -> bool: ...

def HideObject(object_id: str) -> bool: ...

def ShowObject(object_id: str) -> bool: ...

def LockObject(object_id: str) -> bool: ...

def UnlockObject(object_id: str) -> bool: ...

def SelectObject(object_id: str) -> bool: ...

def UnselectObject(object_id: str) -> bool: ...

# Transformations
def MoveObject(object_id: str, translation: Union[List[float], Tuple[float, float, float], rg.Vector3d]) -> bool: ...

def MoveObjects(object_ids: List[str], translation: Union[List[float], Tuple[float, float, float], rg.Vector3d]) -> int: ...

def RotateObject(object_id: str, center_point: Union[List[float], Tuple[float, float, float], rg.Point3d], angle_degrees: float, axis: Optional[Union[List[float], Tuple[float, float, float], rg.Vector3d]] = None, copy: bool = False) -> Union[str, bool]: ...

def RotateObjects(object_ids: List[str], center_point: Union[List[float], Tuple[float, float, float], rg.Point3d], angle_degrees: float, axis: Optional[Union[List[float], Tuple[float, float, float], rg.Vector3d]] = None, copy: bool = False) -> Union[List[str], int]: ...

def ScaleObject(object_id: str, origin: Union[List[float], Tuple[float, float, float], rg.Point3d], scale: Union[float, List[float], Tuple[float, float, float]], copy: bool = False) -> Union[str, bool]: ...

def ScaleObjects(object_ids: List[str], origin: Union[List[float], Tuple[float, float, float], rg.Point3d], scale: Union[float, List[float], Tuple[float, float, float]], copy: bool = False) -> Union[List[str], int]: ...

def CopyObject(object_id: str, translation: Optional[Union[List[float], Tuple[float, float, float], rg.Vector3d]] = None) -> str: ...

def CopyObjects(object_ids: List[str], translation: Optional[Union[List[float], Tuple[float, float, float], rg.Vector3d]] = None) -> List[str]: ...

# Document
def EnableRedraw(enable: bool = True) -> bool: ...

def Redraw() -> None: ...

def Command(command_string: str, echo: bool = True) -> bool: ...

def CurrentLayer(layer: Optional[str] = None) -> str: ...

def AddLayer(name: Optional[str] = None, color: Optional[Union[int, Tuple[int, int, int]]] = None, visible: bool = True, locked: bool = False, parent: Optional[str] = None) -> str: ...

def LayerNames(sort: bool = False, visible: bool = False, parent_layer: Optional[str] = None) -> List[str]: ...

def DeleteLayer(layer: str) -> bool: ...

def IsLayer(layer: str) -> bool: ...

def IsLayerEmpty(layer: str) -> bool: ...

def IsLayerLocked(layer: str) -> bool: ...

def IsLayerOn(layer: str) -> bool: ...

def IsLayerVisible(layer: str) -> bool: ...

def LayerColor(layer: str, color: Optional[Union[int, Tuple[int, int, int]]] = None) -> Union[int, bool]: ...

# Utility
def Distance(point1: Union[List[float], Tuple[float, float, float], rg.Point3d], 
             point2: Union[List[float], Tuple[float, float, float], rg.Point3d]) -> float: ...

def VectorAdd(vector1: Union[List[float], Tuple[float, float, float], rg.Vector3d], 
              vector2: Union[List[float], Tuple[float, float, float], rg.Vector3d]) -> List[float]: ...

def VectorSubtract(vector1: Union[List[float], Tuple[float, float, float], rg.Vector3d], 
                   vector2: Union[List[float], Tuple[float, float, float], rg.Vector3d]) -> List[float]: ...

def VectorScale(vector: Union[List[float], Tuple[float, float, float], rg.Vector3d], 
                scale: float) -> List[float]: ...

def VectorLength(vector: Union[List[float], Tuple[float, float, float], rg.Vector3d]) -> float: ...

def VectorUnitize(vector: Union[List[float], Tuple[float, float, float], rg.Vector3d]) -> List[float]: ...

def VectorDotProduct(vector1: Union[List[float], Tuple[float, float, float], rg.Vector3d], 
                     vector2: Union[List[float], Tuple[float, float, float], rg.Vector3d]) -> float: ...

def VectorCrossProduct(vector1: Union[List[float], Tuple[float, float, float], rg.Vector3d], 
                       vector2: Union[List[float], Tuple[float, float, float], rg.Vector3d]) -> List[float]: ...

def coerce3dpoint(point: Any) -> Optional[rg.Point3d]: ...

def coerce3dvector(vector: Any) -> Optional[rg.Vector3d]: ...

def coerceplane(plane: Any) -> Optional[rg.Plane]: ...

def coercecurve(curve_id: Any) -> Optional[rg.Curve]: ...

def coercesurface(surface_id: Any) -> Optional[rg.Surface]: ...

def coercebrep(brep_id: Any) -> Optional[rg.Brep]: ...

def coercemesh(mesh_id: Any) -> Optional[rg.Mesh]: ...

def coercegeometry(object_id: Any) -> Optional[rg.GeometryBase]: ...

# Boolean Operations
def BooleanUnion(object_ids: List[str], delete_input: bool = True) -> List[str]: ...

def BooleanIntersection(object_ids: List[str], delete_input: bool = True) -> List[str]: ...

def BooleanDifference(object_ids: List[str], delete_input: bool = True) -> List[str]: ...

# Offset
def OffsetCurve(object_id: str, direction_point: Union[List[float], Tuple[float, float, float], rg.Point3d], distance: float, normal: Optional[Union[List[float], Tuple[float, float, float], rg.Vector3d]] = None, style: int = 1) -> List[str]: ...

def OffsetSurface(object_id: str, distance: float, tolerance: Optional[float] = None, both_sides: bool = False, create_solid: bool = False) -> str: ...

# Analysis
def CurveClosestPoint(curve_id: str, test_point: Union[List[float], Tuple[float, float, float], rg.Point3d]) -> float: ...

def CurveClosestObject(curve_id: str, object_ids: List[str]) -> Tuple[str, List[float], List[float]]: ...

def SurfaceClosestPoint(surface_id: str, test_point: Union[List[float], Tuple[float, float, float], rg.Point3d]) -> List[float]: ...

# Views
def ViewNames(return_names: bool = True, view_type: int = 0) -> List[str]: ...

def CurrentView(view: Optional[str] = None, return_name: bool = True) -> str: ...

def ViewCameraTarget(view: Optional[str] = None, camera: Optional[Union[List[float], Tuple[float, float, float], rg.Point3d]] = None, target: Optional[Union[List[float], Tuple[float, float, float], rg.Point3d]] = None) -> Tuple[List[float], List[float]]: ...

def ViewCameraLens(view: Optional[str] = None, length: Optional[float] = None) -> float: ...

def ViewCameraUp(view: Optional[str] = None, up_vector: Optional[Union[List[float], Tuple[float, float, float], rg.Vector3d]] = None) -> List[float]: ...

def ViewProjection(view: Optional[str] = None, mode: Optional[int] = None) -> int: ...

def ZoomExtents(view: Optional[str] = None, all: bool = True) -> None: ...

def ZoomSelected(view: Optional[str] = None) -> None: ...

def ZoomBoundingBox(bounding_box: List[Union[List[float], Tuple[float, float, float], rg.Point3d]], view: Optional[str] = None, all: bool = False) -> None: ...

# File I/O
def DocumentPath() -> str: ...

def DocumentName() -> str: ...

def IsDocumentModified() -> bool: ...

def DocumentModified(modified: Optional[bool] = None) -> bool: ...

# Additional geometry creation
def AddEllipse(plane: rg.Plane, x_radius: float, y_radius: float) -> str: ...

def AddRectangle(plane: rg.Plane, width: float, height: float) -> str: ...

def AddBox(corners: List[Union[List[float], Tuple[float, float, float], rg.Point3d]]) -> str: ...

def AddCone(base: Union[rg.Plane, List[float], Tuple[float, float, float], rg.Point3d], height: float, radius: float, cap: bool = True) -> str: ...

def AddCylinder(base: Union[rg.Plane, List[float], Tuple[float, float, float], rg.Point3d], height: float, radius: float, cap: bool = True) -> str: ...

def AddSphere(center_or_plane: Union[rg.Plane, List[float], Tuple[float, float, float], rg.Point3d], radius: float) -> str: ...

def AddTorus(base: Union[rg.Plane, List[float], Tuple[float, float, float], rg.Point3d], major_radius: float, minor_radius: float) -> str: ...

# Text
def AddText(text: str, point_or_plane: Union[rg.Plane, List[float], Tuple[float, float, float], rg.Point3d], height: float = 1.0, font: str = "Arial", font_style: int = 0, justification: int = 0) -> str: ...

def IsText(object_id: str) -> bool: ...

def TextObjectText(object_id: str, text: Optional[str] = None) -> Union[str, bool]: ...

def TextObjectPoint(object_id: str, point: Optional[Union[List[float], Tuple[float, float, float], rg.Point3d]] = None) -> Union[List[float], bool]: ...

def TextObjectHeight(object_id: str, height: Optional[float] = None) -> Union[float, bool]: ...

def TextObjectFont(object_id: str, font: Optional[str] = None) -> Union[str, bool]: ...

# Dimensions
def AddDimStyle(dimstyle_name: str) -> str: ...

def CurrentDimStyle(dimstyle_name: Optional[str] = None) -> str: ...

def DimStyleNames(sort: bool = False) -> List[str]: ...

def IsDimStyle(dimstyle_name: str) -> bool: ...

def AddLinearDimension(start_point: Union[List[float], Tuple[float, float, float], rg.Point3d], end_point: Union[List[float], Tuple[float, float, float], rg.Point3d], dimension_line_point: Union[List[float], Tuple[float, float, float], rg.Point3d]) -> str: ...

def AddAlignedDimension(start_point: Union[List[float], Tuple[float, float, float], rg.Point3d], end_point: Union[List[float], Tuple[float, float, float], rg.Point3d], dimension_line_point: Union[List[float], Tuple[float, float, float], rg.Point3d]) -> str: ...

def IsDimension(object_id: str) -> bool: ...

# Groups
def AddGroup(group_name: Optional[str] = None) -> str: ...

def AddObjectsToGroup(object_ids: List[str], group_name: str) -> int: ...

def RemoveObjectsFromGroup(object_ids: List[str], group_name: str) -> int: ...

def GroupNames(sort: bool = False) -> List[str]: ...

def IsGroup(group_name: str) -> bool: ...

def IsGroupEmpty(group_name: str) -> bool: ...

def DeleteGroup(group_name: str) -> bool: ...

def RenameGroup(old_name: str, new_name: str) -> bool: ...

# Block instances
def InsertBlock(block_name: str, insertion_point: Union[List[float], Tuple[float, float, float], rg.Point3d], scale: Union[float, List[float], Tuple[float, float, float]] = 1.0, angle_degrees: float = 0.0, rotation_normal: Optional[Union[List[float], Tuple[float, float, float], rg.Vector3d]] = None) -> str: ...

def IsBlock(object_id: str) -> bool: ...

def IsBlockInstance(object_id: str) -> bool: ...

def BlockInstanceName(object_id: str) -> str: ...

def BlockInstanceInsertPoint(object_id: str) -> List[float]: ...

def BlockNames(sort: bool = False) -> List[str]: ...

def BlockObjects(block_name: str) -> List[str]: ...

def DeleteBlock(block_name: str) -> bool: ...

def RenameBlock(old_name: str, new_name: str) -> bool: ...

# User Interface
def GetBoolean(message: str, items: List[Tuple[str, bool]], defaults: List[bool]) -> List[bool]: ...

def GetColor(color: Optional[Union[int, Tuple[int, int, int]]] = None) -> Union[int, None]: ...

def GetInteger(message: Optional[str] = None, number: Optional[int] = None, minimum: Optional[int] = None, maximum: Optional[int] = None) -> Union[int, None]: ...

def GetReal(message: Optional[str] = None, number: Optional[float] = None, minimum: Optional[float] = None, maximum: Optional[float] = None) -> Union[float, None]: ...

def GetString(message: Optional[str] = None, defaultString: Optional[str] = None, strings: Optional[List[str]] = None) -> Union[str, None]: ...

def ListBox(items: List[str], message: Optional[str] = None, title: Optional[str] = None) -> Union[str, None]: ...

def MessageBox(message: str, buttons: int = 0, title: Optional[str] = None) -> int: ...

def PopupMenu(items: List[str], modes: Optional[List[int]] = None, point: Optional[Tuple[int, int]] = None, view: Optional[str] = None) -> int: ...

# Plane utilities
def PlaneFromFrame(origin: Union[List[float], Tuple[float, float, float], rg.Point3d], x_axis: Union[List[float], Tuple[float, float, float], rg.Vector3d], y_axis: Union[List[float], Tuple[float, float, float], rg.Vector3d]) -> rg.Plane: ...

def PlaneFromNormal(origin: Union[List[float], Tuple[float, float, float], rg.Point3d], normal: Union[List[float], Tuple[float, float, float], rg.Vector3d]) -> rg.Plane: ...

def PlaneFromPoints(origin: Union[List[float], Tuple[float, float, float], rg.Point3d], x: Union[List[float], Tuple[float, float, float], rg.Point3d], y: Union[List[float], Tuple[float, float, float], rg.Point3d]) -> rg.Plane: ...

def PlanePlaneIntersection(plane1: rg.Plane, plane2: rg.Plane) -> Optional[Tuple[List[float], List[float]]]: ...

def PlaneClosestPoint(plane: rg.Plane, point: Union[List[float], Tuple[float, float, float], rg.Point3d], return_point: bool = True) -> Union[List[float], float]: ...

def DistanceToPlane(plane: rg.Plane, point: Union[List[float], Tuple[float, float, float], rg.Point3d]) -> float: ...

def EvaluatePlane(plane: rg.Plane, parameter: List[float]) -> List[float]: ...

def IntersectPlanes(plane1: rg.Plane, plane2: rg.Plane, plane3: rg.Plane) -> Optional[List[float]]: ...

def MovePlane(plane: rg.Plane, origin: Union[List[float], Tuple[float, float, float], rg.Point3d]) -> rg.Plane: ...

def RotatePlane(plane: rg.Plane, angle_degrees: float, axis: Union[List[float], Tuple[float, float, float], rg.Vector3d]) -> rg.Plane: ...

def WorldXYPlane() -> rg.Plane: ...

def WorldYZPlane() -> rg.Plane: ...

def WorldZXPlane() -> rg.Plane: ...

# Additional utilities
def AllObjects(select: bool = False, visible_only: bool = True, layer: Optional[str] = None, object_type: Optional[int] = None) -> List[str]: ...

def DeleteObject(object_id: str) -> bool: ...

def DeleteObjects(object_ids: List[str]) -> int: ...

def ObjectsByColor(color: Union[int, Tuple[int, int, int]], select: bool = False, include_lights: bool = False) -> List[str]: ...

def ObjectsByGroup(group_name: str, select: bool = False) -> List[str]: ...

def ObjectsByLayer(layer_name: str, select: bool = False) -> List[str]: ...

def ObjectsByName(name: str, select: bool = False, include_lights: bool = False, include_references: bool = False) -> List[str]: ...

def ObjectsByType(object_type: int, select: bool = False, state: int = 0) -> List[str]: ...

def ObjectsByURL(url: str, select: bool = False, include_lights: bool = False) -> List[str]: ...

def SelectedObjects(include_lights: bool = False, include_grips: bool = False, include_references: bool = False) -> List[str]: ...

def UnselectAllObjects() -> int: ...

def LastCreatedObjects(select: bool = False) -> List[str]: ...

def NextObject(object_id: str, select: bool = False, include_lights: bool = False, include_grips: bool = False) -> Optional[str]: ...

def PrevObject(object_id: str, select: bool = False, include_lights: bool = False, include_grips: bool = False) -> Optional[str]: ...

def FirstObject(select: bool = False, include_lights: bool = False, include_grips: bool = False) -> Optional[str]: ...

def LastObject(select: bool = False, include_lights: bool = False, include_grips: bool = False) -> Optional[str]: ...

def ObjectDescription(object_id: str) -> str: ...

def ObjectGripsOn(object_id: str) -> bool: ...

def ObjectGripsSelected(object_id: str) -> bool: ...

def ObjectType(object_id: str) -> int: ...

def IsObjectInGroup(object_id: str, group_name: Optional[str] = None) -> Union[bool, List[str]]: ...

def IsObjectSolid(object_id: str) -> bool: ...

def IsObjectValid(object_id: str) -> bool: ...

# Curve operations
def ClosedCurveOrientation(curve_id: str, direction: Optional[Union[List[float], Tuple[float, float, float], rg.Vector3d]] = None) -> int: ...

def CurveAreaCentroid(curve_id: str) -> Optional[Tuple[List[float], List[float]]]: ...

def CurveArcLengthPoint(curve_id: str, length: float, from_start: bool = True) -> Optional[List[float]]: ...

def CurveBooleanDifference(curve_id_0: str, curve_id_1: str) -> List[str]: ...

def CurveBooleanIntersection(curve_id_0: str, curve_id_1: str) -> List[str]: ...

def CurveBooleanUnion(curve_ids: List[str]) -> List[str]: ...

def CurveBrepIntersect(curve_id: str, brep_id: str, tolerance: Optional[float] = None) -> List[str]: ...

def CurveContainment(curve_id: str, test_curves: List[str], plane: Optional[rg.Plane] = None, tolerance: Optional[float] = None) -> List[int]: ...

def CurveCurvature(curve_id: str, parameter: float) -> Optional[Tuple[List[float], List[float], float]]: ...

def CurveCurveIntersection(curve_id_0: str, curve_id_1: Optional[str] = None, tolerance: Optional[float] = None) -> Optional[List[Tuple]]: ...

def CurveDegree(curve_id: str) -> int: ...

def CurveDim(curve_id: str) -> int: ...

def CurveDiscontinuity(curve_id: str, style: int) -> List[float]: ...

def CurveDomain(curve_id: str) -> List[float]: ...

def CurveEditPoints(curve_id: str, return_parameters: bool = False, segment_index: int = -1) -> Union[List[List[float]], Tuple[List[List[float]], List[float]]]: ...

def CurveEndPoint(curve_id: str, segment_index: int = -1, point: Optional[Union[List[float], Tuple[float, float, float], rg.Point3d]] = None) -> Union[List[float], bool]: ...

def CurveEvaluate(curve_id: str, parameter: float, derivative_count: int) -> List[List[float]]: ...

def CurveFilletPoints(curve_id_0: str, curve_id_1: str, radius: float = 1.0, base_point_0: Optional[Union[List[float], Tuple[float, float, float], rg.Point3d]] = None, base_point_1: Optional[Union[List[float], Tuple[float, float, float], rg.Point3d]] = None) -> Optional[List[List[float]]]: ...

def CurveFrame(curve_id: str, parameter: float) -> Optional[List[List[float]]]: ...

def CurveKnotCount(curve_id: str) -> int: ...

def CurveKnots(curve_id: str) -> List[float]: ...

def CurveLength(curve_id: str, segment_index: int = -1, sub_domain: Optional[List[float]] = None) -> float: ...

def CurveMidPoint(curve_id: str) -> List[float]: ...

def CurveNormal(curve_id: str) -> Optional[List[float]]: ...

def CurveParameter(curve_id: str, point: Union[List[float], Tuple[float, float, float], rg.Point3d]) -> float: ...

def CurvePointCount(curve_id: str, segment_index: int = -1) -> int: ...

def CurvePoints(curve_id: str, segment_index: int = -1) -> List[List[float]]: ...

def CurveRadius(curve_id: str, point: Union[List[float], Tuple[float, float, float], rg.Point3d]) -> Optional[Tuple[float, List[float]]]: ...

def CurveSeam(curve_id: str, parameter: float) -> bool: ...

def CurveStartPoint(curve_id: str, segment_index: int = -1, point: Optional[Union[List[float], Tuple[float, float, float], rg.Point3d]] = None) -> Union[List[float], bool]: ...

def CurveSurfaceIntersection(curve_id: str, surface_id: str, tolerance: Optional[float] = None, angle_tolerance: Optional[float] = None) -> Optional[List[Tuple]]: ...

def CurveTangent(curve_id: str, parameter: float, segment_index: int = -1) -> List[float]: ...

def CurveWeights(curve_id: str, segment_index: int = -1) -> List[float]: ...

def DivideCurve(curve_id: str, segments: int, create_points: bool = False, return_points: bool = True) -> Union[List[List[float]], List[str]]: ...

def DivideCurveEquidistant(curve_id: str, distance: float, create_points: bool = False, return_points: bool = True) -> Union[List[List[float]], List[str]]: ...

def DivideCurveLength(curve_id: str, length: float, create_points: bool = False, return_points: bool = True) -> Union[List[List[float]], List[str]]: ...

def EvaluateCurve(curve_id: str, parameter: float) -> List[float]: ...

def ExplodeCurves(curve_ids: List[str], delete_input: bool = False) -> List[str]: ...

def ExtendCurve(curve_id: str, extension_type: int, side: int, boundary_object_ids: List[str]) -> Union[str, bool]: ...

def ExtendCurveLength(curve_id: str, extension_type: int, side: int, length: float) -> Union[str, bool]: ...

def ExtendCurvePoint(curve_id: str, side: int, point: Union[List[float], Tuple[float, float, float], rg.Point3d]) -> Union[str, bool]: ...

def FairCurve(curve_id: str, tolerance: float = 1.0) -> bool: ...

def FitCurve(curve_id: str, degree: int = 3, tolerance: float = -1, angle_tolerance: float = -1) -> Union[str, bool]: ...

def InsertCurveKnot(curve_id: str, parameter: float, symmetrical: bool = False) -> bool: ...

def IsCurveClosed(curve_id: str) -> bool: ...

def IsCurveClosable(curve_id: str, tolerance: Optional[float] = None) -> bool: ...

def IsCurveInPlane(curve_id: str, plane: Optional[rg.Plane] = None) -> bool: ...

def IsCurveLinear(curve_id: str) -> bool: ...

def IsCurvePeriodic(curve_id: str) -> bool: ...

def IsCurvePlanar(curve_id: str) -> bool: ...

def IsCurveRational(curve_id: str) -> bool: ...

def IsPointOnCurve(curve_id: str, point: Union[List[float], Tuple[float, float, float], rg.Point3d]) -> bool: ...

def JoinCurves(object_ids: List[str], delete_input: bool = False, tolerance: Optional[float] = None) -> List[str]: ...

def MakeCurveNonPeriodic(curve_id: str, delete_input: bool = False) -> Union[str, bool]: ...

def OffsetCurve(curve_id: str, direction_point: Union[List[float], Tuple[float, float, float], rg.Point3d], distance: float, normal: Optional[Union[List[float], Tuple[float, float, float], rg.Vector3d]] = None, style: int = 1) -> List[str]: ...

def OffsetCurveOnSurface(curve_id: str, surface_id: str, distance: float) -> List[str]: ...

def PolylineVertices(object_id: str, segment_index: int = -1) -> List[List[float]]: ...

def ProjectCurveToMesh(curve_ids: List[str], mesh_ids: List[str], direction: Union[List[float], Tuple[float, float, float], rg.Vector3d]) -> List[str]: ...

def ProjectCurveToSurface(curve_ids: List[str], surface_ids: List[str], direction: Union[List[float], Tuple[float, float, float], rg.Vector3d]) -> List[str]: ...

def PullCurve(surface_id: str, curve_id: str, delete_input: bool = False) -> List[str]: ...

def RebuildCurve(curve_id: str, degree: int = 3, point_count: int = 10) -> bool: ...

def RemoveCurveKnot(curve_id: str, parameter: float) -> bool: ...

def ReverseCurve(curve_id: str) -> bool: ...

def SimplifyCurve(curve_id: str, flags: int = 0) -> bool: ...

def SplitCurve(curve_id: str, parameters: Union[float, List[float]], delete_input: bool = True) -> List[str]: ...

def TrimCurve(curve_id: str, interval: List[float], delete_input: bool = True) -> Union[str, bool]: ...

# Additional surface operations
def AddEdgeSrf(curve_ids: List[str]) -> str: ...

def AddLoftSrf(curve_ids: List[str], start_pt: Optional[Union[List[float], Tuple[float, float, float], rg.Point3d]] = None, end_pt: Optional[Union[List[float], Tuple[float, float, float], rg.Point3d]] = None, loft_type: int = 0, simplify_method: int = 0, value: int = 0, closed: bool = False) -> List[str]: ...

def AddNurbsSurface(point_count: List[int], points: List[List[float]], knots_u: List[float], knots_v: List[float], degree: List[int], weights: Optional[List[List[float]]] = None) -> str: ...

def AddPatch(object_ids: List[str], u_spans: int = 10, v_spans: int = 10, tolerance: Optional[float] = None, trim: bool = True) -> str: ...

def AddPlanarSrf(object_ids: List[str]) -> str: ...

def AddRevSrf(curve_id: str, axis: List[Union[List[float], Tuple[float, float, float], rg.Point3d]], start_angle: float = 0.0, end_angle: float = 360.0) -> str: ...

def AddRailRevSrf(profile: str, rail: str, axis: List[Union[List[float], Tuple[float, float, float], rg.Point3d]]) -> str: ...

def AddSweep1(rail: str, shapes: List[str], closed: bool = False, miter_type: int = 0, simplify: int = 0, simplify_arg: Optional[float] = None) -> List[str]: ...

def AddSweep2(rails: List[str], shapes: List[str], closed: bool = False, simple_sweep: bool = False, maintain_height: bool = False, simplify: int = 0, simplify_arg: Optional[float] = None) -> List[str]: ...

def BrepFaces(brep_id: str, return_faces: bool = True) -> Union[List[str], int]: ...

def CapPlanarHoles(surface_id: str) -> bool: ...

def DuplicateEdgeCurves(object_id: str, select: bool = False) -> List[str]: ...

def DuplicateSurfaceBorder(surface_id: str, type: int = 0) -> List[str]: ...

def ExtractIsoCurve(surface_id: str, parameter: List[float], direction: int) -> List[str]: ...

def ExtrudeCurve(curve_id: str, path_id: str) -> str: ...

def ExtrudeCurvePoint(curve_id: str, point: Union[List[float], Tuple[float, float, float], rg.Point3d]) -> str: ...

def ExtrudeCurveStraight(curve_id: str, start_point: Union[List[float], Tuple[float, float, float], rg.Point3d], end_point: Union[List[float], Tuple[float, float, float], rg.Point3d]) -> str: ...

def ExtrudeCurveTapered(curve_id: str, distance: float, direction: Union[List[float], Tuple[float, float, float], rg.Vector3d], base_point: Union[List[float], Tuple[float, float, float], rg.Point3d], angle: float, cornertype: int = 0) -> str: ...

def ExtrudeSurface(surface_id: str, curve_id: str, cap: bool = True) -> str: ...

def FlipSurface(surface_id: str, flip: Optional[bool] = None) -> bool: ...

def IntersectBreps(brep_id_0: str, brep_id_1: str, tolerance: Optional[float] = None) -> List[str]: ...

def IsBrep(object_id: str) -> bool: ...

def IsBrepManifold(object_id: str) -> bool: ...

def IsPointInSurface(surface_id: str, point: Union[List[float], Tuple[float, float, float], rg.Point3d]) -> bool: ...

def IsPointOnSurface(surface_id: str, point: Union[List[float], Tuple[float, float, float], rg.Point3d]) -> bool: ...

def IsPolysurface(object_id: str) -> bool: ...

def IsPolysurfaceClosed(object_id: str) -> bool: ...

def IsSurface(object_id: str) -> bool: ...

def IsSurfaceClosed(surface_id: str, direction: int) -> bool: ...

def IsSurfacePeriodic(surface_id: str, direction: int) -> bool: ...

def IsSurfacePlanar(surface_id: str, tolerance: Optional[float] = None) -> bool: ...

def IsSurfaceRational(surface_id: str) -> bool: ...

def IsSurfaceTrimmed(surface_id: str) -> bool: ...

def JoinSurfaces(object_ids: List[str], delete_input: bool = True) -> Union[str, bool]: ...

def MakeSurfaceNonPeriodic(surface_id: str, direction: int, delete_input: bool = False) -> Union[str, bool]: ...

def OffsetSurface(surface_id: str, distance: float, tolerance: Optional[float] = None, both_sides: bool = False, create_solid: bool = False) -> Union[str, List[str]]: ...

def PullCurveToSurface(surface_id: str, curve_id: str) -> List[str]: ...

def RebuildSurface(surface_id: str, degree: List[int] = [3, 3], point_count: List[int] = [10, 10]) -> bool: ...

def RemoveSurfaceKnot(surface_id: str, direction: int, parameter: float, maintaining: bool = True) -> bool: ...

def ReverseSurface(surface_id: str, direction: int) -> bool: ...

def ShortPath(surface_id: str, start_point: Union[List[float], Tuple[float, float, float], rg.Point3d], end_point: Union[List[float], Tuple[float, float, float], rg.Point3d]) -> str: ...

def ShrinkTrimmedSurface(surface_id: str) -> bool: ...

def SplitBrep(brep_id: str, cutter_ids: List[str], delete_input: bool = True) -> List[str]: ...

def SurfaceArea(surface_id: str) -> List[float]: ...

def SurfaceAreaCentroid(surface_id: str) -> Optional[Tuple[List[float], List[float]]]: ...

def SurfaceAreaMoments(surface_id: str) -> Optional[Tuple[List[float], List[float], List[List[float]], List[List[float]]]]: ...

def SurfaceClosestPoint(surface_id: str, test_point: Union[List[float], Tuple[float, float, float], rg.Point3d]) -> List[float]: ...

def SurfaceContourPoints(surface_id: str, start_point: Union[List[float], Tuple[float, float, float], rg.Point3d], end_point: Union[List[float], Tuple[float, float, float], rg.Point3d], interval: Optional[float] = None, angle_tolerance: Optional[float] = None) -> List[str]: ...

def SurfaceCurvature(surface_id: str, parameter: List[float]) -> Optional[List[float]]: ...

def SurfaceCurvatureAnalysis(surface_id: str) -> List[float]: ...

def SurfaceDegree(surface_id: str, direction: int = 0) -> int: ...

def SurfaceDomain(surface_id: str, direction: int) -> List[float]: ...

def SurfaceEditPoints(surface_id: str, return_parameters: bool = False, return_all: bool = True) -> Union[List[List[float]], Tuple[List[List[float]], List[List[float]]]]: ...

def SurfaceEvaluate(surface_id: str, parameter: List[float], derivative: List[int]) -> List[List[float]]: ...

def SurfaceFrame(surface_id: str, parameter: List[float]) -> List[List[float]]: ...

def SurfaceIsocurveDensity(surface_id: str, density: Optional[int] = None) -> int: ...

def SurfaceKnotCount(surface_id: str) -> List[int]: ...

def SurfaceKnots(surface_id: str) -> List[List[float]]: ...

def SurfaceNormal(surface_id: str, parameter: List[float]) -> List[float]: ...

def SurfaceParameter(surface_id: str, point: Union[List[float], Tuple[float, float, float], rg.Point3d]) -> List[float]: ...

def SurfacePointCount(surface_id: str) -> List[int]: ...

def SurfacePoints(surface_id: str, return_all: bool = True) -> List[List[float]]: ...

def SurfacePrincipalCurvature(surface_id: str, point: Union[List[float], Tuple[float, float, float], rg.Point3d]) -> Optional[List[List[float]]]: ...

def SurfaceSeam(surface_id: str, direction: int, parameter: float) -> bool: ...

def SurfaceVolume(surface_id: str) -> List[float]: ...

def SurfaceVolumeCentroid(surface_id: str) -> Optional[List[List[float]]]: ...

def SurfaceVolumeMoments(surface_id: str) -> Optional[List[List[float]]]: ...

def SurfaceWeights(surface_id: str) -> List[List[float]]: ...

def TrimBrep(brep_id: str, cutter: str, tolerance: Optional[float] = None) -> List[str]: ...

def TrimSurface(surface_id: str, direction: int, interval: List[float], delete_input: bool = True) -> Union[str, bool]: ...

def UnrollSurface(surface_id: str, explode: bool = False, following_geometry: Optional[List[str]] = None, absolute_tolerance: Optional[float] = None, relative_tolerance: Optional[float] = None) -> List[str]: ...

# Mesh operations
def AddPlanarMesh(object_id: str, delete_input: bool = False) -> str: ...

def BoundingBox(objects: Union[str, List[str]], view: Optional[str] = None, world_coords: bool = True) -> List[List[float]]: ...

def CullDuplicateMeshFaces(object_id: str) -> bool: ...

def DisjointMeshCount(object_id: str) -> int: ...

def DuplicateMeshBorder(object_id: str) -> List[str]: ...

def ExplodeMeshes(object_ids: List[str], delete_input: bool = False) -> List[str]: ...

def ExtractConnectedMeshFaces(object_id: str, face_indices: List[int], delete_input: bool = True) -> str: ...

def ExtractMeshFaces(object_id: str, face_indices: List[int], delete_input: bool = True) -> str: ...

def ExtractNonManifoldMeshEdges(object_id: str, non_manifold_edges_only: bool = False) -> List[str]: ...

def FlipMeshNormals(object_id: str) -> bool: ...

def IsMeshClosed(object_id: str) -> bool: ...

def IsMeshManifold(object_id: str) -> bool: ...

def JoinMeshes(object_ids: List[str], delete_input: bool = True) -> str: ...

def MeshArea(object_ids: Union[str, List[str]]) -> List[float]: ...

def MeshAreaCentroid(object_id: str) -> List[float]: ...

def MeshBooleanDifference(input_ids: List[str], delete_input: bool = True) -> List[str]: ...

def MeshBooleanIntersection(input_ids: List[str], delete_input: bool = True) -> List[str]: ...

def MeshBooleanSplit(input_ids: List[str], delete_input: bool = True) -> List[str]: ...

def MeshBooleanUnion(input_ids: List[str], delete_input: bool = True) -> List[str]: ...

def MeshClosestPoint(object_id: str, point: Union[List[float], Tuple[float, float, float], rg.Point3d], maximum_distance: Optional[float] = None) -> Optional[Tuple[List[float], int]]: ...

def MeshContourPoints(object_id: str, start_point: Union[List[float], Tuple[float, float, float], rg.Point3d], end_point: Union[List[float], Tuple[float, float, float], rg.Point3d], interval: Optional[float] = None, remove_coincident_points: bool = False) -> List[str]: ...

def MeshFaceCenters(object_id: str) -> List[List[float]]: ...

def MeshFaceCount(object_id: str) -> int: ...

def MeshFaceNormals(object_id: str) -> List[List[float]]: ...

def MeshFaceVertices(object_id: str) -> List[List[int]]: ...

def MeshFaces(object_id: str, face_type: bool = True) -> List[List[int]]: ...

def MeshHasFaceNormals(object_id: str) -> bool: ...

def MeshHasTextureCoordinates(object_id: str) -> bool: ...

def MeshHasVertexColors(object_id: str) -> bool: ...

def MeshHasVertexNormals(object_id: str) -> bool: ...

def MeshNakedEdgePoints(object_id: str) -> List[List[float]]: ...

def MeshOffset(mesh_id: str, distance: float) -> List[str]: ...

def MeshOutline(object_ids: Union[str, List[str]], view: Optional[str] = None) -> List[str]: ...

def MeshQuadCount(object_id: str) -> int: ...

def MeshQuadsToTriangles(object_id: str) -> bool: ...

def MeshTextureCoordinates(object_id: str, texture_coordinates: Optional[List[List[float]]] = None) -> Union[List[List[float]], bool]: ...

def MeshTriangleCount(object_id: str) -> int: ...

def MeshUnifyNormals(object_id: str) -> int: ...

def MeshVertexColors(object_id: str, vertex_colors: Optional[List[Union[int, Tuple[int, int, int]]]] = None) -> Union[List[int], bool]: ...

def MeshVertexCount(object_id: str) -> int: ...

def MeshVertexFaces(object_id: str, vertex_index: int) -> List[int]: ...

def MeshVertexNormals(object_id: str) -> List[List[float]]: ...

def MeshVertices(object_id: str) -> List[List[float]]: ...

def MeshVolume(object_ids: Union[str, List[str]]) -> List[float]: ...

def MeshVolumeCentroid(object_id: str) -> List[float]: ...

def PullCurveToMesh(mesh_id: str, curve_id: str) -> str: ...

def ReduceMesh(object_id: str, polygon_count: int, locking: bool = False, accuracy: int = 1, min_edge_length: Optional[float] = None, max_edge_length: Optional[float] = None, distance_tolerance: Optional[float] = None) -> bool: ...

def SmoothMesh(object_id: str, smooth_factor: float = 0.0, iterations: int = 1) -> bool: ...

def SplitDisjointMesh(object_id: str, delete_input: bool = False) -> List[str]: ...

def UnifyMeshNormals(object_id: str) -> int: ...

def WeldMesh(object_id: str, angle_tolerance_degrees: float = 0.0) -> int: ...

# Light operations
def AddDirectionalLight(start_point: Union[List[float], Tuple[float, float, float], rg.Point3d], end_point: Union[List[float], Tuple[float, float, float], rg.Point3d], name: Optional[str] = None) -> str: ...

def AddLinearLight(start_point: Union[List[float], Tuple[float, float, float], rg.Point3d], end_point: Union[List[float], Tuple[float, float, float], rg.Point3d], width: Optional[float] = None) -> str: ...

def AddPointLight(point: Union[List[float], Tuple[float, float, float], rg.Point3d], name: Optional[str] = None) -> str: ...

def AddRectangularLight(origin: Union[List[float], Tuple[float, float, float], rg.Point3d], width_point: Union[List[float], Tuple[float, float, float], rg.Point3d], height_point: Union[List[float], Tuple[float, float, float], rg.Point3d]) -> str: ...

def AddSpotLight(origin: Union[List[float], Tuple[float, float, float], rg.Point3d], radius: float, apex_point: Union[List[float], Tuple[float, float, float], rg.Point3d]) -> str: ...

def EnableLight(object_id: str, enable: Optional[bool] = None) -> bool: ...

def IsDirectionalLight(object_id: str) -> bool: ...

def IsLight(object_id: str) -> bool: ...

def IsLightEnabled(object_id: str) -> bool: ...

def IsLightReference(object_id: str) -> bool: ...

def IsLinearLight(object_id: str) -> bool: ...

def IsPointLight(object_id: str) -> bool: ...

def IsRectangularLight(object_id: str) -> bool: ...

def IsSpotLight(object_id: str) -> bool: ...

def LightColor(object_id: str, color: Optional[Union[int, Tuple[int, int, int]]] = None) -> Union[int, bool]: ...

def LightCount() -> int: ...

def LightDirection(object_id: str, direction: Optional[Union[List[float], Tuple[float, float, float], rg.Vector3d]] = None) -> Union[List[float], bool]: ...

def LightLocation(object_id: str, location: Optional[Union[List[float], Tuple[float, float, float], rg.Point3d]] = None) -> Union[List[float], bool]: ...

def LightName(object_id: str, name: Optional[str] = None) -> Union[str, bool]: ...

def LightObjects() -> List[str]: ...

def SpotLightHardness(object_id: str, hardness: Optional[float] = None) -> Union[float, bool]: ...

def SpotLightRadius(object_id: str, radius: Optional[float] = None) -> Union[float, bool]: ...

def SpotLightShadowIntensity(object_id: str, intensity: Optional[float] = None) -> Union[float, bool]: ...

# Material operations
def AddMaterialToLayer(layer: str) -> int: ...

def AddMaterialToObject(object_id: str) -> int: ...

def CopyMaterial(source_index: int, destination_index: int) -> bool: ...

def IsMaterialDefault(material_index: int) -> bool: ...

def IsMaterialReference(material_index: int) -> bool: ...

def MatchMaterial(source: Union[str, int], destination: Union[str, int]) -> int: ...

def MaterialBump(material_index: int, filename: Optional[str] = None) -> Union[str, bool]: ...

def MaterialColor(material_index: int, color: Optional[Union[int, Tuple[int, int, int]]] = None) -> Union[int, bool]: ...

def MaterialEnvironmentMap(material_index: int, filename: Optional[str] = None) -> Union[str, bool]: ...

def MaterialName(material_index: int, name: Optional[str] = None) -> Union[str, bool]: ...

def MaterialReflectiveColor(material_index: int, color: Optional[Union[int, Tuple[int, int, int]]] = None) -> Union[int, bool]: ...

def MaterialShine(material_index: int, shine: Optional[float] = None) -> Union[float, bool]: ...

def MaterialTexture(material_index: int, filename: Optional[str] = None) -> Union[str, bool]: ...

def MaterialTransparency(material_index: int, transparency: Optional[float] = None) -> Union[float, bool]: ...

def MaterialTransparencyMap(material_index: int, filename: Optional[str] = None) -> Union[str, bool]: ...

def ResetMaterial(material_index: int) -> bool: ...

# Utility geometry operations
def Angle(point1: Union[List[float], Tuple[float, float, float], rg.Point3d], point2: Union[List[float], Tuple[float, float, float], rg.Point3d], plane: Optional[rg.Plane] = None) -> Optional[float]: ...

def Angle2(line1: List[Union[List[float], Tuple[float, float, float], rg.Point3d]], line2: List[Union[List[float], Tuple[float, float, float], rg.Point3d]]) -> Optional[float]: ...

def BoundingBox(objects: Union[str, List[str]], view: Optional[str] = None, world_coords: bool = True) -> List[List[float]]: ...

def ClipboardText(text: Optional[str] = None) -> Union[str, bool]: ...

def CreatePoint(point: Union[List[float], Tuple[float, float, float], rg.Point3d]) -> rg.Point3d: ...

def CreateVector(x: float, y: float, z: float) -> rg.Vector3d: ...

def CreateXform(initial_plane: rg.Plane, final_plane: rg.Plane) -> rg.Transform: ...

def XformChangeBasis(initial_plane: rg.Plane, final_plane: rg.Plane) -> rg.Transform: ...

def XformCompare(xform1: rg.Transform, xform2: rg.Transform) -> int: ...

def XformDeterminant(xform: rg.Transform) -> float: ...

def XformIdentity() -> rg.Transform: ...

def XformInverse(xform: rg.Transform) -> Optional[rg.Transform]: ...

def XformMirror(mirror_plane_origin: Union[List[float], Tuple[float, float, float], rg.Point3d], mirror_plane_normal: Union[List[float], Tuple[float, float, float], rg.Vector3d]) -> rg.Transform: ...

def XformMultiply(xform1: rg.Transform, xform2: rg.Transform) -> rg.Transform: ...

def XformPlanarProjection(plane: rg.Plane) -> rg.Transform: ...

def XformRotation(angle_degrees: float, axis: Union[List[float], Tuple[float, float, float], rg.Vector3d], center_point: Union[List[float], Tuple[float, float, float], rg.Point3d]) -> rg.Transform: ...

def XformRotation2(angle_degrees: float, axis: Union[List[float], Tuple[float, float, float], rg.Vector3d], center_point: Union[List[float], Tuple[float, float, float], rg.Point3d]) -> rg.Transform: ...

def XformRotation3(start_direction: Union[List[float], Tuple[float, float, float], rg.Vector3d], end_direction: Union[List[float], Tuple[float, float, float], rg.Vector3d], center_point: Union[List[float], Tuple[float, float, float], rg.Point3d]) -> rg.Transform: ...

def XformRotation4(x0: Union[List[float], Tuple[float, float, float], rg.Point3d], y0: Union[List[float], Tuple[float, float, float], rg.Point3d], z0: Union[List[float], Tuple[float, float, float], rg.Point3d], x1: Union[List[float], Tuple[float, float, float], rg.Point3d], y1: Union[List[float], Tuple[float, float, float], rg.Point3d], z1: Union[List[float], Tuple[float, float, float], rg.Point3d]) -> rg.Transform: ...

def XformScale(scale: Union[float, List[float], Tuple[float, float, float]], center_point: Optional[Union[List[float], Tuple[float, float, float], rg.Point3d]] = None) -> rg.Transform: ...

def XformScreenToWorld(screen_point: List[int], view: Optional[str] = None, screen_to_client: bool = False) -> rg.Transform: ...

def XformShear(plane: rg.Plane, x: Union[List[float], Tuple[float, float, float], rg.Vector3d], y: Union[List[float], Tuple[float, float, float], rg.Vector3d], z: Union[List[float], Tuple[float, float, float], rg.Vector3d]) -> rg.Transform: ...

def XformTranslation(vector: Union[List[float], Tuple[float, float, float], rg.Vector3d]) -> rg.Transform: ...

def XformWorldToScreen(point: Union[List[float], Tuple[float, float, float], rg.Point3d], view: Optional[str] = None, client_to_screen: bool = False) -> rg.Transform: ...

def XformZero() -> rg.Transform: ...

def TransformObject(object_id: str, matrix: rg.Transform, copy: bool = False) -> Union[str, bool]: ...

def TransformObjects(object_ids: List[str], matrix: rg.Transform, copy: bool = False) -> Union[List[str], int]: ...

# Filter constants
filter = type('filter', (), {
    'point': 1,
    'pointcloud': 2,
    'curve': 4,
    'surface': 8,
    'polysurface': 16,
    'mesh': 32,
    'light': 256,
    'annotation': 512,
    'instance': 4096,
    'hatch': 65536,
    'any': 4294967295,
})()

# Object type constants
class ObjectType:
    Unknown = 0
    Point = 1
    PointCloud = 2
    Curve = 4
    Surface = 8
    Brep = 16
    Mesh = 32
    Light = 256
    Annotation = 512
    Block = 4096
    InstanceReference = 4096
    TextDot = 8192
    Grip = 16384
    Detail = 32768
    Hatch = 65536
    Morph = 131072
    SubD = 134217728
    Cage = 134217728
    Phantom = 262144
    ClippingPlane = 536870912
    Extrusion = 1073741824
    Any = 4294967295