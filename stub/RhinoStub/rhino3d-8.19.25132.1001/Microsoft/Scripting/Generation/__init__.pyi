"""this file is auto-generated by rhinocode stubmaker. do not make changes"""

# region: Exports
__all__ = ["AssemblyGen", "ActionRef", "CompilerHelpers", "ConstantCheck", "DynamicILGen", "FieldBuilderExpression", "EmitArrayHelper", "ILGen", "GeneratorOps", "MethodSignatureInfo", "Snippets", "TypeGen"]
# endregion

# region: Imports
from System import Collections
from System import ComponentModel
from System import Numerics
from System import Reflection
from System.Collections import Generic
from System.Linq import Expressions
from System.Reflection import Emit
from System.Runtime import CompilerServices
from System.Runtime import InteropServices
from typing import overload
import System
# endregion

# region: Microsoft.Dynamic, Version=1.3.1.0

class AssemblyGen(object):
    """    """
    def __init__(self, name: Reflection.AssemblyName, outDir: str, outFileExtension: str, isDebuggable: bool, attrs: Generic.IDictionary): ...
    @overload
    def DefinePublicType(self, name: str, parent: System.Type, preserveName: bool) -> Emit.TypeBuilder: ...
    @property
    def AssemblyBuilder(self) -> Emit.AssemblyBuilder: ...
    @property
    def ModuleBuilder(self) -> Emit.ModuleBuilder: ...
    @overload
    def MakeDelegateType(self, name: str, parameters: System.System.Array[System.Type], returnType: System.Type) -> System.Type: ...
    @overload
    def SaveAssembly() -> str: ...

class ActionRef(System.MulticastDelegate):
    """    ActionRef[T0, T1]
    """
    def __init__(self, object_: object, method: System.IntPtr): ...
    @overload
    def BeginInvoke(self, callback: System.AsyncCallback, object_: object) -> (System.IAsyncResult, T0, T1): ...
    @overload
    def EndInvoke(self, result: System.IAsyncResult) -> (T0, T1): ...
    @overload
    def Invoke() -> (T0, T1): ...

class CompilerHelpers(object):
    """    """
    @property
    def PublicStatic(self) -> Reflection.MethodAttributes: ...
    @overload
    @staticmethod
    def CanEmitConstant(value: object, type_: System.Type) -> bool: ...
    @overload
    @staticmethod
    def CanOptimizeMethod(method: Reflection.MethodBase) -> bool: ...
    @overload
    @staticmethod
    def Compile(lambda_: Expressions.Expression, emitDebugSymbols: bool) -> T: ...
    @overload
    @staticmethod
    def CreateBigInteger(value: System.Int64) -> Numerics.BigInteger: ...
    @overload
    @staticmethod
    def CreateBigInteger(value: int) -> Numerics.BigInteger: ...
    @overload
    @staticmethod
    def CreateBigInteger(isNegative: bool, data: System.System.Array[System.Byte]) -> Numerics.BigInteger: ...
    @overload
    @staticmethod
    def FilterConstructorsToPublicAndProtected(ctors: Generic.IEnumerable) -> Generic.IEnumerable: ...
    @overload
    @staticmethod
    def FilterNonVisibleMembers(targetType: System.Type, members: Generic.IEnumerable) -> Generic.IEnumerable: ...
    @overload
    @staticmethod
    def FilterNonVisibleMembersIterator(targetType: System.Type, members: Generic.IEnumerable) -> Generic.IEnumerable: ...
    @overload
    @staticmethod
    def GetConstructors(t: System.Type, privateBinding: bool) -> Reflection.System.Array[Reflection.MethodBase]: ...
    @overload
    @staticmethod
    def GetConstructors(t: System.Type, privateBinding: bool, includeProtected: bool) -> Reflection.System.Array[Reflection.MethodBase]: ...
    @overload
    @staticmethod
    def GetExplicitConverter(fromType: System.Type, toType: System.Type) -> Reflection.MethodInfo: ...
    @overload
    @staticmethod
    def GetExpressionTypes(expressions: Expressions.System.Array[Expressions.Expression]) -> System.System.Array[System.Type]: ...
    @overload
    @staticmethod
    def GetImplicitConverter(fromType: System.Type, toType: System.Type) -> Reflection.MethodInfo: ...
    @overload
    @staticmethod
    def GetMethodTargets(obj: object) -> Reflection.System.Array[Reflection.MethodBase]: ...
    @overload
    @staticmethod
    def GetMissingValue(type_: System.Type) -> object: ...
    @overload
    @staticmethod
    def GetSiteTypes(arguments: Generic.IList, returnType: System.Type) -> System.System.Array[System.Type]: ...
    @overload
    @staticmethod
    def GetTryConvertReturnValue(type_: System.Type) -> Expressions.Expression: ...
    @overload
    @staticmethod
    def GetType(obj: object) -> System.Type: ...
    @overload
    @staticmethod
    def GetTypes(args: System.System.Array[object]) -> System.System.Array[System.Type]: ...
    @overload
    @staticmethod
    def GetUniqueMethodName() -> str: ...
    @overload
    @staticmethod
    def GetVisibleType(value: object) -> System.Type: ...
    @overload
    @staticmethod
    def GetVisibleType(t: System.Type) -> System.Type: ...
    @overload
    @staticmethod
    def HasTypeConverter(fromType: System.Type, toType: System.Type) -> bool: ...
    @overload
    @staticmethod
    def IsComparisonOperator(op: Expressions.ExpressionType) -> bool: ...
    @overload
    @staticmethod
    def IsConstructor(mb: Reflection.MethodBase) -> bool: ...
    @overload
    @staticmethod
    def IsProtected(type_: System.Type) -> bool: ...
    @overload
    @staticmethod
    def IsProtected(info: Reflection.FieldInfo) -> bool: ...
    @overload
    @staticmethod
    def IsProtected(info: Reflection.MethodBase) -> bool: ...
    @overload
    @staticmethod
    def IsStatic(mi: Reflection.MethodBase) -> bool: ...
    @overload
    @staticmethod
    def IsStrongBox(target: object) -> bool: ...
    @overload
    @staticmethod
    def IsStrongBox(t: System.Type) -> bool: ...
    @overload
    @staticmethod
    def IsVisible(info: Reflection.FieldInfo) -> bool: ...
    @overload
    @staticmethod
    def IsVisible(info: Reflection.MethodBase) -> bool: ...
    @overload
    @staticmethod
    def LightCompile(lambda_: Expressions.LambdaExpression) -> System.Delegate: ...
    @overload
    @staticmethod
    def LightCompile(lambda_: Expressions.Expression) -> T: ...
    @overload
    @staticmethod
    def LightCompile(lambda_: Expressions.LambdaExpression, compilationThreshold: int) -> System.Delegate: ...
    @overload
    @staticmethod
    def LightCompile(lambda_: Expressions.Expression, compilationThreshold: int) -> T: ...
    @overload
    @staticmethod
    def MakeCallSiteDelegateType(types: System.System.Array[System.Type]) -> System.Type: ...
    @overload
    @staticmethod
    def MakeCallSiteType(types: System.System.Array[System.Type]) -> System.Type: ...
    @overload
    @staticmethod
    def MakeRepeatedArray(item: T, count: int) -> System.Array[T]: ...
    @overload
    @staticmethod
    def MemberEquals(self: Reflection.MemberInfo, other: Reflection.MemberInfo) -> bool: ...
    @overload
    @staticmethod
    def Reduce(node: Expressions.DynamicExpression) -> Expressions.Expression: ...
    @overload
    @staticmethod
    def TryApplyTypeConverter(value: object, toType: System.Type) -> (bool, object): ...
    @overload
    @staticmethod
    def TryGetCallableMethod(targetType: System.Type, method: Reflection.MethodInfo) -> Reflection.MethodInfo: ...
    @overload
    @staticmethod
    def TryGetTypeConverter(fromType: System.Type, toType: System.Type) -> (bool, ComponentModel.TypeConverter): ...
    @overload
    @staticmethod
    def TryGetVisibleMember(targetType: System.Type, member: Reflection.MemberInfo) -> Reflection.MemberInfo: ...
    @overload
    @staticmethod
    def TryImplicitConversion(value: object, to: System.Type) -> (bool, object): ...
    @overload
    @staticmethod
    def TypesEqual(args: Collections.IList, start: int, types: System.System.Array[System.Type]) -> bool: ...

class ConstantCheck(object):
    """    """
    @overload
    @staticmethod
    def Check(expression: Expressions.Expression, value: object) -> bool: ...

class DynamicILGen(ILGen):
    """    """
    @overload
    def CreateDelegate() -> T: ...
    @overload
    def CreateDelegate() -> (T, Reflection.MethodInfo): ...
    @overload
    def Finish() -> Reflection.MethodInfo: ...

class FieldBuilderExpression(Expressions.Expression):
    """    """
    def __init__(self, builder: Emit.FieldBuilder, finishedType: CompilerServices.StrongBox): ...
    @property
    def CanReduce(self) -> bool: ...
    @property
    def NodeType(self) -> Expressions.ExpressionType: ...
    @property
    def Type(self) -> System.Type: ...
    @overload
    def Reduce() -> Expressions.Expression: ...

class EmitArrayHelper(System.MulticastDelegate):
    """    """
    def __init__(self, object_: object, method: System.IntPtr): ...
    @overload
    def BeginInvoke(self, index: int, callback: System.AsyncCallback, object_: object) -> System.IAsyncResult: ...
    @overload
    def EndInvoke(self, result: System.IAsyncResult) -> None: ...
    @overload
    def Invoke(self, index: int) -> None: ...

class ILGen(object):
    """    """
    def __init__(self, ilg: Emit.ILGenerator): ...
    @overload
    def BeginCatchBlock(self, exceptionType: System.Type) -> None: ...
    @overload
    def BeginExceptFilterBlock() -> None: ...
    @overload
    def BeginExceptionBlock() -> Emit.Label: ...
    @overload
    def BeginFaultBlock() -> None: ...
    @overload
    def BeginFinallyBlock() -> None: ...
    @overload
    def BeginScope() -> None: ...
    @overload
    def DeclareLocal(self, localType: System.Type) -> Emit.LocalBuilder: ...
    @overload
    def DeclareLocal(self, localType: System.Type, pinned: bool) -> Emit.LocalBuilder: ...
    @overload
    def DefineLabel() -> Emit.Label: ...
    @overload
    def Emit(self, opcode: Emit.OpCode) -> None: ...
    @overload
    def Emit(self, opcode: Emit.OpCode, cls: System.Type) -> None: ...
    @overload
    def Emit(self, opcode: Emit.OpCode, labels: Emit.System.Array[Emit.Label]) -> None: ...
    @overload
    def Emit(self, opcode: Emit.OpCode, signature: Emit.SignatureHelper) -> None: ...
    @overload
    def Emit(self, opcode: Emit.OpCode, arg: System.Int16) -> None: ...
    @overload
    def Emit(self, opcode: Emit.OpCode, arg: System.SByte) -> None: ...
    @overload
    def Emit(self, opcode: Emit.OpCode, meth: Reflection.MethodInfo) -> None: ...
    @overload
    def Emit(self, opcode: Emit.OpCode, local: Emit.LocalBuilder) -> None: ...
    @overload
    def Emit(self, opcode: Emit.OpCode, str_: str) -> None: ...
    @overload
    def Emit(self, opcode: Emit.OpCode, label: Emit.Label) -> None: ...
    @overload
    def Emit(self, opcode: Emit.OpCode, arg: System.Int64) -> None: ...
    @overload
    def Emit(self, opcode: Emit.OpCode, arg: System.Single) -> None: ...
    @overload
    def Emit(self, opcode: Emit.OpCode, field: Reflection.FieldInfo) -> None: ...
    @overload
    def Emit(self, opcode: Emit.OpCode, arg: float) -> None: ...
    @overload
    def Emit(self, opcode: Emit.OpCode, con: Reflection.ConstructorInfo) -> None: ...
    @overload
    def Emit(self, opcode: Emit.OpCode, arg: System.Byte) -> None: ...
    @overload
    def Emit(self, opcode: Emit.OpCode, arg: int) -> None: ...
    @overload
    def EmitArray(self, items: Generic.IList) -> None: ...
    @overload
    def EmitArray(self, arrayType: System.Type) -> None: ...
    @overload
    def EmitArray(self, elementType: System.Type, count: int, emit: EmitArrayHelper) -> None: ...
    @overload
    def EmitBoolean(self, value: bool) -> None: ...
    @overload
    def EmitBoxing(self, type_: System.Type) -> None: ...
    @overload
    def EmitByte(self, value: System.Byte) -> None: ...
    @overload
    def EmitCall(self, mi: Reflection.MethodInfo) -> None: ...
    @overload
    def EmitCall(self, type_: System.Type, name: str) -> None: ...
    @overload
    def EmitCall(self, opcode: Emit.OpCode, methodInfo: Reflection.MethodInfo, optionalParameterTypes: System.System.Array[System.Type]) -> None: ...
    @overload
    def EmitCall(self, type_: System.Type, name: str, paramTypes: System.System.Array[System.Type]) -> None: ...
    @overload
    def EmitCalli(self, opcode: Emit.OpCode, unmanagedCallConv: InteropServices.CallingConvention, returnType: System.Type, parameterTypes: System.System.Array[System.Type]) -> None: ...
    @overload
    def EmitCalli(self, opcode: Emit.OpCode, callingConvention: Reflection.CallingConventions, returnType: System.Type, parameterTypes: System.System.Array[System.Type], optionalParameterTypes: System.System.Array[System.Type]) -> None: ...
    @overload
    def EmitChar(self, value: System.Char) -> None: ...
    @overload
    def EmitDecimal(self, value: System.Decimal) -> None: ...
    @overload
    def EmitDouble(self, value: float) -> None: ...
    @overload
    def EmitExplicitCast(self, from_: System.Type, to: System.Type) -> None: ...
    @overload
    def EmitFieldAddress(self, fi: Reflection.FieldInfo) -> None: ...
    @overload
    def EmitFieldGet(self, fi: Reflection.FieldInfo) -> None: ...
    @overload
    def EmitFieldSet(self, fi: Reflection.FieldInfo) -> None: ...
    @overload
    def EmitImplicitCast(self, from_: System.Type, to: System.Type) -> None: ...
    @overload
    def EmitInt(self, value: int) -> None: ...
    @overload
    def EmitLoadArg(self, index: int) -> None: ...
    @overload
    def EmitLoadArgAddress(self, index: int) -> None: ...
    @overload
    def EmitLoadElement(self, type_: System.Type) -> None: ...
    @overload
    def EmitLoadValueIndirect(self, type_: System.Type) -> None: ...
    @overload
    def EmitLong(self, value: System.Int64) -> None: ...
    @overload
    def EmitMissingValue(self, type_: System.Type) -> None: ...
    @overload
    def EmitNew(self, ci: Reflection.ConstructorInfo) -> None: ...
    @overload
    def EmitNew(self, type_: System.Type, paramTypes: System.System.Array[System.Type]) -> None: ...
    @overload
    def EmitNull() -> None: ...
    @overload
    def EmitNumericCast(self, from_: System.Type, to: System.Type, implicitOnly: bool) -> bool: ...
    @overload
    def EmitPropertyGet(self, pi: Reflection.PropertyInfo) -> None: ...
    @overload
    def EmitPropertySet(self, pi: Reflection.PropertyInfo) -> None: ...
    @overload
    def EmitSByte(self, value: System.SByte) -> None: ...
    @overload
    def EmitShort(self, value: System.Int16) -> None: ...
    @overload
    def EmitSingle(self, value: System.Single) -> None: ...
    @overload
    def EmitStoreArg(self, index: int) -> None: ...
    @overload
    def EmitStoreElement(self, type_: System.Type) -> None: ...
    @overload
    def EmitStoreValueIndirect(self, type_: System.Type) -> None: ...
    @overload
    def EmitString(self, value: str) -> None: ...
    @overload
    def EmitType(self, type_: System.Type) -> None: ...
    @overload
    def EmitUInt(self, value: System.UInt32) -> None: ...
    @overload
    def EmitULong(self, value: System.UInt64) -> None: ...
    @overload
    def EmitUnbox(self, type_: System.Type) -> None: ...
    @overload
    def EmitUShort(self, value: System.UInt16) -> None: ...
    @overload
    def EndExceptionBlock() -> None: ...
    @overload
    def EndScope() -> None: ...
    @overload
    def MarkLabel(self, loc: Emit.Label) -> None: ...
    @overload
    @staticmethod
    def ShouldLdtoken(t: System.Type) -> bool: ...
    @overload
    @staticmethod
    def ShouldLdtoken(mb: Reflection.MethodBase) -> bool: ...
    @overload
    def TryEmitExplicitCast(self, from_: System.Type, to: System.Type) -> bool: ...
    @overload
    def TryEmitImplicitCast(self, from_: System.Type, to: System.Type) -> bool: ...
    @overload
    def UsingNamespace(self, usingNamespace: str) -> None: ...

class GeneratorOps(object):
    """    """
    @overload
    @staticmethod
    def BoxGeneric(value: T) -> object: ...

class MethodSignatureInfo(object):
    """    """
    @overload
    def __init__(self, info: Reflection.MethodInfo): ...
    @overload
    def __init__(self, isStatic: bool, pis: Reflection.System.Array[Reflection.ParameterInfo], genericArity: int): ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def GetHashCode() -> int: ...

class Snippets(object):
    """    """
    @property
    def Shared(self) -> Snippets: ...
    @overload
    def CreateDynamicMethod(self, methodName: str, returnType: System.Type, parameterTypes: System.System.Array[System.Type], isDebuggable: bool) -> DynamicILGen: ...
    @overload
    def DefineDelegate(self, name: str, returnType: System.Type, argTypes: System.System.Array[System.Type]) -> System.Type: ...
    @overload
    def DefineDelegateType(self, name: str) -> Emit.TypeBuilder: ...
    @overload
    def DefinePublicType(self, name: str, parent: System.Type) -> Emit.TypeBuilder: ...
    @overload
    def DefineType(self, name: str, parent: System.Type, preserveName: bool, emitDebugSymbols: bool) -> TypeGen: ...
    @property
    def SaveSnippets(self) -> bool: ...
    @property
    def SnippetsDirectory(self) -> str: ...
    @overload
    def IsSnippetsAssembly(self, asm: Reflection.Assembly) -> bool: ...
    @overload
    @staticmethod
    def SaveAndVerifyAssemblies() -> None: ...
    @overload
    @staticmethod
    def SetSaveAssemblies(enable: bool, directory: str) -> None: ...

class TypeGen(object):
    """    """
    def __init__(self, myAssembly: AssemblyGen, myType: Emit.TypeBuilder): ...
    @overload
    def AddStaticField(self, fieldType: System.Type, name: str) -> Emit.FieldBuilder: ...
    @overload
    def AddStaticField(self, fieldType: System.Type, attributes: Reflection.FieldAttributes, name: str) -> Emit.FieldBuilder: ...
    @overload
    def DefineExplicitInterfaceImplementation(self, baseMethod: Reflection.MethodInfo) -> ILGen: ...
    @overload
    def DefineMethodOverride(self, baseMethod: Reflection.MethodInfo) -> ILGen: ...
    @overload
    def FinishType() -> System.Type: ...
    @property
    def TypeBuilder(self) -> Emit.TypeBuilder: ...
    @property
    def TypeInitializer(self) -> ILGen: ...
    @overload
    def ToString() -> str: ...

# endregion
