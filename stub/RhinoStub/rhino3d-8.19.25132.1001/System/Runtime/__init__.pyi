"""this file is auto-generated by rhinocode stubmaker. do not make changes"""

# region: Exports
__all__ = ["Caching"]
# endregion

# region: Imports
from typing import overload
# endregion

# region: Exports
__all__ = ["Serialization", "Diagnostics", "AsyncCompletionResult", "ServiceModelSynchronizationContext", "TaskHelpers", "DefaultTaskSchedulerAwaiter", "OutWrapper", "TimeoutHelper", "EndWithOutDelegate"]
# endregion

# region: Imports
from System import ServiceModel
from System import Threading
from System.Runtime import CompilerServices
from System.Threading import Tasks
from typing import overload
import enum
import System
# endregion

# region: Exports
__all__ = ["CompilerServices"]
# endregion

# region: Imports
from typing import overload
# endregion

# region: Exports
__all__ = ["Serialization"]
# endregion

# region: Imports
from typing import overload
# endregion

# region: Exports
__all__ = ["Serialization"]
# endregion

# region: Imports
from typing import overload
# endregion

# region: Exports
__all__ = ["Serialization"]
# endregion

# region: Imports
from typing import overload
# endregion

# region: Exports
__all__ = ["InteropServices"]
# endregion

# region: Imports
from typing import overload
# endregion

# region: Exports
__all__ = ["CompilerServices"]
# endregion

# region: Imports
from typing import overload
# endregion

# region: Exports
__all__ = ["InteropServices", "CompilerServices"]
# endregion

# region: Imports
from typing import overload
# endregion

# region: Exports
__all__ = ["Serialization", "Remoting", "ExceptionServices", "ConstrainedExecution", "Versioning", "Loader", "Intrinsics", "InteropServices", "CompilerServices", "ControlledExecution", "DependentHandle", "GCSettings", "JitInfo", "AmbiguousImplementationException", "GCLargeObjectHeapCompactionMode", "GCLatencyMode", "MemoryFailPoint", "AssemblyTargetedPatchBandAttribute", "TargetedPatchingOptOutAttribute", "ProfileOptimization"]
# endregion

# region: Imports
from System.Runtime import CompilerServices
from System.Runtime import ConstrainedExecution
from typing import overload
import enum
import System
# endregion

# region: System.Private.CoreLib, Version=7.0.0.0

class ControlledExecution(object):
    """    """

class DependentHandle(System.ValueType):
    """    """
    def __init__(self, target: object, dependent: object): ...
    @overload
    def Dispose() -> None: ...
    @property
    def Dependent(self) -> object: ...
    @property
    def IsAllocated(self) -> bool: ...
    @property
    def Target(self) -> object: ...
    @property
    def TargetAndDependent(self) -> System.ValueTuple: ...
    @Dependent.setter
    def Dependent(self, value: System.Void): ...
    @Target.setter
    def Target(self, value: System.Void): ...

class GCSettings(object):
    """    """
    @property
    def IsServerGC(self) -> bool: ...
    @property
    def LargeObjectHeapCompactionMode(self) -> GCLargeObjectHeapCompactionMode: ...
    @property
    def LatencyMode(self) -> GCLatencyMode: ...
    @LargeObjectHeapCompactionMode.setter
    def LargeObjectHeapCompactionMode(self, value: System.Void): ...
    @LatencyMode.setter
    def LatencyMode(self, value: System.Void): ...

class JitInfo(object):
    """    """
    @overload
    @staticmethod
    def GetCompilationTime(currentThread: bool) -> System.TimeSpan: ...
    @overload
    @staticmethod
    def GetCompiledILBytes(currentThread: bool) -> System.Int64: ...
    @overload
    @staticmethod
    def GetCompiledMethodCount(currentThread: bool) -> System.Int64: ...

class AmbiguousImplementationException(System.Exception):
    """    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, message: str): ...
    @overload
    def __init__(self, message: str, innerException: System.Exception): ...

class GCLargeObjectHeapCompactionMode(enum.Enum):
    Default = 1
    CompactOnce = 2

class GCLatencyMode(enum.Enum):
    Batch = 0
    Interactive = 1
    LowLatency = 2
    SustainedLowLatency = 3
    NoGCRegion = 4

class MemoryFailPoint(ConstrainedExecution.CriticalFinalizerObject):
    """    """
    def __init__(self, sizeInMegabytes: int): ...
    @overload
    def Dispose() -> None: ...

class AssemblyTargetedPatchBandAttribute(System.Attribute):
    """    """
    def __init__(self, targetedPatchBand: str): ...
    @property
    def TargetedPatchBand(self) -> str: ...

class TargetedPatchingOptOutAttribute(System.Attribute):
    """    """
    def __init__(self, reason: str): ...
    @property
    def Reason(self) -> str: ...

class ProfileOptimization(object):
    """    """
    @overload
    @staticmethod
    def SetProfileRoot(directoryPath: str) -> None: ...
    @overload
    @staticmethod
    def StartProfile(profile: str) -> None: ...

# endregion

# region: System.Private.ServiceModel, Version=4.9.0.0

class AsyncCompletionResult(enum.Enum):
    Queued = 0
    Completed = 1

class ServiceModelSynchronizationContext(Threading.SynchronizationContext):
    """    """
    def __init__(self): ...
    @property
    def Instance(self) -> ServiceModelSynchronizationContext: ...
    @overload
    def Post(self, d: Threading.SendOrPostCallback, state: object) -> None: ...

class TaskHelpers(object):
    """    """
    @property
    def OnAsyncCompletionCallback(self) -> System.Action: ...
    @overload
    @staticmethod
    def AsyncWait(task: Tasks.Task) -> Tasks.Task: ...
    @overload
    @staticmethod
    def AwaitWithTimeout(task: Tasks.Task, timeout: System.TimeSpan) -> Tasks.Task: ...
    @overload
    @staticmethod
    def CallActionAsync(action: System.Action, argument: TArg) -> Tasks.Task: ...
    @overload
    @staticmethod
    def CloseHelperAsync(communicationObject: ServiceModel.ICommunicationObject, timeout: System.TimeSpan) -> Tasks.Task: ...
    @overload
    @staticmethod
    def CompletedTask() -> Tasks.Task: ...
    @overload
    @staticmethod
    def EnsureDefaultTaskScheduler() -> DefaultTaskSchedulerAwaiter: ...
    @overload
    @staticmethod
    def FromAsync(beginDelegate: System.Func, endDelegate: EndWithOutDelegate, arg1: TIn, state: object) -> Tasks.Task: ...
    @overload
    @staticmethod
    def OpenHelperAsync(communicationObject: ServiceModel.ICommunicationObject, timeout: System.TimeSpan) -> Tasks.Task: ...
    @overload
    @staticmethod
    def RunTaskContinuationsOnOurThreads() -> System.IDisposable: ...
    @overload
    @staticmethod
    def ToApm(task: Tasks.Task, callback: System.AsyncCallback, state: object) -> Tasks.Task: ...
    @overload
    @staticmethod
    def ToApm(task: Tasks.Task, callback: System.AsyncCallback, state: object) -> Tasks.Task: ...
    @overload
    @staticmethod
    def ToApmEnd(iar: System.IAsyncResult) -> None: ...
    @overload
    @staticmethod
    def ToApmEnd(iar: System.IAsyncResult) -> TResult: ...
    @overload
    @staticmethod
    def Wait(task: Tasks.Task, timeout: System.TimeSpan, exceptionConverter: System.Action, operationType: str) -> None: ...
    @overload
    @staticmethod
    def WaitForCompletion(task: Tasks.Task) -> None: ...
    @overload
    @staticmethod
    def WaitForCompletion(task: Tasks.Task) -> TResult: ...
    @overload
    @staticmethod
    def WaitForCompletionNoSpin(task: Tasks.Task) -> None: ...
    @overload
    @staticmethod
    def WaitForCompletionNoSpin(task: Tasks.Task) -> TResult: ...
    @overload
    @staticmethod
    def WaitForCompletionNoSpin(task: Tasks.Task, timeout: System.TimeSpan) -> bool: ...

class DefaultTaskSchedulerAwaiter(System.ValueType):
    """    """
    @property
    def Singleton(self) -> DefaultTaskSchedulerAwaiter: ...
    @property
    def IsCompleted(self) -> bool: ...
    @overload
    def GetAwaiter() -> DefaultTaskSchedulerAwaiter: ...
    @overload
    def GetResult() -> None: ...
    @overload
    def OnCompleted(self, continuation: System.Action) -> None: ...

class OutWrapper(object):
    """    OutWrapper[T]
    """
    def __init__(self): ...
    @property
    def Value(self) -> T: ...
    @Value.setter
    def Value(self, value: System.Void): ...

class TimeoutHelper(System.ValueType):
    """    """
    def __init__(self, timeout: System.TimeSpan): ...
    @property
    def MaxWait(self) -> System.TimeSpan: ...
    @overload
    @staticmethod
    def Add(time: System.DateTime, timeout: System.TimeSpan) -> System.DateTime: ...
    @overload
    @staticmethod
    def Add(timeout1: System.TimeSpan, timeout2: System.TimeSpan) -> System.TimeSpan: ...
    @overload
    @staticmethod
    def Divide(timeout: System.TimeSpan, factor: int) -> System.TimeSpan: ...
    @overload
    def ElapsedTime() -> System.TimeSpan: ...
    @overload
    @staticmethod
    def FromMilliseconds(milliseconds: int) -> System.TimeSpan: ...
    @property
    def OriginalTimeout(self) -> System.TimeSpan: ...
    @overload
    def GetCancellationToken() -> Threading.CancellationToken: ...
    @overload
    def GetCancellationTokenAsync() -> Tasks.Task: ...
    @overload
    @staticmethod
    def IsTooLarge(timeout: System.TimeSpan) -> bool: ...
    @overload
    @staticmethod
    def Min(val1: System.TimeSpan, val2: System.TimeSpan) -> System.TimeSpan: ...
    @overload
    def RemainingTime() -> System.TimeSpan: ...
    @overload
    @staticmethod
    def Subtract(time: System.DateTime, timeout: System.TimeSpan) -> System.DateTime: ...
    @overload
    @staticmethod
    def ThrowIfNegativeArgument(timeout: System.TimeSpan) -> None: ...
    @overload
    @staticmethod
    def ThrowIfNegativeArgument(timeout: System.TimeSpan, argumentName: str) -> None: ...
    @overload
    @staticmethod
    def ThrowIfNonPositiveArgument(timeout: System.TimeSpan) -> None: ...
    @overload
    @staticmethod
    def ThrowIfNonPositiveArgument(timeout: System.TimeSpan, argumentName: str) -> None: ...
    @overload
    @staticmethod
    def ToMilliseconds(timeout: System.TimeSpan) -> int: ...
    @overload
    @staticmethod
    def WaitOne(waitHandle: Threading.WaitHandle, timeout: System.TimeSpan) -> bool: ...

class EndWithOutDelegate(System.MulticastDelegate):
    """    EndWithOutDelegate[T1, TResult]
    """
    def __init__(self, object_: object, method: System.IntPtr): ...
    @overload
    def BeginInvoke(self, iar: System.IAsyncResult, callback: System.AsyncCallback, object_: object) -> (System.IAsyncResult, T1): ...
    @overload
    def EndInvoke(self, result: System.IAsyncResult) -> (TResult, T1): ...
    @overload
    def Invoke(self, iar: System.IAsyncResult) -> (TResult, T1): ...

# endregion

