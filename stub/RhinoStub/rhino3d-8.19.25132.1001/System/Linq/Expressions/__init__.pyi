"""this file is auto-generated by rhinocode stubmaker. do not make changes"""

# region: Exports
__all__ = ["Interpreter", "BinaryExpression", "Expression", "BlockExpression", "CatchBlock", "ConditionalExpression", "ConstantExpression", "DebugInfoExpression", "DefaultExpression", "ElementInit", "ExpressionType", "ExpressionVisitor", "GotoExpressionKind", "GotoExpression", "IArgumentProvider", "IDynamicExpression", "IndexExpression", "InvocationExpression", "LabelExpression", "LabelTarget", "LambdaExpression", "ListInitExpression", "LoopExpression", "MemberAssignment", "MemberBindingType", "MemberBinding", "MemberExpression", "MemberInitExpression", "MemberListBinding", "MemberMemberBinding", "MethodCallExpression", "NewArrayExpression", "NewExpression", "ParameterExpression", "RuntimeVariablesExpression", "SwitchCase", "SwitchExpression", "SymbolDocumentInfo", "TryExpression", "TypeBinaryExpression", "UnaryExpression", "DynamicExpressionVisitor", "DynamicExpression"]
# endregion

# region: Imports
from System import Reflection
from System.Collections import Generic
from System.Collections import ObjectModel
from System.Runtime import CompilerServices
from typing import overload
import enum
import System
# endregion

# region: System.Linq.Expressions, Version=7.0.0.0

class BinaryExpression(Expression):
    """    """
    @property
    def CanReduce(self) -> bool: ...
    @property
    def Conversion(self) -> LambdaExpression: ...
    @property
    def IsLifted(self) -> bool: ...
    @property
    def IsLiftedToNull(self) -> bool: ...
    @property
    def Left(self) -> Expression: ...
    @property
    def Method(self) -> Reflection.MethodInfo: ...
    @property
    def Right(self) -> Expression: ...
    @overload
    def Reduce() -> Expression: ...
    @overload
    def Update(self, left: Expression, conversion: LambdaExpression, right: Expression) -> BinaryExpression: ...

class Expression(object):
    """    """
    @overload
    @staticmethod
    def Add(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def Add(left: Expression, right: Expression, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def AddAssign(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def AddAssign(left: Expression, right: Expression, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def AddAssign(left: Expression, right: Expression, method: Reflection.MethodInfo, conversion: LambdaExpression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def AddAssignChecked(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def AddAssignChecked(left: Expression, right: Expression, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def AddAssignChecked(left: Expression, right: Expression, method: Reflection.MethodInfo, conversion: LambdaExpression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def AddChecked(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def AddChecked(left: Expression, right: Expression, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def And(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def And(left: Expression, right: Expression, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def AndAlso(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def AndAlso(left: Expression, right: Expression, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def AndAssign(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def AndAssign(left: Expression, right: Expression, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def AndAssign(left: Expression, right: Expression, method: Reflection.MethodInfo, conversion: LambdaExpression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def ArrayAccess(array: Expression, indexes: Generic.IEnumerable) -> IndexExpression: ...
    @overload
    @staticmethod
    def ArrayAccess(array: Expression, indexes: System.Array[Expression]) -> IndexExpression: ...
    @overload
    @staticmethod
    def ArrayIndex(array: Expression, index: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def ArrayIndex(array: Expression, indexes: System.Array[Expression]) -> MethodCallExpression: ...
    @overload
    @staticmethod
    def ArrayIndex(array: Expression, indexes: Generic.IEnumerable) -> MethodCallExpression: ...
    @overload
    @staticmethod
    def ArrayLength(array: Expression) -> UnaryExpression: ...
    @overload
    @staticmethod
    def Assign(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def Bind(propertyAccessor: Reflection.MethodInfo, expression: Expression) -> MemberAssignment: ...
    @overload
    @staticmethod
    def Bind(member: Reflection.MemberInfo, expression: Expression) -> MemberAssignment: ...
    @overload
    @staticmethod
    def Block(expressions: Generic.IEnumerable) -> BlockExpression: ...
    @overload
    @staticmethod
    def Block(expressions: System.Array[Expression]) -> BlockExpression: ...
    @overload
    @staticmethod
    def Block(variables: Generic.IEnumerable, expressions: Generic.IEnumerable) -> BlockExpression: ...
    @overload
    @staticmethod
    def Block(variables: Generic.IEnumerable, expressions: System.Array[Expression]) -> BlockExpression: ...
    @overload
    @staticmethod
    def Block(type_: System.Type, expressions: Generic.IEnumerable) -> BlockExpression: ...
    @overload
    @staticmethod
    def Block(type_: System.Type, expressions: System.Array[Expression]) -> BlockExpression: ...
    @overload
    @staticmethod
    def Block(arg0: Expression, arg1: Expression) -> BlockExpression: ...
    @overload
    @staticmethod
    def Block(type_: System.Type, variables: Generic.IEnumerable, expressions: System.Array[Expression]) -> BlockExpression: ...
    @overload
    @staticmethod
    def Block(type_: System.Type, variables: Generic.IEnumerable, expressions: Generic.IEnumerable) -> BlockExpression: ...
    @overload
    @staticmethod
    def Block(arg0: Expression, arg1: Expression, arg2: Expression) -> BlockExpression: ...
    @overload
    @staticmethod
    def Block(arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression) -> BlockExpression: ...
    @overload
    @staticmethod
    def Block(arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression, arg4: Expression) -> BlockExpression: ...
    @overload
    @staticmethod
    def Break(target: LabelTarget) -> GotoExpression: ...
    @overload
    @staticmethod
    def Break(target: LabelTarget, value: Expression) -> GotoExpression: ...
    @overload
    @staticmethod
    def Break(target: LabelTarget, type_: System.Type) -> GotoExpression: ...
    @overload
    @staticmethod
    def Break(target: LabelTarget, value: Expression, type_: System.Type) -> GotoExpression: ...
    @overload
    @staticmethod
    def Call(method: Reflection.MethodInfo, arguments: System.Array[Expression]) -> MethodCallExpression: ...
    @overload
    @staticmethod
    def Call(method: Reflection.MethodInfo, arguments: Generic.IEnumerable) -> MethodCallExpression: ...
    @overload
    @staticmethod
    def Call(instance: Expression, method: Reflection.MethodInfo) -> MethodCallExpression: ...
    @overload
    @staticmethod
    def Call(method: Reflection.MethodInfo, arg0: Expression) -> MethodCallExpression: ...
    @overload
    @staticmethod
    def Call(method: Reflection.MethodInfo, arg0: Expression, arg1: Expression) -> MethodCallExpression: ...
    @overload
    @staticmethod
    def Call(instance: Expression, method: Reflection.MethodInfo, arguments: System.Array[Expression]) -> MethodCallExpression: ...
    @overload
    @staticmethod
    def Call(instance: Expression, method: Reflection.MethodInfo, arguments: Generic.IEnumerable) -> MethodCallExpression: ...
    @overload
    @staticmethod
    def Call(method: Reflection.MethodInfo, arg0: Expression, arg1: Expression, arg2: Expression) -> MethodCallExpression: ...
    @overload
    @staticmethod
    def Call(instance: Expression, method: Reflection.MethodInfo, arg0: Expression, arg1: Expression) -> MethodCallExpression: ...
    @overload
    @staticmethod
    def Call(instance: Expression, methodName: str, typeArguments: System.System.Array[System.Type], arguments: System.Array[Expression]) -> MethodCallExpression: ...
    @overload
    @staticmethod
    def Call(type_: System.Type, methodName: str, typeArguments: System.System.Array[System.Type], arguments: System.Array[Expression]) -> MethodCallExpression: ...
    @overload
    @staticmethod
    def Call(instance: Expression, method: Reflection.MethodInfo, arg0: Expression, arg1: Expression, arg2: Expression) -> MethodCallExpression: ...
    @overload
    @staticmethod
    def Call(method: Reflection.MethodInfo, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression) -> MethodCallExpression: ...
    @overload
    @staticmethod
    def Call(method: Reflection.MethodInfo, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression, arg4: Expression) -> MethodCallExpression: ...
    @overload
    @staticmethod
    def Catch(variable: ParameterExpression, body: Expression) -> CatchBlock: ...
    @overload
    @staticmethod
    def Catch(type_: System.Type, body: Expression) -> CatchBlock: ...
    @overload
    @staticmethod
    def Catch(type_: System.Type, body: Expression, filter_: Expression) -> CatchBlock: ...
    @overload
    @staticmethod
    def Catch(variable: ParameterExpression, body: Expression, filter_: Expression) -> CatchBlock: ...
    @overload
    @staticmethod
    def ClearDebugInfo(document: SymbolDocumentInfo) -> DebugInfoExpression: ...
    @overload
    @staticmethod
    def Coalesce(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def Coalesce(left: Expression, right: Expression, conversion: LambdaExpression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def Condition(test: Expression, ifTrue: Expression, ifFalse: Expression) -> ConditionalExpression: ...
    @overload
    @staticmethod
    def Condition(test: Expression, ifTrue: Expression, ifFalse: Expression, type_: System.Type) -> ConditionalExpression: ...
    @overload
    @staticmethod
    def Constant(value: object) -> ConstantExpression: ...
    @overload
    @staticmethod
    def Constant(value: object, type_: System.Type) -> ConstantExpression: ...
    @overload
    @staticmethod
    def Continue(target: LabelTarget) -> GotoExpression: ...
    @overload
    @staticmethod
    def Continue(target: LabelTarget, type_: System.Type) -> GotoExpression: ...
    @overload
    @staticmethod
    def Convert(expression: Expression, type_: System.Type) -> UnaryExpression: ...
    @overload
    @staticmethod
    def Convert(expression: Expression, type_: System.Type, method: Reflection.MethodInfo) -> UnaryExpression: ...
    @overload
    @staticmethod
    def ConvertChecked(expression: Expression, type_: System.Type) -> UnaryExpression: ...
    @overload
    @staticmethod
    def ConvertChecked(expression: Expression, type_: System.Type, method: Reflection.MethodInfo) -> UnaryExpression: ...
    @overload
    @staticmethod
    def DebugInfo(document: SymbolDocumentInfo, startLine: int, startColumn: int, endLine: int, endColumn: int) -> DebugInfoExpression: ...
    @overload
    @staticmethod
    def Decrement(expression: Expression) -> UnaryExpression: ...
    @overload
    @staticmethod
    def Decrement(expression: Expression, method: Reflection.MethodInfo) -> UnaryExpression: ...
    @overload
    @staticmethod
    def Default(type_: System.Type) -> DefaultExpression: ...
    @overload
    @staticmethod
    def Divide(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def Divide(left: Expression, right: Expression, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def DivideAssign(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def DivideAssign(left: Expression, right: Expression, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def DivideAssign(left: Expression, right: Expression, method: Reflection.MethodInfo, conversion: LambdaExpression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def Dynamic(binder: CompilerServices.CallSiteBinder, returnType: System.Type, arguments: System.Array[Expression]) -> DynamicExpression: ...
    @overload
    @staticmethod
    def Dynamic(binder: CompilerServices.CallSiteBinder, returnType: System.Type, arguments: Generic.IEnumerable) -> DynamicExpression: ...
    @overload
    @staticmethod
    def Dynamic(binder: CompilerServices.CallSiteBinder, returnType: System.Type, arg0: Expression) -> DynamicExpression: ...
    @overload
    @staticmethod
    def Dynamic(binder: CompilerServices.CallSiteBinder, returnType: System.Type, arg0: Expression, arg1: Expression) -> DynamicExpression: ...
    @overload
    @staticmethod
    def Dynamic(binder: CompilerServices.CallSiteBinder, returnType: System.Type, arg0: Expression, arg1: Expression, arg2: Expression) -> DynamicExpression: ...
    @overload
    @staticmethod
    def Dynamic(binder: CompilerServices.CallSiteBinder, returnType: System.Type, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression) -> DynamicExpression: ...
    @overload
    @staticmethod
    def ElementInit(addMethod: Reflection.MethodInfo, arguments: System.Array[Expression]) -> ElementInit: ...
    @overload
    @staticmethod
    def ElementInit(addMethod: Reflection.MethodInfo, arguments: Generic.IEnumerable) -> ElementInit: ...
    @overload
    @staticmethod
    def Empty() -> DefaultExpression: ...
    @overload
    @staticmethod
    def Equal(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def Equal(left: Expression, right: Expression, liftToNull: bool, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def ExclusiveOr(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def ExclusiveOr(left: Expression, right: Expression, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def ExclusiveOrAssign(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def ExclusiveOrAssign(left: Expression, right: Expression, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def ExclusiveOrAssign(left: Expression, right: Expression, method: Reflection.MethodInfo, conversion: LambdaExpression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def Field(expression: Expression, fieldName: str) -> MemberExpression: ...
    @overload
    @staticmethod
    def Field(expression: Expression, field: Reflection.FieldInfo) -> MemberExpression: ...
    @overload
    @staticmethod
    def Field(expression: Expression, type_: System.Type, fieldName: str) -> MemberExpression: ...
    @property
    def CanReduce(self) -> bool: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Type(self) -> System.Type: ...
    @overload
    @staticmethod
    def GetActionType(typeArgs: System.System.Array[System.Type]) -> System.Type: ...
    @overload
    @staticmethod
    def GetDelegateType(typeArgs: System.System.Array[System.Type]) -> System.Type: ...
    @overload
    @staticmethod
    def GetFuncType(typeArgs: System.System.Array[System.Type]) -> System.Type: ...
    @overload
    @staticmethod
    def Goto(target: LabelTarget) -> GotoExpression: ...
    @overload
    @staticmethod
    def Goto(target: LabelTarget, type_: System.Type) -> GotoExpression: ...
    @overload
    @staticmethod
    def Goto(target: LabelTarget, value: Expression) -> GotoExpression: ...
    @overload
    @staticmethod
    def Goto(target: LabelTarget, value: Expression, type_: System.Type) -> GotoExpression: ...
    @overload
    @staticmethod
    def GreaterThan(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def GreaterThan(left: Expression, right: Expression, liftToNull: bool, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def GreaterThanOrEqual(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def GreaterThanOrEqual(left: Expression, right: Expression, liftToNull: bool, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def IfThen(test: Expression, ifTrue: Expression) -> ConditionalExpression: ...
    @overload
    @staticmethod
    def IfThenElse(test: Expression, ifTrue: Expression, ifFalse: Expression) -> ConditionalExpression: ...
    @overload
    @staticmethod
    def Increment(expression: Expression) -> UnaryExpression: ...
    @overload
    @staticmethod
    def Increment(expression: Expression, method: Reflection.MethodInfo) -> UnaryExpression: ...
    @overload
    @staticmethod
    def Invoke(expression: Expression, arguments: System.Array[Expression]) -> InvocationExpression: ...
    @overload
    @staticmethod
    def Invoke(expression: Expression, arguments: Generic.IEnumerable) -> InvocationExpression: ...
    @overload
    @staticmethod
    def IsFalse(expression: Expression) -> UnaryExpression: ...
    @overload
    @staticmethod
    def IsFalse(expression: Expression, method: Reflection.MethodInfo) -> UnaryExpression: ...
    @overload
    @staticmethod
    def IsTrue(expression: Expression) -> UnaryExpression: ...
    @overload
    @staticmethod
    def IsTrue(expression: Expression, method: Reflection.MethodInfo) -> UnaryExpression: ...
    @overload
    @staticmethod
    def Label() -> LabelTarget: ...
    @overload
    @staticmethod
    def Label(target: LabelTarget) -> LabelExpression: ...
    @overload
    @staticmethod
    def Label(name: str) -> LabelTarget: ...
    @overload
    @staticmethod
    def Label(type_: System.Type) -> LabelTarget: ...
    @overload
    @staticmethod
    def Label(target: LabelTarget, defaultValue: Expression) -> LabelExpression: ...
    @overload
    @staticmethod
    def Label(type_: System.Type, name: str) -> LabelTarget: ...
    @overload
    @staticmethod
    def Lambda(body: Expression, parameters: System.Array[ParameterExpression]) -> Expression: ...
    @overload
    @staticmethod
    def Lambda(body: Expression, parameters: Generic.IEnumerable) -> Expression: ...
    @overload
    @staticmethod
    def Lambda(body: Expression, parameters: System.Array[ParameterExpression]) -> LambdaExpression: ...
    @overload
    @staticmethod
    def Lambda(body: Expression, parameters: Generic.IEnumerable) -> LambdaExpression: ...
    @overload
    @staticmethod
    def Lambda(body: Expression, name: str, parameters: Generic.IEnumerable) -> Expression: ...
    @overload
    @staticmethod
    def Lambda(body: Expression, tailCall: bool, parameters: System.Array[ParameterExpression]) -> LambdaExpression: ...
    @overload
    @staticmethod
    def Lambda(body: Expression, tailCall: bool, parameters: Generic.IEnumerable) -> LambdaExpression: ...
    @overload
    @staticmethod
    def Lambda(delegateType: System.Type, body: Expression, parameters: System.Array[ParameterExpression]) -> LambdaExpression: ...
    @overload
    @staticmethod
    def Lambda(delegateType: System.Type, body: Expression, parameters: Generic.IEnumerable) -> LambdaExpression: ...
    @overload
    @staticmethod
    def Lambda(body: Expression, name: str, parameters: Generic.IEnumerable) -> LambdaExpression: ...
    @overload
    @staticmethod
    def Lambda(body: Expression, tailCall: bool, parameters: System.Array[ParameterExpression]) -> Expression: ...
    @overload
    @staticmethod
    def Lambda(body: Expression, tailCall: bool, parameters: Generic.IEnumerable) -> Expression: ...
    @overload
    @staticmethod
    def Lambda(delegateType: System.Type, body: Expression, tailCall: bool, parameters: System.Array[ParameterExpression]) -> LambdaExpression: ...
    @overload
    @staticmethod
    def Lambda(delegateType: System.Type, body: Expression, tailCall: bool, parameters: Generic.IEnumerable) -> LambdaExpression: ...
    @overload
    @staticmethod
    def Lambda(body: Expression, name: str, tailCall: bool, parameters: Generic.IEnumerable) -> LambdaExpression: ...
    @overload
    @staticmethod
    def Lambda(delegateType: System.Type, body: Expression, name: str, parameters: Generic.IEnumerable) -> LambdaExpression: ...
    @overload
    @staticmethod
    def Lambda(body: Expression, name: str, tailCall: bool, parameters: Generic.IEnumerable) -> Expression: ...
    @overload
    @staticmethod
    def Lambda(delegateType: System.Type, body: Expression, name: str, tailCall: bool, parameters: Generic.IEnumerable) -> LambdaExpression: ...
    @overload
    @staticmethod
    def LeftShift(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def LeftShift(left: Expression, right: Expression, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def LeftShiftAssign(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def LeftShiftAssign(left: Expression, right: Expression, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def LeftShiftAssign(left: Expression, right: Expression, method: Reflection.MethodInfo, conversion: LambdaExpression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def LessThan(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def LessThan(left: Expression, right: Expression, liftToNull: bool, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def LessThanOrEqual(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def LessThanOrEqual(left: Expression, right: Expression, liftToNull: bool, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def ListBind(propertyAccessor: Reflection.MethodInfo, initializers: System.Array[ElementInit]) -> MemberListBinding: ...
    @overload
    @staticmethod
    def ListBind(member: Reflection.MemberInfo, initializers: Generic.IEnumerable) -> MemberListBinding: ...
    @overload
    @staticmethod
    def ListBind(propertyAccessor: Reflection.MethodInfo, initializers: Generic.IEnumerable) -> MemberListBinding: ...
    @overload
    @staticmethod
    def ListBind(member: Reflection.MemberInfo, initializers: System.Array[ElementInit]) -> MemberListBinding: ...
    @overload
    @staticmethod
    def ListInit(newExpression: NewExpression, initializers: Generic.IEnumerable) -> ListInitExpression: ...
    @overload
    @staticmethod
    def ListInit(newExpression: NewExpression, initializers: System.Array[Expression]) -> ListInitExpression: ...
    @overload
    @staticmethod
    def ListInit(newExpression: NewExpression, initializers: System.Array[ElementInit]) -> ListInitExpression: ...
    @overload
    @staticmethod
    def ListInit(newExpression: NewExpression, initializers: Generic.IEnumerable) -> ListInitExpression: ...
    @overload
    @staticmethod
    def ListInit(newExpression: NewExpression, addMethod: Reflection.MethodInfo, initializers: System.Array[Expression]) -> ListInitExpression: ...
    @overload
    @staticmethod
    def ListInit(newExpression: NewExpression, addMethod: Reflection.MethodInfo, initializers: Generic.IEnumerable) -> ListInitExpression: ...
    @overload
    @staticmethod
    def Loop(body: Expression) -> LoopExpression: ...
    @overload
    @staticmethod
    def Loop(body: Expression, break_: LabelTarget) -> LoopExpression: ...
    @overload
    @staticmethod
    def Loop(body: Expression, break_: LabelTarget, continue_: LabelTarget) -> LoopExpression: ...
    @overload
    @staticmethod
    def MakeBinary(binaryType: ExpressionType, left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def MakeBinary(binaryType: ExpressionType, left: Expression, right: Expression, liftToNull: bool, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def MakeBinary(binaryType: ExpressionType, left: Expression, right: Expression, liftToNull: bool, method: Reflection.MethodInfo, conversion: LambdaExpression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def MakeCatchBlock(type_: System.Type, variable: ParameterExpression, body: Expression, filter_: Expression) -> CatchBlock: ...
    @overload
    @staticmethod
    def MakeDynamic(delegateType: System.Type, binder: CompilerServices.CallSiteBinder, arguments: Generic.IEnumerable) -> DynamicExpression: ...
    @overload
    @staticmethod
    def MakeDynamic(delegateType: System.Type, binder: CompilerServices.CallSiteBinder, arg0: Expression) -> DynamicExpression: ...
    @overload
    @staticmethod
    def MakeDynamic(delegateType: System.Type, binder: CompilerServices.CallSiteBinder, arguments: System.Array[Expression]) -> DynamicExpression: ...
    @overload
    @staticmethod
    def MakeDynamic(delegateType: System.Type, binder: CompilerServices.CallSiteBinder, arg0: Expression, arg1: Expression) -> DynamicExpression: ...
    @overload
    @staticmethod
    def MakeDynamic(delegateType: System.Type, binder: CompilerServices.CallSiteBinder, arg0: Expression, arg1: Expression, arg2: Expression) -> DynamicExpression: ...
    @overload
    @staticmethod
    def MakeDynamic(delegateType: System.Type, binder: CompilerServices.CallSiteBinder, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression) -> DynamicExpression: ...
    @overload
    @staticmethod
    def MakeGoto(kind: GotoExpressionKind, target: LabelTarget, value: Expression, type_: System.Type) -> GotoExpression: ...
    @overload
    @staticmethod
    def MakeIndex(instance: Expression, indexer: Reflection.PropertyInfo, arguments: Generic.IEnumerable) -> IndexExpression: ...
    @overload
    @staticmethod
    def MakeMemberAccess(expression: Expression, member: Reflection.MemberInfo) -> MemberExpression: ...
    @overload
    @staticmethod
    def MakeTry(type_: System.Type, body: Expression, finally_: Expression, fault: Expression, handlers: Generic.IEnumerable) -> TryExpression: ...
    @overload
    @staticmethod
    def MakeUnary(unaryType: ExpressionType, operand: Expression, type_: System.Type) -> UnaryExpression: ...
    @overload
    @staticmethod
    def MakeUnary(unaryType: ExpressionType, operand: Expression, type_: System.Type, method: Reflection.MethodInfo) -> UnaryExpression: ...
    @overload
    @staticmethod
    def MemberBind(propertyAccessor: Reflection.MethodInfo, bindings: System.Array[MemberBinding]) -> MemberMemberBinding: ...
    @overload
    @staticmethod
    def MemberBind(propertyAccessor: Reflection.MethodInfo, bindings: Generic.IEnumerable) -> MemberMemberBinding: ...
    @overload
    @staticmethod
    def MemberBind(member: Reflection.MemberInfo, bindings: Generic.IEnumerable) -> MemberMemberBinding: ...
    @overload
    @staticmethod
    def MemberBind(member: Reflection.MemberInfo, bindings: System.Array[MemberBinding]) -> MemberMemberBinding: ...
    @overload
    @staticmethod
    def MemberInit(newExpression: NewExpression, bindings: System.Array[MemberBinding]) -> MemberInitExpression: ...
    @overload
    @staticmethod
    def MemberInit(newExpression: NewExpression, bindings: Generic.IEnumerable) -> MemberInitExpression: ...
    @overload
    @staticmethod
    def Modulo(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def Modulo(left: Expression, right: Expression, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def ModuloAssign(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def ModuloAssign(left: Expression, right: Expression, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def ModuloAssign(left: Expression, right: Expression, method: Reflection.MethodInfo, conversion: LambdaExpression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def Multiply(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def Multiply(left: Expression, right: Expression, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def MultiplyAssign(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def MultiplyAssign(left: Expression, right: Expression, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def MultiplyAssign(left: Expression, right: Expression, method: Reflection.MethodInfo, conversion: LambdaExpression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def MultiplyAssignChecked(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def MultiplyAssignChecked(left: Expression, right: Expression, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def MultiplyAssignChecked(left: Expression, right: Expression, method: Reflection.MethodInfo, conversion: LambdaExpression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def MultiplyChecked(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def MultiplyChecked(left: Expression, right: Expression, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def Negate(expression: Expression) -> UnaryExpression: ...
    @overload
    @staticmethod
    def Negate(expression: Expression, method: Reflection.MethodInfo) -> UnaryExpression: ...
    @overload
    @staticmethod
    def NegateChecked(expression: Expression) -> UnaryExpression: ...
    @overload
    @staticmethod
    def NegateChecked(expression: Expression, method: Reflection.MethodInfo) -> UnaryExpression: ...
    @overload
    @staticmethod
    def New(constructor: Reflection.ConstructorInfo) -> NewExpression: ...
    @overload
    @staticmethod
    def New(type_: System.Type) -> NewExpression: ...
    @overload
    @staticmethod
    def New(constructor: Reflection.ConstructorInfo, arguments: Generic.IEnumerable) -> NewExpression: ...
    @overload
    @staticmethod
    def New(constructor: Reflection.ConstructorInfo, arguments: System.Array[Expression]) -> NewExpression: ...
    @overload
    @staticmethod
    def New(constructor: Reflection.ConstructorInfo, arguments: Generic.IEnumerable, members: Generic.IEnumerable) -> NewExpression: ...
    @overload
    @staticmethod
    def New(constructor: Reflection.ConstructorInfo, arguments: Generic.IEnumerable, members: Reflection.System.Array[Reflection.MemberInfo]) -> NewExpression: ...
    @overload
    @staticmethod
    def NewArrayBounds(type_: System.Type, bounds: System.Array[Expression]) -> NewArrayExpression: ...
    @overload
    @staticmethod
    def NewArrayBounds(type_: System.Type, bounds: Generic.IEnumerable) -> NewArrayExpression: ...
    @overload
    @staticmethod
    def NewArrayInit(type_: System.Type, initializers: Generic.IEnumerable) -> NewArrayExpression: ...
    @overload
    @staticmethod
    def NewArrayInit(type_: System.Type, initializers: System.Array[Expression]) -> NewArrayExpression: ...
    @overload
    @staticmethod
    def Not(expression: Expression) -> UnaryExpression: ...
    @overload
    @staticmethod
    def Not(expression: Expression, method: Reflection.MethodInfo) -> UnaryExpression: ...
    @overload
    @staticmethod
    def NotEqual(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def NotEqual(left: Expression, right: Expression, liftToNull: bool, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def OnesComplement(expression: Expression) -> UnaryExpression: ...
    @overload
    @staticmethod
    def OnesComplement(expression: Expression, method: Reflection.MethodInfo) -> UnaryExpression: ...
    @overload
    @staticmethod
    def Or(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def Or(left: Expression, right: Expression, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def OrAssign(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def OrAssign(left: Expression, right: Expression, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def OrAssign(left: Expression, right: Expression, method: Reflection.MethodInfo, conversion: LambdaExpression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def OrElse(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def OrElse(left: Expression, right: Expression, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def Parameter(type_: System.Type) -> ParameterExpression: ...
    @overload
    @staticmethod
    def Parameter(type_: System.Type, name: str) -> ParameterExpression: ...
    @overload
    @staticmethod
    def PostDecrementAssign(expression: Expression) -> UnaryExpression: ...
    @overload
    @staticmethod
    def PostDecrementAssign(expression: Expression, method: Reflection.MethodInfo) -> UnaryExpression: ...
    @overload
    @staticmethod
    def PostIncrementAssign(expression: Expression) -> UnaryExpression: ...
    @overload
    @staticmethod
    def PostIncrementAssign(expression: Expression, method: Reflection.MethodInfo) -> UnaryExpression: ...
    @overload
    @staticmethod
    def Power(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def Power(left: Expression, right: Expression, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def PowerAssign(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def PowerAssign(left: Expression, right: Expression, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def PowerAssign(left: Expression, right: Expression, method: Reflection.MethodInfo, conversion: LambdaExpression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def PreDecrementAssign(expression: Expression) -> UnaryExpression: ...
    @overload
    @staticmethod
    def PreDecrementAssign(expression: Expression, method: Reflection.MethodInfo) -> UnaryExpression: ...
    @overload
    @staticmethod
    def PreIncrementAssign(expression: Expression) -> UnaryExpression: ...
    @overload
    @staticmethod
    def PreIncrementAssign(expression: Expression, method: Reflection.MethodInfo) -> UnaryExpression: ...
    @overload
    @staticmethod
    def Property(expression: Expression, property_: Reflection.PropertyInfo) -> MemberExpression: ...
    @overload
    @staticmethod
    def Property(expression: Expression, propertyName: str) -> MemberExpression: ...
    @overload
    @staticmethod
    def Property(expression: Expression, propertyAccessor: Reflection.MethodInfo) -> MemberExpression: ...
    @overload
    @staticmethod
    def Property(instance: Expression, propertyName: str, arguments: System.Array[Expression]) -> IndexExpression: ...
    @overload
    @staticmethod
    def Property(instance: Expression, indexer: Reflection.PropertyInfo, arguments: System.Array[Expression]) -> IndexExpression: ...
    @overload
    @staticmethod
    def Property(instance: Expression, indexer: Reflection.PropertyInfo, arguments: Generic.IEnumerable) -> IndexExpression: ...
    @overload
    @staticmethod
    def Property(expression: Expression, type_: System.Type, propertyName: str) -> MemberExpression: ...
    @overload
    @staticmethod
    def PropertyOrField(expression: Expression, propertyOrFieldName: str) -> MemberExpression: ...
    @overload
    @staticmethod
    def Quote(expression: Expression) -> UnaryExpression: ...
    @overload
    def Reduce() -> Expression: ...
    @overload
    def ReduceAndCheck() -> Expression: ...
    @overload
    def ReduceExtensions() -> Expression: ...
    @overload
    @staticmethod
    def ReferenceEqual(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def ReferenceNotEqual(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def Rethrow() -> UnaryExpression: ...
    @overload
    @staticmethod
    def Rethrow(type_: System.Type) -> UnaryExpression: ...
    @overload
    @staticmethod
    def Return(target: LabelTarget) -> GotoExpression: ...
    @overload
    @staticmethod
    def Return(target: LabelTarget, value: Expression) -> GotoExpression: ...
    @overload
    @staticmethod
    def Return(target: LabelTarget, type_: System.Type) -> GotoExpression: ...
    @overload
    @staticmethod
    def Return(target: LabelTarget, value: Expression, type_: System.Type) -> GotoExpression: ...
    @overload
    @staticmethod
    def RightShift(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def RightShift(left: Expression, right: Expression, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def RightShiftAssign(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def RightShiftAssign(left: Expression, right: Expression, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def RightShiftAssign(left: Expression, right: Expression, method: Reflection.MethodInfo, conversion: LambdaExpression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def RuntimeVariables(variables: System.Array[ParameterExpression]) -> RuntimeVariablesExpression: ...
    @overload
    @staticmethod
    def RuntimeVariables(variables: Generic.IEnumerable) -> RuntimeVariablesExpression: ...
    @overload
    @staticmethod
    def Subtract(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def Subtract(left: Expression, right: Expression, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def SubtractAssign(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def SubtractAssign(left: Expression, right: Expression, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def SubtractAssign(left: Expression, right: Expression, method: Reflection.MethodInfo, conversion: LambdaExpression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def SubtractAssignChecked(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def SubtractAssignChecked(left: Expression, right: Expression, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def SubtractAssignChecked(left: Expression, right: Expression, method: Reflection.MethodInfo, conversion: LambdaExpression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def SubtractChecked(left: Expression, right: Expression) -> BinaryExpression: ...
    @overload
    @staticmethod
    def SubtractChecked(left: Expression, right: Expression, method: Reflection.MethodInfo) -> BinaryExpression: ...
    @overload
    @staticmethod
    def Switch(switchValue: Expression, cases: System.Array[SwitchCase]) -> SwitchExpression: ...
    @overload
    @staticmethod
    def Switch(switchValue: Expression, defaultBody: Expression, cases: System.Array[SwitchCase]) -> SwitchExpression: ...
    @overload
    @staticmethod
    def Switch(switchValue: Expression, defaultBody: Expression, comparison: Reflection.MethodInfo, cases: System.Array[SwitchCase]) -> SwitchExpression: ...
    @overload
    @staticmethod
    def Switch(switchValue: Expression, defaultBody: Expression, comparison: Reflection.MethodInfo, cases: Generic.IEnumerable) -> SwitchExpression: ...
    @overload
    @staticmethod
    def Switch(type_: System.Type, switchValue: Expression, defaultBody: Expression, comparison: Reflection.MethodInfo, cases: System.Array[SwitchCase]) -> SwitchExpression: ...
    @overload
    @staticmethod
    def Switch(type_: System.Type, switchValue: Expression, defaultBody: Expression, comparison: Reflection.MethodInfo, cases: Generic.IEnumerable) -> SwitchExpression: ...
    @overload
    @staticmethod
    def SwitchCase(body: Expression, testValues: System.Array[Expression]) -> SwitchCase: ...
    @overload
    @staticmethod
    def SwitchCase(body: Expression, testValues: Generic.IEnumerable) -> SwitchCase: ...
    @overload
    @staticmethod
    def SymbolDocument(fileName: str) -> SymbolDocumentInfo: ...
    @overload
    @staticmethod
    def SymbolDocument(fileName: str, language: System.Guid) -> SymbolDocumentInfo: ...
    @overload
    @staticmethod
    def SymbolDocument(fileName: str, language: System.Guid, languageVendor: System.Guid) -> SymbolDocumentInfo: ...
    @overload
    @staticmethod
    def SymbolDocument(fileName: str, language: System.Guid, languageVendor: System.Guid, documentType: System.Guid) -> SymbolDocumentInfo: ...
    @overload
    @staticmethod
    def Throw(value: Expression) -> UnaryExpression: ...
    @overload
    @staticmethod
    def Throw(value: Expression, type_: System.Type) -> UnaryExpression: ...
    @overload
    def ToString() -> str: ...
    @overload
    @staticmethod
    def TryCatch(body: Expression, handlers: System.Array[CatchBlock]) -> TryExpression: ...
    @overload
    @staticmethod
    def TryCatchFinally(body: Expression, finally_: Expression, handlers: System.Array[CatchBlock]) -> TryExpression: ...
    @overload
    @staticmethod
    def TryFault(body: Expression, fault: Expression) -> TryExpression: ...
    @overload
    @staticmethod
    def TryFinally(body: Expression, finally_: Expression) -> TryExpression: ...
    @overload
    @staticmethod
    def TryGetActionType(typeArgs: System.System.Array[System.Type]) -> (bool, System.Type): ...
    @overload
    @staticmethod
    def TryGetFuncType(typeArgs: System.System.Array[System.Type]) -> (bool, System.Type): ...
    @overload
    @staticmethod
    def TypeAs(expression: Expression, type_: System.Type) -> UnaryExpression: ...
    @overload
    @staticmethod
    def TypeEqual(expression: Expression, type_: System.Type) -> TypeBinaryExpression: ...
    @overload
    @staticmethod
    def TypeIs(expression: Expression, type_: System.Type) -> TypeBinaryExpression: ...
    @overload
    @staticmethod
    def UnaryPlus(expression: Expression) -> UnaryExpression: ...
    @overload
    @staticmethod
    def UnaryPlus(expression: Expression, method: Reflection.MethodInfo) -> UnaryExpression: ...
    @overload
    @staticmethod
    def Unbox(expression: Expression, type_: System.Type) -> UnaryExpression: ...
    @overload
    @staticmethod
    def Variable(type_: System.Type) -> ParameterExpression: ...
    @overload
    @staticmethod
    def Variable(type_: System.Type, name: str) -> ParameterExpression: ...

class BlockExpression(Expression):
    """    """
    @property
    def Expressions(self) -> ObjectModel.ReadOnlyCollection: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Result(self) -> Expression: ...
    @property
    def Type(self) -> System.Type: ...
    @property
    def Variables(self) -> ObjectModel.ReadOnlyCollection: ...
    @overload
    def Update(self, variables: Generic.IEnumerable, expressions: Generic.IEnumerable) -> BlockExpression: ...

class CatchBlock(object):
    """    """
    @property
    def Body(self) -> Expression: ...
    @property
    def Filter(self) -> Expression: ...
    @property
    def Test(self) -> System.Type: ...
    @property
    def Variable(self) -> ParameterExpression: ...
    @overload
    def ToString() -> str: ...
    @overload
    def Update(self, variable: ParameterExpression, filter_: Expression, body: Expression) -> CatchBlock: ...

class ConditionalExpression(Expression):
    """    """
    @property
    def IfFalse(self) -> Expression: ...
    @property
    def IfTrue(self) -> Expression: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Test(self) -> Expression: ...
    @property
    def Type(self) -> System.Type: ...
    @overload
    def Update(self, test: Expression, ifTrue: Expression, ifFalse: Expression) -> ConditionalExpression: ...

class ConstantExpression(Expression):
    """    """
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Type(self) -> System.Type: ...
    @property
    def Value(self) -> object: ...

class DebugInfoExpression(Expression):
    """    """
    @property
    def Document(self) -> SymbolDocumentInfo: ...
    @property
    def EndColumn(self) -> int: ...
    @property
    def EndLine(self) -> int: ...
    @property
    def IsClear(self) -> bool: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def StartColumn(self) -> int: ...
    @property
    def StartLine(self) -> int: ...
    @property
    def Type(self) -> System.Type: ...

class DefaultExpression(Expression):
    """    """
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Type(self) -> System.Type: ...

class ElementInit(object):
    """    """
    @property
    def AddMethod(self) -> Reflection.MethodInfo: ...
    @property
    def ArgumentCount(self) -> int: ...
    @property
    def Arguments(self) -> ObjectModel.ReadOnlyCollection: ...
    @overload
    def GetArgument(self, index: int) -> Expression: ...
    @overload
    def ToString() -> str: ...
    @overload
    def Update(self, arguments: Generic.IEnumerable) -> ElementInit: ...

class ExpressionType(enum.Enum):
    Add = 0
    AddChecked = 1
    And = 2
    AndAlso = 3
    ArrayLength = 4
    ArrayIndex = 5
    Call = 6
    Coalesce = 7
    Conditional = 8
    Constant = 9
    Convert = 10
    ConvertChecked = 11
    Divide = 12
    Equal = 13
    ExclusiveOr = 14
    GreaterThan = 15
    GreaterThanOrEqual = 16
    Invoke = 17
    Lambda = 18
    LeftShift = 19
    LessThan = 20
    LessThanOrEqual = 21
    ListInit = 22
    MemberAccess = 23
    MemberInit = 24
    Modulo = 25
    Multiply = 26
    MultiplyChecked = 27
    Negate = 28
    UnaryPlus = 29
    NegateChecked = 30
    New = 31
    NewArrayInit = 32
    NewArrayBounds = 33
    Not = 34
    NotEqual = 35
    Or = 36
    OrElse = 37
    Parameter = 38
    Power = 39
    Quote = 40
    RightShift = 41
    Subtract = 42
    SubtractChecked = 43
    TypeAs = 44
    TypeIs = 45
    Assign = 46
    Block = 47
    DebugInfo = 48
    Decrement = 49
    Dynamic = 50
    Default = 51
    Extension = 52
    Goto = 53
    Increment = 54
    Index = 55
    Label = 56
    RuntimeVariables = 57
    Loop = 58
    Switch = 59
    Throw = 60
    Try = 61
    Unbox = 62
    AddAssign = 63
    AndAssign = 64
    DivideAssign = 65
    ExclusiveOrAssign = 66
    LeftShiftAssign = 67
    ModuloAssign = 68
    MultiplyAssign = 69
    OrAssign = 70
    PowerAssign = 71
    RightShiftAssign = 72
    SubtractAssign = 73
    AddAssignChecked = 74
    MultiplyAssignChecked = 75
    SubtractAssignChecked = 76
    PreIncrementAssign = 77
    PreDecrementAssign = 78
    PostIncrementAssign = 79
    PostDecrementAssign = 80
    TypeEqual = 81
    OnesComplement = 82
    IsTrue = 83
    IsFalse = 84

class ExpressionVisitor(object):
    """    """
    @overload
    def Visit(self, node: Expression) -> Expression: ...
    @overload
    def Visit(self, nodes: ObjectModel.ReadOnlyCollection) -> ObjectModel.ReadOnlyCollection: ...
    @overload
    @staticmethod
    def Visit(nodes: ObjectModel.ReadOnlyCollection, elementVisitor: System.Func) -> ObjectModel.ReadOnlyCollection: ...
    @overload
    def VisitAndConvert(self, node: T, callerName: str) -> T: ...
    @overload
    def VisitAndConvert(self, nodes: ObjectModel.ReadOnlyCollection, callerName: str) -> ObjectModel.ReadOnlyCollection: ...

class GotoExpressionKind(enum.Enum):
    Goto = 0
    Return = 1
    Break = 2
    Continue = 3

class GotoExpression(Expression):
    """    """
    @property
    def Kind(self) -> GotoExpressionKind: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Target(self) -> LabelTarget: ...
    @property
    def Type(self) -> System.Type: ...
    @property
    def Value(self) -> Expression: ...
    @overload
    def Update(self, target: LabelTarget, value: Expression) -> GotoExpression: ...

class IArgumentProvider:
    """    """
    @property
    def ArgumentCount(self) -> int: ...
    @overload
    def GetArgument(self, index: int) -> Expression: ...

class IDynamicExpression:
    """    """
    @overload
    def CreateCallSite() -> object: ...
    @property
    def DelegateType(self) -> System.Type: ...
    @overload
    def Rewrite(self, args: System.Array[Expression]) -> Expression: ...

class IndexExpression(Expression):
    """    """
    @property
    def ArgumentCount(self) -> int: ...
    @property
    def Arguments(self) -> ObjectModel.ReadOnlyCollection: ...
    @property
    def Indexer(self) -> Reflection.PropertyInfo: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Object(self) -> Expression: ...
    @property
    def Type(self) -> System.Type: ...
    @overload
    def GetArgument(self, index: int) -> Expression: ...
    @overload
    def Update(self, object_: Expression, arguments: Generic.IEnumerable) -> IndexExpression: ...

class InvocationExpression(Expression):
    """    """
    @property
    def ArgumentCount(self) -> int: ...
    @property
    def Arguments(self) -> ObjectModel.ReadOnlyCollection: ...
    @property
    def Expression(self) -> Expression: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Type(self) -> System.Type: ...
    @overload
    def GetArgument(self, index: int) -> Expression: ...
    @overload
    def Update(self, expression: Expression, arguments: Generic.IEnumerable) -> InvocationExpression: ...

class LabelExpression(Expression):
    """    """
    @property
    def DefaultValue(self) -> Expression: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Target(self) -> LabelTarget: ...
    @property
    def Type(self) -> System.Type: ...
    @overload
    def Update(self, target: LabelTarget, defaultValue: Expression) -> LabelExpression: ...

class LabelTarget(object):
    """    """
    @property
    def Name(self) -> str: ...
    @property
    def Type(self) -> System.Type: ...
    @overload
    def ToString() -> str: ...

class LambdaExpression(Expression):
    """    """
    @overload
    def Compile() -> System.Delegate: ...
    @overload
    def Compile(self, debugInfoGenerator: CompilerServices.DebugInfoGenerator) -> System.Delegate: ...
    @overload
    def Compile(self, preferInterpretation: bool) -> System.Delegate: ...
    @property
    def Body(self) -> Expression: ...
    @property
    def CanCompileToIL(self) -> bool: ...
    @property
    def CanInterpret(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Parameters(self) -> ObjectModel.ReadOnlyCollection: ...
    @property
    def ReturnType(self) -> System.Type: ...
    @property
    def TailCall(self) -> bool: ...
    @property
    def Type(self) -> System.Type: ...

class Expression(LambdaExpression):
    """    Expression[TDelegate]
    """
    @overload
    def Compile() -> TDelegate: ...
    @overload
    def Compile(self, preferInterpretation: bool) -> TDelegate: ...
    @overload
    def Compile(self, debugInfoGenerator: CompilerServices.DebugInfoGenerator) -> TDelegate: ...
    @overload
    def Update(self, body: Expression, parameters: Generic.IEnumerable) -> Expression: ...

class ListInitExpression(Expression):
    """    """
    @property
    def CanReduce(self) -> bool: ...
    @property
    def Initializers(self) -> ObjectModel.ReadOnlyCollection: ...
    @property
    def NewExpression(self) -> NewExpression: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Type(self) -> System.Type: ...
    @overload
    def Reduce() -> Expression: ...
    @overload
    def Update(self, newExpression: NewExpression, initializers: Generic.IEnumerable) -> ListInitExpression: ...

class LoopExpression(Expression):
    """    """
    @property
    def Body(self) -> Expression: ...
    @property
    def BreakLabel(self) -> LabelTarget: ...
    @property
    def ContinueLabel(self) -> LabelTarget: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Type(self) -> System.Type: ...
    @overload
    def Update(self, breakLabel: LabelTarget, continueLabel: LabelTarget, body: Expression) -> LoopExpression: ...

class MemberAssignment(MemberBinding):
    """    """
    @property
    def Expression(self) -> Expression: ...
    @overload
    def Update(self, expression: Expression) -> MemberAssignment: ...

class MemberBindingType(enum.Enum):
    Assignment = 0
    MemberBinding = 1
    ListBinding = 2

class MemberBinding(object):
    """    """
    @property
    def BindingType(self) -> MemberBindingType: ...
    @property
    def Member(self) -> Reflection.MemberInfo: ...
    @overload
    def ToString() -> str: ...

class MemberExpression(Expression):
    """    """
    @property
    def Expression(self) -> Expression: ...
    @property
    def Member(self) -> Reflection.MemberInfo: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @overload
    def Update(self, expression: Expression) -> MemberExpression: ...

class MemberInitExpression(Expression):
    """    """
    @property
    def Bindings(self) -> ObjectModel.ReadOnlyCollection: ...
    @property
    def CanReduce(self) -> bool: ...
    @property
    def NewExpression(self) -> NewExpression: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Type(self) -> System.Type: ...
    @overload
    def Reduce() -> Expression: ...
    @overload
    def Update(self, newExpression: NewExpression, bindings: Generic.IEnumerable) -> MemberInitExpression: ...

class MemberListBinding(MemberBinding):
    """    """
    @property
    def Initializers(self) -> ObjectModel.ReadOnlyCollection: ...
    @overload
    def Update(self, initializers: Generic.IEnumerable) -> MemberListBinding: ...

class MemberMemberBinding(MemberBinding):
    """    """
    @property
    def Bindings(self) -> ObjectModel.ReadOnlyCollection: ...
    @overload
    def Update(self, bindings: Generic.IEnumerable) -> MemberMemberBinding: ...

class MethodCallExpression(Expression):
    """    """
    @property
    def ArgumentCount(self) -> int: ...
    @property
    def Arguments(self) -> ObjectModel.ReadOnlyCollection: ...
    @property
    def Method(self) -> Reflection.MethodInfo: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Object(self) -> Expression: ...
    @property
    def Type(self) -> System.Type: ...
    @overload
    def GetArgument(self, index: int) -> Expression: ...
    @overload
    def Update(self, object_: Expression, arguments: Generic.IEnumerable) -> MethodCallExpression: ...

class NewArrayExpression(Expression):
    """    """
    @property
    def Expressions(self) -> ObjectModel.ReadOnlyCollection: ...
    @property
    def Type(self) -> System.Type: ...
    @overload
    def Update(self, expressions: Generic.IEnumerable) -> NewArrayExpression: ...

class NewExpression(Expression):
    """    """
    @property
    def ArgumentCount(self) -> int: ...
    @property
    def Arguments(self) -> ObjectModel.ReadOnlyCollection: ...
    @property
    def Constructor(self) -> Reflection.ConstructorInfo: ...
    @property
    def Members(self) -> ObjectModel.ReadOnlyCollection: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Type(self) -> System.Type: ...
    @overload
    def GetArgument(self, index: int) -> Expression: ...
    @overload
    def Update(self, arguments: Generic.IEnumerable) -> NewExpression: ...

class ParameterExpression(Expression):
    """    """
    @property
    def IsByRef(self) -> bool: ...
    @property
    def Name(self) -> str: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Type(self) -> System.Type: ...

class RuntimeVariablesExpression(Expression):
    """    """
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Type(self) -> System.Type: ...
    @property
    def Variables(self) -> ObjectModel.ReadOnlyCollection: ...
    @overload
    def Update(self, variables: Generic.IEnumerable) -> RuntimeVariablesExpression: ...

class SwitchCase(object):
    """    """
    @property
    def Body(self) -> Expression: ...
    @property
    def TestValues(self) -> ObjectModel.ReadOnlyCollection: ...
    @overload
    def ToString() -> str: ...
    @overload
    def Update(self, testValues: Generic.IEnumerable, body: Expression) -> SwitchCase: ...

class SwitchExpression(Expression):
    """    """
    @property
    def Cases(self) -> ObjectModel.ReadOnlyCollection: ...
    @property
    def Comparison(self) -> Reflection.MethodInfo: ...
    @property
    def DefaultBody(self) -> Expression: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def SwitchValue(self) -> Expression: ...
    @property
    def Type(self) -> System.Type: ...
    @overload
    def Update(self, switchValue: Expression, cases: Generic.IEnumerable, defaultBody: Expression) -> SwitchExpression: ...

class SymbolDocumentInfo(object):
    """    """
    @property
    def DocumentType(self) -> System.Guid: ...
    @property
    def FileName(self) -> str: ...
    @property
    def Language(self) -> System.Guid: ...
    @property
    def LanguageVendor(self) -> System.Guid: ...

class TryExpression(Expression):
    """    """
    @property
    def Body(self) -> Expression: ...
    @property
    def Fault(self) -> Expression: ...
    @property
    def Finally(self) -> Expression: ...
    @property
    def Handlers(self) -> ObjectModel.ReadOnlyCollection: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Type(self) -> System.Type: ...
    @overload
    def Update(self, body: Expression, handlers: Generic.IEnumerable, finally_: Expression, fault: Expression) -> TryExpression: ...

class TypeBinaryExpression(Expression):
    """    """
    @property
    def Expression(self) -> Expression: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Type(self) -> System.Type: ...
    @property
    def TypeOperand(self) -> System.Type: ...
    @overload
    def Update(self, expression: Expression) -> TypeBinaryExpression: ...

class UnaryExpression(Expression):
    """    """
    @property
    def CanReduce(self) -> bool: ...
    @property
    def IsLifted(self) -> bool: ...
    @property
    def IsLiftedToNull(self) -> bool: ...
    @property
    def Method(self) -> Reflection.MethodInfo: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Operand(self) -> Expression: ...
    @property
    def Type(self) -> System.Type: ...
    @overload
    def Reduce() -> Expression: ...
    @overload
    def Update(self, operand: Expression) -> UnaryExpression: ...

class DynamicExpressionVisitor(ExpressionVisitor):
    """    """
    def __init__(self): ...

class DynamicExpression(Expression):
    """    """
    @overload
    @staticmethod
    def Dynamic(binder: CompilerServices.CallSiteBinder, returnType: System.Type, arg0: Expression) -> DynamicExpression: ...
    @overload
    @staticmethod
    def Dynamic(binder: CompilerServices.CallSiteBinder, returnType: System.Type, arguments: Generic.IEnumerable) -> DynamicExpression: ...
    @overload
    @staticmethod
    def Dynamic(binder: CompilerServices.CallSiteBinder, returnType: System.Type, arguments: System.Array[Expression]) -> DynamicExpression: ...
    @overload
    @staticmethod
    def Dynamic(binder: CompilerServices.CallSiteBinder, returnType: System.Type, arg0: Expression, arg1: Expression) -> DynamicExpression: ...
    @overload
    @staticmethod
    def Dynamic(binder: CompilerServices.CallSiteBinder, returnType: System.Type, arg0: Expression, arg1: Expression, arg2: Expression) -> DynamicExpression: ...
    @overload
    @staticmethod
    def Dynamic(binder: CompilerServices.CallSiteBinder, returnType: System.Type, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression) -> DynamicExpression: ...
    @property
    def Arguments(self) -> ObjectModel.ReadOnlyCollection: ...
    @property
    def Binder(self) -> CompilerServices.CallSiteBinder: ...
    @property
    def CanReduce(self) -> bool: ...
    @property
    def DelegateType(self) -> System.Type: ...
    @property
    def NodeType(self) -> ExpressionType: ...
    @property
    def Type(self) -> System.Type: ...
    @overload
    @staticmethod
    def MakeDynamic(delegateType: System.Type, binder: CompilerServices.CallSiteBinder, arguments: Generic.IEnumerable) -> DynamicExpression: ...
    @overload
    @staticmethod
    def MakeDynamic(delegateType: System.Type, binder: CompilerServices.CallSiteBinder, arguments: System.Array[Expression]) -> DynamicExpression: ...
    @overload
    @staticmethod
    def MakeDynamic(delegateType: System.Type, binder: CompilerServices.CallSiteBinder, arg0: Expression) -> DynamicExpression: ...
    @overload
    @staticmethod
    def MakeDynamic(delegateType: System.Type, binder: CompilerServices.CallSiteBinder, arg0: Expression, arg1: Expression) -> DynamicExpression: ...
    @overload
    @staticmethod
    def MakeDynamic(delegateType: System.Type, binder: CompilerServices.CallSiteBinder, arg0: Expression, arg1: Expression, arg2: Expression) -> DynamicExpression: ...
    @overload
    @staticmethod
    def MakeDynamic(delegateType: System.Type, binder: CompilerServices.CallSiteBinder, arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression) -> DynamicExpression: ...
    @overload
    def Reduce() -> Expression: ...
    @overload
    def Update(self, arguments: Generic.IEnumerable) -> DynamicExpression: ...

# endregion
