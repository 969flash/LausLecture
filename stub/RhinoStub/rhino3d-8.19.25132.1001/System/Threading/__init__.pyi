"""this file is auto-generated by rhinocode stubmaker. do not make changes"""

# region: Exports
__all__ = ["Tasks"]
# endregion

# region: Imports
from typing import overload
# endregion

# region: Exports
__all__ = ["BarrierPostPhaseException", "Barrier", "CountdownEvent", "HostExecutionContext", "HostExecutionContextManager", "LockCookie", "ReaderWriterLock"]
# endregion

# region: Imports
from System.Runtime import CompilerServices
from System.Runtime import ConstrainedExecution
from typing import overload
import System
# endregion

# region: Exports
__all__ = ["EventWaitHandleAcl", "MutexAcl", "SemaphoreAcl", "ThreadingAclExtensions"]
# endregion

# region: Imports
from System.Runtime import CompilerServices
from System.Security import AccessControl
from typing import overload
# endregion

# region: Exports
__all__ = ["Tasks", "Interlocked", "Monitor", "Overlapped", "SynchronizationContext", "Thread", "RegisteredWaitHandle", "ThreadPool", "WaitHandle", "AbandonedMutexException", "ApartmentState", "AsyncLocal", "AsyncLocalValueChangedArgs", "AutoResetEvent", "CancellationToken", "CancellationTokenRegistration", "CancellationTokenSource", "CompressedStack", "EventResetMode", "EventWaitHandle", "ContextCallback", "ExecutionContext", "AsyncFlowControl", "IOCompletionCallback", "IThreadPoolWorkItem", "LazyInitializer", "LazyThreadSafetyMode", "LockRecursionException", "ManualResetEvent", "ManualResetEventSlim", "Mutex", "NativeOverlapped", "ParameterizedThreadStart", "LockRecursionPolicy", "ReaderWriterLockSlim", "Semaphore", "SemaphoreFullException", "SemaphoreSlim", "SendOrPostCallback", "SpinLock", "SpinWait", "SynchronizationLockException", "ThreadAbortException", "ThreadExceptionEventArgs", "ThreadExceptionEventHandler", "ThreadInterruptedException", "ThreadLocal", "WaitCallback", "WaitOrTimerCallback", "ThreadPriority", "ThreadStart", "ThreadStartException", "ThreadState", "ThreadStateException", "Timeout", "PeriodicTimer", "TimerCallback", "Timer", "Volatile", "WaitHandleCannotBeOpenedException", "WaitHandleExtensions", "PreAllocatedOverlapped", "ThreadPoolBoundHandle"]
# endregion

# region: Imports
from Microsoft.Win32 import SafeHandles
from System import Globalization
from System.Collections import Generic
from System.Runtime import CompilerServices
from System.Runtime import ConstrainedExecution
from System.Runtime import InteropServices
from System.Runtime import Serialization
from System.Security import Principal
from System.Threading import Tasks
from typing import overload
import enum
import System
# endregion

# region: Exports
__all__ = ["Tasks"]
# endregion

# region: Imports
from typing import overload
# endregion

# region: System.Private.CoreLib, Version=7.0.0.0

class Interlocked(object):
    """    """
    @overload
    @staticmethod
    def Add(value: int) -> (int, int): ...
    @overload
    @staticmethod
    def Add(value: System.UInt32) -> (System.UInt32, System.UInt32): ...
    @overload
    @staticmethod
    def Add(value: System.UInt64) -> (System.UInt64, System.UInt64): ...
    @overload
    @staticmethod
    def Add(value: System.Int64) -> (System.Int64, System.Int64): ...
    @overload
    @staticmethod
    def And(value: System.UInt64) -> (System.UInt64, System.UInt64): ...
    @overload
    @staticmethod
    def And(value: int) -> (int, int): ...
    @overload
    @staticmethod
    def And(value: System.UInt32) -> (System.UInt32, System.UInt32): ...
    @overload
    @staticmethod
    def And(value: System.Int64) -> (System.Int64, System.Int64): ...
    @overload
    @staticmethod
    def CompareExchange(value: System.UInt64, comparand: System.UInt64) -> (System.UInt64, System.UInt64): ...
    @overload
    @staticmethod
    def CompareExchange(value: System.UInt32, comparand: System.UInt32) -> (System.UInt32, System.UInt32): ...
    @overload
    @staticmethod
    def CompareExchange(value: System.IntPtr, comparand: System.IntPtr) -> (System.IntPtr, System.IntPtr): ...
    @overload
    @staticmethod
    def CompareExchange(value: T, comparand: T) -> (T, T): ...
    @overload
    @staticmethod
    def CompareExchange(value: object, comparand: object) -> (object, object): ...
    @overload
    @staticmethod
    def CompareExchange(value: System.UIntPtr, comparand: System.UIntPtr) -> (System.UIntPtr, System.UIntPtr): ...
    @overload
    @staticmethod
    def CompareExchange(value: System.Single, comparand: System.Single) -> (System.Single, System.Single): ...
    @overload
    @staticmethod
    def CompareExchange(value: System.Int64, comparand: System.Int64) -> (System.Int64, System.Int64): ...
    @overload
    @staticmethod
    def CompareExchange(value: int, comparand: int) -> (int, int): ...
    @overload
    @staticmethod
    def CompareExchange(value: float, comparand: float) -> (float, float): ...
    @overload
    @staticmethod
    def Decrement() -> (int, int): ...
    @overload
    @staticmethod
    def Decrement() -> (System.Int64, System.Int64): ...
    @overload
    @staticmethod
    def Decrement() -> (System.UInt64, System.UInt64): ...
    @overload
    @staticmethod
    def Decrement() -> (System.UInt32, System.UInt32): ...
    @overload
    @staticmethod
    def Exchange(value: int) -> (int, int): ...
    @overload
    @staticmethod
    def Exchange(value: System.Single) -> (System.Single, System.Single): ...
    @overload
    @staticmethod
    def Exchange(value: float) -> (float, float): ...
    @overload
    @staticmethod
    def Exchange(value: System.UInt32) -> (System.UInt32, System.UInt32): ...
    @overload
    @staticmethod
    def Exchange(value: System.UInt64) -> (System.UInt64, System.UInt64): ...
    @overload
    @staticmethod
    def Exchange(value: System.IntPtr) -> (System.IntPtr, System.IntPtr): ...
    @overload
    @staticmethod
    def Exchange(value: System.UIntPtr) -> (System.UIntPtr, System.UIntPtr): ...
    @overload
    @staticmethod
    def Exchange(value: object) -> (object, object): ...
    @overload
    @staticmethod
    def Exchange(value: T) -> (T, T): ...
    @overload
    @staticmethod
    def Exchange(value: System.Int64) -> (System.Int64, System.Int64): ...
    @overload
    @staticmethod
    def Increment() -> (System.UInt32, System.UInt32): ...
    @overload
    @staticmethod
    def Increment() -> (System.Int64, System.Int64): ...
    @overload
    @staticmethod
    def Increment() -> (System.UInt64, System.UInt64): ...
    @overload
    @staticmethod
    def Increment() -> (int, int): ...
    @overload
    @staticmethod
    def MemoryBarrier() -> None: ...
    @overload
    @staticmethod
    def MemoryBarrierProcessWide() -> None: ...
    @overload
    @staticmethod
    def Or(value: int) -> (int, int): ...
    @overload
    @staticmethod
    def Or(value: System.UInt32) -> (System.UInt32, System.UInt32): ...
    @overload
    @staticmethod
    def Or(value: System.Int64) -> (System.Int64, System.Int64): ...
    @overload
    @staticmethod
    def Or(value: System.UInt64) -> (System.UInt64, System.UInt64): ...
    @overload
    @staticmethod
    def Read() -> (System.UInt64, System.UInt64): ...
    @overload
    @staticmethod
    def Read() -> (System.Int64, System.Int64): ...

class Monitor(object):
    """    """
    @overload
    @staticmethod
    def Enter(obj: object) -> None: ...
    @overload
    @staticmethod
    def Enter(obj: object) -> (bool): ...
    @overload
    @staticmethod
    def Exit(obj: object) -> None: ...
    @property
    def LockContentionCount(self) -> System.Int64: ...
    @overload
    @staticmethod
    def IsEntered(obj: object) -> bool: ...
    @overload
    @staticmethod
    def Pulse(obj: object) -> None: ...
    @overload
    @staticmethod
    def PulseAll(obj: object) -> None: ...
    @overload
    @staticmethod
    def TryEnter(obj: object) -> bool: ...
    @overload
    @staticmethod
    def TryEnter(obj: object) -> (bool): ...
    @overload
    @staticmethod
    def TryEnter(obj: object, timeout: System.TimeSpan) -> bool: ...
    @overload
    @staticmethod
    def TryEnter(obj: object, millisecondsTimeout: int) -> bool: ...
    @overload
    @staticmethod
    def TryEnter(obj: object, millisecondsTimeout: int) -> (bool): ...
    @overload
    @staticmethod
    def TryEnter(obj: object, timeout: System.TimeSpan) -> (bool): ...
    @overload
    @staticmethod
    def Wait(obj: object) -> bool: ...
    @overload
    @staticmethod
    def Wait(obj: object, millisecondsTimeout: int) -> bool: ...
    @overload
    @staticmethod
    def Wait(obj: object, timeout: System.TimeSpan) -> bool: ...
    @overload
    @staticmethod
    def Wait(obj: object, millisecondsTimeout: int, exitContext: bool) -> bool: ...
    @overload
    @staticmethod
    def Wait(obj: object, timeout: System.TimeSpan, exitContext: bool) -> bool: ...

class Overlapped(object):
    """    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, offsetLo: int, offsetHi: int, hEvent: System.IntPtr, ar: System.IAsyncResult): ...
    @overload
    def __init__(self, offsetLo: int, offsetHi: int, hEvent: int, ar: System.IAsyncResult): ...
    @overload
    @staticmethod
    def Free(nativeOverlappedPtr: NativeOverlapped) -> None: ...
    @property
    def AsyncResult(self) -> System.IAsyncResult: ...
    @property
    def EventHandle(self) -> int: ...
    @property
    def EventHandleIntPtr(self) -> System.IntPtr: ...
    @property
    def OffsetHigh(self) -> int: ...
    @property
    def OffsetLow(self) -> int: ...
    @overload
    def Pack(self, iocb: IOCompletionCallback, userData: object) -> NativeOverlapped: ...
    @AsyncResult.setter
    def AsyncResult(self, value: System.Void): ...
    @EventHandle.setter
    def EventHandle(self, value: System.Void): ...
    @EventHandleIntPtr.setter
    def EventHandleIntPtr(self, value: System.Void): ...
    @OffsetHigh.setter
    def OffsetHigh(self, value: System.Void): ...
    @OffsetLow.setter
    def OffsetLow(self, value: System.Void): ...
    @overload
    @staticmethod
    def Unpack(nativeOverlappedPtr: NativeOverlapped) -> Overlapped: ...
    @overload
    def UnsafePack(self, iocb: IOCompletionCallback, userData: object) -> NativeOverlapped: ...

class SynchronizationContext(object):
    """    """
    def __init__(self): ...
    @overload
    def CreateCopy() -> SynchronizationContext: ...
    @property
    def Current(self) -> SynchronizationContext: ...
    @overload
    def IsWaitNotificationRequired() -> bool: ...
    @overload
    def OperationCompleted() -> None: ...
    @overload
    def OperationStarted() -> None: ...
    @overload
    def Post(self, d: SendOrPostCallback, state: object) -> None: ...
    @overload
    def Send(self, d: SendOrPostCallback, state: object) -> None: ...
    @overload
    @staticmethod
    def SetSynchronizationContext(syncContext: SynchronizationContext) -> None: ...
    @overload
    def Wait(self, waitHandles: System.System.Array[System.IntPtr], waitAll: bool, millisecondsTimeout: int) -> int: ...

class Thread(ConstrainedExecution.CriticalFinalizerObject):
    """    """
    @overload
    def __init__(self, start: ThreadStart): ...
    @overload
    def __init__(self, start: ParameterizedThreadStart): ...
    @overload
    def __init__(self, start: ThreadStart, maxStackSize: int): ...
    @overload
    def __init__(self, start: ParameterizedThreadStart, maxStackSize: int): ...
    @overload
    @staticmethod
    def AllocateDataSlot() -> System.LocalDataStoreSlot: ...
    @overload
    @staticmethod
    def AllocateNamedDataSlot(name: str) -> System.LocalDataStoreSlot: ...
    @overload
    @staticmethod
    def BeginCriticalRegion() -> None: ...
    @overload
    @staticmethod
    def BeginThreadAffinity() -> None: ...
    @overload
    def DisableComObjectEagerCleanup() -> None: ...
    @overload
    @staticmethod
    def EndCriticalRegion() -> None: ...
    @overload
    @staticmethod
    def EndThreadAffinity() -> None: ...
    @overload
    @staticmethod
    def FreeNamedDataSlot(name: str) -> None: ...
    @property
    def ApartmentState(self) -> ApartmentState: ...
    @property
    def CurrentCulture(self) -> Globalization.CultureInfo: ...
    @property
    def CurrentPrincipal(self) -> Principal.IPrincipal: ...
    @property
    def CurrentThread(self) -> Thread: ...
    @property
    def CurrentUICulture(self) -> Globalization.CultureInfo: ...
    @property
    def ExecutionContext(self) -> ExecutionContext: ...
    @property
    def IsAlive(self) -> bool: ...
    @property
    def IsBackground(self) -> bool: ...
    @property
    def IsThreadPoolThread(self) -> bool: ...
    @property
    def ManagedThreadId(self) -> int: ...
    @property
    def Name(self) -> str: ...
    @property
    def Priority(self) -> ThreadPriority: ...
    @property
    def ThreadState(self) -> ThreadState: ...
    @overload
    def GetApartmentState() -> ApartmentState: ...
    @overload
    @staticmethod
    def GetCurrentProcessorId() -> int: ...
    @overload
    @staticmethod
    def GetData(slot: System.LocalDataStoreSlot) -> object: ...
    @overload
    @staticmethod
    def GetDomain() -> System.AppDomain: ...
    @overload
    @staticmethod
    def GetDomainID() -> int: ...
    @overload
    def GetHashCode() -> int: ...
    @overload
    @staticmethod
    def GetNamedDataSlot(name: str) -> System.LocalDataStoreSlot: ...
    @overload
    def Interrupt() -> None: ...
    @overload
    def Join() -> None: ...
    @overload
    def Join(self, millisecondsTimeout: int) -> bool: ...
    @overload
    def Join(self, timeout: System.TimeSpan) -> bool: ...
    @overload
    @staticmethod
    def MemoryBarrier() -> None: ...
    @ApartmentState.setter
    def ApartmentState(self, value: System.Void): ...
    @CurrentCulture.setter
    def CurrentCulture(self, value: System.Void): ...
    @CurrentPrincipal.setter
    def CurrentPrincipal(self, value: System.Void): ...
    @CurrentUICulture.setter
    def CurrentUICulture(self, value: System.Void): ...
    @IsBackground.setter
    def IsBackground(self, value: System.Void): ...
    @Name.setter
    def Name(self, value: System.Void): ...
    @Priority.setter
    def Priority(self, value: System.Void): ...
    @overload
    def SetApartmentState(self, state: ApartmentState) -> None: ...
    @overload
    @staticmethod
    def SetData(slot: System.LocalDataStoreSlot, data: object) -> None: ...
    @overload
    @staticmethod
    def Sleep(millisecondsTimeout: int) -> None: ...
    @overload
    @staticmethod
    def Sleep(timeout: System.TimeSpan) -> None: ...
    @overload
    @staticmethod
    def SpinWait(iterations: int) -> None: ...
    @overload
    def Start() -> None: ...
    @overload
    def Start(self, parameter: object) -> None: ...
    @overload
    def TrySetApartmentState(self, state: ApartmentState) -> bool: ...
    @overload
    def UnsafeStart() -> None: ...
    @overload
    def UnsafeStart(self, parameter: object) -> None: ...
    @overload
    @staticmethod
    def VolatileRead() -> (float, float): ...
    @overload
    @staticmethod
    def VolatileRead() -> (System.UIntPtr, System.UIntPtr): ...
    @overload
    @staticmethod
    def VolatileRead() -> (System.UInt64, System.UInt64): ...
    @overload
    @staticmethod
    def VolatileRead() -> (System.UInt32, System.UInt32): ...
    @overload
    @staticmethod
    def VolatileRead() -> (System.UInt16, System.UInt16): ...
    @overload
    @staticmethod
    def VolatileRead() -> (System.Single, System.Single): ...
    @overload
    @staticmethod
    def VolatileRead() -> (System.Byte, System.Byte): ...
    @overload
    @staticmethod
    def VolatileRead() -> (object, object): ...
    @overload
    @staticmethod
    def VolatileRead() -> (System.IntPtr, System.IntPtr): ...
    @overload
    @staticmethod
    def VolatileRead() -> (System.Int64, System.Int64): ...
    @overload
    @staticmethod
    def VolatileRead() -> (int, int): ...
    @overload
    @staticmethod
    def VolatileRead() -> (System.Int16, System.Int16): ...
    @overload
    @staticmethod
    def VolatileRead() -> (System.SByte, System.SByte): ...
    @overload
    @staticmethod
    def VolatileWrite(value: System.UIntPtr) -> (System.UIntPtr): ...
    @overload
    @staticmethod
    def VolatileWrite(value: System.UInt64) -> (System.UInt64): ...
    @overload
    @staticmethod
    def VolatileWrite(value: System.UInt32) -> (System.UInt32): ...
    @overload
    @staticmethod
    def VolatileWrite(value: System.UInt16) -> (System.UInt16): ...
    @overload
    @staticmethod
    def VolatileWrite(value: System.Single) -> (System.Single): ...
    @overload
    @staticmethod
    def VolatileWrite(value: System.IntPtr) -> (System.IntPtr): ...
    @overload
    @staticmethod
    def VolatileWrite(value: object) -> (object): ...
    @overload
    @staticmethod
    def VolatileWrite(value: System.Int64) -> (System.Int64): ...
    @overload
    @staticmethod
    def VolatileWrite(value: int) -> (int): ...
    @overload
    @staticmethod
    def VolatileWrite(value: System.Int16) -> (System.Int16): ...
    @overload
    @staticmethod
    def VolatileWrite(value: System.Byte) -> (System.Byte): ...
    @overload
    @staticmethod
    def VolatileWrite(value: System.SByte) -> (System.SByte): ...
    @overload
    @staticmethod
    def VolatileWrite(value: float) -> (float): ...
    @overload
    @staticmethod
    def Yield() -> bool: ...

class RegisteredWaitHandle(System.MarshalByRefObject):
    """    """
    @overload
    def Unregister(self, waitObject: WaitHandle) -> bool: ...

class ThreadPool(object):
    """    """
    @overload
    @staticmethod
    def BindHandle(osHandle: InteropServices.SafeHandle) -> bool: ...
    @property
    def CompletedWorkItemCount(self) -> System.Int64: ...
    @property
    def PendingWorkItemCount(self) -> System.Int64: ...
    @property
    def ThreadCount(self) -> int: ...
    @overload
    @staticmethod
    def GetAvailableThreads() -> (int, int): ...
    @overload
    @staticmethod
    def GetMaxThreads() -> (int, int): ...
    @overload
    @staticmethod
    def GetMinThreads() -> (int, int): ...
    @overload
    @staticmethod
    def QueueUserWorkItem(callBack: WaitCallback) -> bool: ...
    @overload
    @staticmethod
    def QueueUserWorkItem(callBack: WaitCallback, state: object) -> bool: ...
    @overload
    @staticmethod
    def QueueUserWorkItem(callBack: System.Action, state: TState, preferLocal: bool) -> bool: ...
    @overload
    @staticmethod
    def RegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: object, timeout: System.TimeSpan, executeOnlyOnce: bool) -> RegisteredWaitHandle: ...
    @overload
    @staticmethod
    def RegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: object, millisecondsTimeOutInterval: System.Int64, executeOnlyOnce: bool) -> RegisteredWaitHandle: ...
    @overload
    @staticmethod
    def RegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: object, millisecondsTimeOutInterval: int, executeOnlyOnce: bool) -> RegisteredWaitHandle: ...
    @overload
    @staticmethod
    def RegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: object, millisecondsTimeOutInterval: System.UInt32, executeOnlyOnce: bool) -> RegisteredWaitHandle: ...
    @overload
    @staticmethod
    def SetMaxThreads(workerThreads: int, completionPortThreads: int) -> bool: ...
    @overload
    @staticmethod
    def SetMinThreads(workerThreads: int, completionPortThreads: int) -> bool: ...
    @overload
    @staticmethod
    def UnsafeQueueNativeOverlapped(overlapped: NativeOverlapped) -> bool: ...
    @overload
    @staticmethod
    def UnsafeQueueUserWorkItem(callBack: WaitCallback, state: object) -> bool: ...
    @overload
    @staticmethod
    def UnsafeQueueUserWorkItem(callBack: IThreadPoolWorkItem, preferLocal: bool) -> bool: ...
    @overload
    @staticmethod
    def UnsafeQueueUserWorkItem(callBack: System.Action, state: TState, preferLocal: bool) -> bool: ...
    @overload
    @staticmethod
    def UnsafeRegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: object, millisecondsTimeOutInterval: int, executeOnlyOnce: bool) -> RegisteredWaitHandle: ...
    @overload
    @staticmethod
    def UnsafeRegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: object, timeout: System.TimeSpan, executeOnlyOnce: bool) -> RegisteredWaitHandle: ...
    @overload
    @staticmethod
    def UnsafeRegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: object, millisecondsTimeOutInterval: System.UInt32, executeOnlyOnce: bool) -> RegisteredWaitHandle: ...
    @overload
    @staticmethod
    def UnsafeRegisterWaitForSingleObject(waitObject: WaitHandle, callBack: WaitOrTimerCallback, state: object, millisecondsTimeOutInterval: System.Int64, executeOnlyOnce: bool) -> RegisteredWaitHandle: ...

class WaitHandle(System.MarshalByRefObject):
    """    """
    @property
    def WaitTimeout(self) -> int: ...
    @overload
    def Close() -> None: ...
    @overload
    def Dispose() -> None: ...
    @property
    def Handle(self) -> System.IntPtr: ...
    @property
    def SafeWaitHandle(self) -> SafeHandles.SafeWaitHandle: ...
    @Handle.setter
    def Handle(self, value: System.Void): ...
    @SafeWaitHandle.setter
    def SafeWaitHandle(self, value: System.Void): ...
    @overload
    @staticmethod
    def SignalAndWait(toSignal: WaitHandle, toWaitOn: WaitHandle) -> bool: ...
    @overload
    @staticmethod
    def SignalAndWait(toSignal: WaitHandle, toWaitOn: WaitHandle, millisecondsTimeout: int, exitContext: bool) -> bool: ...
    @overload
    @staticmethod
    def SignalAndWait(toSignal: WaitHandle, toWaitOn: WaitHandle, timeout: System.TimeSpan, exitContext: bool) -> bool: ...
    @overload
    @staticmethod
    def WaitAll(waitHandles: System.Array[WaitHandle]) -> bool: ...
    @overload
    @staticmethod
    def WaitAll(waitHandles: System.Array[WaitHandle], millisecondsTimeout: int) -> bool: ...
    @overload
    @staticmethod
    def WaitAll(waitHandles: System.Array[WaitHandle], timeout: System.TimeSpan) -> bool: ...
    @overload
    @staticmethod
    def WaitAll(waitHandles: System.Array[WaitHandle], millisecondsTimeout: int, exitContext: bool) -> bool: ...
    @overload
    @staticmethod
    def WaitAll(waitHandles: System.Array[WaitHandle], timeout: System.TimeSpan, exitContext: bool) -> bool: ...
    @overload
    @staticmethod
    def WaitAny(waitHandles: System.Array[WaitHandle]) -> int: ...
    @overload
    @staticmethod
    def WaitAny(waitHandles: System.Array[WaitHandle], timeout: System.TimeSpan) -> int: ...
    @overload
    @staticmethod
    def WaitAny(waitHandles: System.Array[WaitHandle], millisecondsTimeout: int) -> int: ...
    @overload
    @staticmethod
    def WaitAny(waitHandles: System.Array[WaitHandle], millisecondsTimeout: int, exitContext: bool) -> int: ...
    @overload
    @staticmethod
    def WaitAny(waitHandles: System.Array[WaitHandle], timeout: System.TimeSpan, exitContext: bool) -> int: ...
    @overload
    def WaitOne() -> bool: ...
    @overload
    def WaitOne(self, timeout: System.TimeSpan) -> bool: ...
    @overload
    def WaitOne(self, millisecondsTimeout: int) -> bool: ...
    @overload
    def WaitOne(self, timeout: System.TimeSpan, exitContext: bool) -> bool: ...
    @overload
    def WaitOne(self, millisecondsTimeout: int, exitContext: bool) -> bool: ...

class AbandonedMutexException(System.SystemException):
    """    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, message: str): ...
    @overload
    def __init__(self, message: str, inner: System.Exception): ...
    @overload
    def __init__(self, location: int, handle: WaitHandle): ...
    @overload
    def __init__(self, message: str, location: int, handle: WaitHandle): ...
    @overload
    def __init__(self, message: str, inner: System.Exception, location: int, handle: WaitHandle): ...
    @property
    def Mutex(self) -> Mutex: ...
    @property
    def MutexIndex(self) -> int: ...

class ApartmentState(enum.Enum):
    STA = 0
    MTA = 1
    Unknown = 2

class AsyncLocal(object):
    """    AsyncLocal[T]
    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, valueChangedHandler: System.Action): ...
    @property
    def Value(self) -> T: ...
    @Value.setter
    def Value(self, value: System.Void): ...

class AsyncLocalValueChangedArgs(System.ValueType):
    """    AsyncLocalValueChangedArgs[T]
    """
    @property
    def CurrentValue(self) -> T: ...
    @property
    def PreviousValue(self) -> T: ...
    @property
    def ThreadContextChanged(self) -> bool: ...

class AutoResetEvent(EventWaitHandle):
    """    """
    def __init__(self, initialState: bool): ...

class CancellationToken(System.ValueType):
    """    """
    def __init__(self, canceled: bool): ...
    @overload
    def Equals(self, other: object) -> bool: ...
    @overload
    def Equals(self, other: CancellationToken) -> bool: ...
    @property
    def CanBeCanceled(self) -> bool: ...
    @property
    def IsCancellationRequested(self) -> bool: ...
    @property
    def None_(self) -> CancellationToken: ...
    @property
    def WaitHandle(self) -> WaitHandle: ...
    @overload
    def GetHashCode() -> int: ...
    @overload
    def Register(self, callback: System.Action) -> CancellationTokenRegistration: ...
    @overload
    def Register(self, callback: System.Action, state: object) -> CancellationTokenRegistration: ...
    @overload
    def Register(self, callback: System.Action, useSynchronizationContext: bool) -> CancellationTokenRegistration: ...
    @overload
    def Register(self, callback: System.Action, state: object) -> CancellationTokenRegistration: ...
    @overload
    def Register(self, callback: System.Action, state: object, useSynchronizationContext: bool) -> CancellationTokenRegistration: ...
    @overload
    def ThrowIfCancellationRequested() -> None: ...
    @overload
    def UnsafeRegister(self, callback: System.Action, state: object) -> CancellationTokenRegistration: ...
    @overload
    def UnsafeRegister(self, callback: System.Action, state: object) -> CancellationTokenRegistration: ...

class CancellationTokenRegistration(System.ValueType):
    """    """
    @overload
    def Dispose() -> None: ...
    @overload
    def DisposeAsync() -> Tasks.ValueTask: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Equals(self, other: CancellationTokenRegistration) -> bool: ...
    @property
    def Token(self) -> CancellationToken: ...
    @overload
    def GetHashCode() -> int: ...
    @overload
    def Unregister() -> bool: ...

class CancellationTokenSource(object):
    """    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, delay: System.TimeSpan): ...
    @overload
    def __init__(self, millisecondsDelay: int): ...
    @overload
    def Cancel() -> None: ...
    @overload
    def Cancel(self, throwOnFirstException: bool) -> None: ...
    @overload
    def CancelAfter(self, delay: System.TimeSpan) -> None: ...
    @overload
    def CancelAfter(self, millisecondsDelay: int) -> None: ...
    @overload
    @staticmethod
    def CreateLinkedTokenSource(token: CancellationToken) -> CancellationTokenSource: ...
    @overload
    @staticmethod
    def CreateLinkedTokenSource(tokens: System.Array[CancellationToken]) -> CancellationTokenSource: ...
    @overload
    @staticmethod
    def CreateLinkedTokenSource(token1: CancellationToken, token2: CancellationToken) -> CancellationTokenSource: ...
    @overload
    def Dispose() -> None: ...
    @property
    def IsCancellationRequested(self) -> bool: ...
    @property
    def Token(self) -> CancellationToken: ...
    @overload
    def TryReset() -> bool: ...

class CompressedStack(object):
    """    """
    @overload
    @staticmethod
    def Capture() -> CompressedStack: ...
    @overload
    def CreateCopy() -> CompressedStack: ...
    @overload
    @staticmethod
    def GetCompressedStack() -> CompressedStack: ...
    @overload
    def GetObjectData(self, info: Serialization.SerializationInfo, context: Serialization.StreamingContext) -> None: ...
    @overload
    @staticmethod
    def Run(compressedStack: CompressedStack, callback: ContextCallback, state: object) -> None: ...

class EventResetMode(enum.Enum):
    AutoReset = 0
    ManualReset = 1

class EventWaitHandle(WaitHandle):
    """    """
    @overload
    def __init__(self, initialState: bool, mode: EventResetMode): ...
    @overload
    def __init__(self, initialState: bool, mode: EventResetMode, name: str): ...
    @overload
    def __init__(self, initialState: bool, mode: EventResetMode, name: str, createdNew: System.Boolean): ...
    @overload
    @staticmethod
    def OpenExisting(name: str) -> EventWaitHandle: ...
    @overload
    def Reset() -> bool: ...
    @overload
    def Set() -> bool: ...
    @overload
    @staticmethod
    def TryOpenExisting(name: str) -> (bool, EventWaitHandle): ...

class ContextCallback(System.MulticastDelegate):
    """    """
    def __init__(self, object_: object, method: System.IntPtr): ...
    @overload
    def BeginInvoke(self, state: object, callback: System.AsyncCallback, object_: object) -> System.IAsyncResult: ...
    @overload
    def EndInvoke(self, result: System.IAsyncResult) -> None: ...
    @overload
    def Invoke(self, state: object) -> None: ...

class ExecutionContext(object):
    """    """
    @overload
    @staticmethod
    def Capture() -> ExecutionContext: ...
    @overload
    def CreateCopy() -> ExecutionContext: ...
    @overload
    def Dispose() -> None: ...
    @overload
    def GetObjectData(self, info: Serialization.SerializationInfo, context: Serialization.StreamingContext) -> None: ...
    @overload
    @staticmethod
    def IsFlowSuppressed() -> bool: ...
    @overload
    @staticmethod
    def Restore(executionContext: ExecutionContext) -> None: ...
    @overload
    @staticmethod
    def RestoreFlow() -> None: ...
    @overload
    @staticmethod
    def Run(executionContext: ExecutionContext, callback: ContextCallback, state: object) -> None: ...
    @overload
    @staticmethod
    def SuppressFlow() -> AsyncFlowControl: ...

class AsyncFlowControl(System.ValueType):
    """    """
    @overload
    def Dispose() -> None: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Equals(self, obj: AsyncFlowControl) -> bool: ...
    @overload
    def GetHashCode() -> int: ...
    @overload
    def Undo() -> None: ...

class IOCompletionCallback(System.MulticastDelegate):
    """    """
    def __init__(self, object_: object, method: System.IntPtr): ...
    @overload
    def BeginInvoke(self, errorCode: System.UInt32, numBytes: System.UInt32, pOVERLAP: NativeOverlapped, callback: System.AsyncCallback, object_: object) -> System.IAsyncResult: ...
    @overload
    def EndInvoke(self, result: System.IAsyncResult) -> None: ...
    @overload
    def Invoke(self, errorCode: System.UInt32, numBytes: System.UInt32, pOVERLAP: NativeOverlapped) -> None: ...

class IThreadPoolWorkItem:
    """    """
    @overload
    def Execute() -> None: ...

class LazyInitializer(object):
    """    """
    @overload
    @staticmethod
    def EnsureInitialized() -> (T, T): ...
    @overload
    @staticmethod
    def EnsureInitialized(valueFactory: System.Func) -> (T, T): ...
    @overload
    @staticmethod
    def EnsureInitialized() -> (T, T, bool, object): ...
    @overload
    @staticmethod
    def EnsureInitialized(valueFactory: System.Func) -> (T, T, object): ...
    @overload
    @staticmethod
    def EnsureInitialized(valueFactory: System.Func) -> (T, T, bool, object): ...

class LazyThreadSafetyMode(enum.Enum):
    None_ = 0
    PublicationOnly = 1
    ExecutionAndPublication = 2

class LockRecursionException(System.Exception):
    """    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, message: str): ...
    @overload
    def __init__(self, message: str, innerException: System.Exception): ...

class ManualResetEvent(EventWaitHandle):
    """    """
    def __init__(self, initialState: bool): ...

class ManualResetEventSlim(object):
    """    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, initialState: bool): ...
    @overload
    def __init__(self, initialState: bool, spinCount: int): ...
    @overload
    def Dispose() -> None: ...
    @property
    def IsSet(self) -> bool: ...
    @property
    def SpinCount(self) -> int: ...
    @property
    def WaitHandle(self) -> WaitHandle: ...
    @overload
    def Reset() -> None: ...
    @overload
    def Set() -> None: ...
    @overload
    def Wait() -> None: ...
    @overload
    def Wait(self, cancellationToken: CancellationToken) -> None: ...
    @overload
    def Wait(self, timeout: System.TimeSpan) -> bool: ...
    @overload
    def Wait(self, millisecondsTimeout: int) -> bool: ...
    @overload
    def Wait(self, timeout: System.TimeSpan, cancellationToken: CancellationToken) -> bool: ...
    @overload
    def Wait(self, millisecondsTimeout: int, cancellationToken: CancellationToken) -> bool: ...

class Mutex(WaitHandle):
    """    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, initiallyOwned: bool): ...
    @overload
    def __init__(self, initiallyOwned: bool, name: str): ...
    @overload
    def __init__(self, initiallyOwned: bool, name: str, createdNew: System.Boolean): ...
    @overload
    @staticmethod
    def OpenExisting(name: str) -> Mutex: ...
    @overload
    def ReleaseMutex() -> None: ...
    @overload
    @staticmethod
    def TryOpenExisting(name: str) -> (bool, Mutex): ...

class NativeOverlapped(System.ValueType):
    """    """
    @property
    def InternalLow(self) -> System.IntPtr: ...
    @property
    def InternalHigh(self) -> System.IntPtr: ...
    @property
    def OffsetLow(self) -> int: ...
    @property
    def OffsetHigh(self) -> int: ...
    @property
    def EventHandle(self) -> System.IntPtr: ...

class ParameterizedThreadStart(System.MulticastDelegate):
    """    """
    def __init__(self, object_: object, method: System.IntPtr): ...
    @overload
    def BeginInvoke(self, obj: object, callback: System.AsyncCallback, object_: object) -> System.IAsyncResult: ...
    @overload
    def EndInvoke(self, result: System.IAsyncResult) -> None: ...
    @overload
    def Invoke(self, obj: object) -> None: ...

class LockRecursionPolicy(enum.Enum):
    NoRecursion = 0
    SupportsRecursion = 1

class ReaderWriterLockSlim(object):
    """    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, recursionPolicy: LockRecursionPolicy): ...
    @overload
    def Dispose() -> None: ...
    @overload
    def EnterReadLock() -> None: ...
    @overload
    def EnterUpgradeableReadLock() -> None: ...
    @overload
    def EnterWriteLock() -> None: ...
    @overload
    def ExitReadLock() -> None: ...
    @overload
    def ExitUpgradeableReadLock() -> None: ...
    @overload
    def ExitWriteLock() -> None: ...
    @property
    def CurrentReadCount(self) -> int: ...
    @property
    def IsReadLockHeld(self) -> bool: ...
    @property
    def IsUpgradeableReadLockHeld(self) -> bool: ...
    @property
    def IsWriteLockHeld(self) -> bool: ...
    @property
    def RecursionPolicy(self) -> LockRecursionPolicy: ...
    @property
    def RecursiveReadCount(self) -> int: ...
    @property
    def RecursiveUpgradeCount(self) -> int: ...
    @property
    def RecursiveWriteCount(self) -> int: ...
    @property
    def WaitingReadCount(self) -> int: ...
    @property
    def WaitingUpgradeCount(self) -> int: ...
    @property
    def WaitingWriteCount(self) -> int: ...
    @overload
    def TryEnterReadLock(self, timeout: System.TimeSpan) -> bool: ...
    @overload
    def TryEnterReadLock(self, millisecondsTimeout: int) -> bool: ...
    @overload
    def TryEnterUpgradeableReadLock(self, millisecondsTimeout: int) -> bool: ...
    @overload
    def TryEnterUpgradeableReadLock(self, timeout: System.TimeSpan) -> bool: ...
    @overload
    def TryEnterWriteLock(self, timeout: System.TimeSpan) -> bool: ...
    @overload
    def TryEnterWriteLock(self, millisecondsTimeout: int) -> bool: ...

class Semaphore(WaitHandle):
    """    """
    @overload
    def __init__(self, initialCount: int, maximumCount: int): ...
    @overload
    def __init__(self, initialCount: int, maximumCount: int, name: str): ...
    @overload
    def __init__(self, initialCount: int, maximumCount: int, name: str, createdNew: System.Boolean): ...
    @overload
    @staticmethod
    def OpenExisting(name: str) -> Semaphore: ...
    @overload
    def Release() -> int: ...
    @overload
    def Release(self, releaseCount: int) -> int: ...
    @overload
    @staticmethod
    def TryOpenExisting(name: str) -> (bool, Semaphore): ...

class SemaphoreFullException(System.SystemException):
    """    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, message: str): ...
    @overload
    def __init__(self, message: str, innerException: System.Exception): ...

class SemaphoreSlim(object):
    """    """
    @overload
    def __init__(self, initialCount: int): ...
    @overload
    def __init__(self, initialCount: int, maxCount: int): ...
    @overload
    def Dispose() -> None: ...
    @property
    def AvailableWaitHandle(self) -> WaitHandle: ...
    @property
    def CurrentCount(self) -> int: ...
    @overload
    def Release() -> int: ...
    @overload
    def Release(self, releaseCount: int) -> int: ...
    @overload
    def Wait() -> None: ...
    @overload
    def Wait(self, millisecondsTimeout: int) -> bool: ...
    @overload
    def Wait(self, cancellationToken: CancellationToken) -> None: ...
    @overload
    def Wait(self, timeout: System.TimeSpan) -> bool: ...
    @overload
    def Wait(self, timeout: System.TimeSpan, cancellationToken: CancellationToken) -> bool: ...
    @overload
    def Wait(self, millisecondsTimeout: int, cancellationToken: CancellationToken) -> bool: ...
    @overload
    def WaitAsync() -> Tasks.Task: ...
    @overload
    def WaitAsync(self, cancellationToken: CancellationToken) -> Tasks.Task: ...
    @overload
    def WaitAsync(self, timeout: System.TimeSpan) -> Tasks.Task: ...
    @overload
    def WaitAsync(self, millisecondsTimeout: int) -> Tasks.Task: ...
    @overload
    def WaitAsync(self, timeout: System.TimeSpan, cancellationToken: CancellationToken) -> Tasks.Task: ...
    @overload
    def WaitAsync(self, millisecondsTimeout: int, cancellationToken: CancellationToken) -> Tasks.Task: ...

class SendOrPostCallback(System.MulticastDelegate):
    """    """
    def __init__(self, object_: object, method: System.IntPtr): ...
    @overload
    def BeginInvoke(self, state: object, callback: System.AsyncCallback, object_: object) -> System.IAsyncResult: ...
    @overload
    def EndInvoke(self, result: System.IAsyncResult) -> None: ...
    @overload
    def Invoke(self, state: object) -> None: ...

class SpinLock(System.ValueType):
    """    """
    def __init__(self, enableThreadOwnerTracking: bool): ...
    @overload
    def Enter() -> (bool): ...
    @overload
    def Exit() -> None: ...
    @overload
    def Exit(self, useMemoryBarrier: bool) -> None: ...
    @property
    def IsHeld(self) -> bool: ...
    @property
    def IsHeldByCurrentThread(self) -> bool: ...
    @property
    def IsThreadOwnerTrackingEnabled(self) -> bool: ...
    @overload
    def TryEnter() -> (bool): ...
    @overload
    def TryEnter(self, timeout: System.TimeSpan) -> (bool): ...
    @overload
    def TryEnter(self, millisecondsTimeout: int) -> (bool): ...

class SpinWait(System.ValueType):
    """    """
    @property
    def Count(self) -> int: ...
    @property
    def NextSpinWillYield(self) -> bool: ...
    @overload
    def Reset() -> None: ...
    @overload
    def SpinOnce() -> None: ...
    @overload
    def SpinOnce(self, sleep1Threshold: int) -> None: ...
    @overload
    @staticmethod
    def SpinUntil(condition: System.Func) -> None: ...
    @overload
    @staticmethod
    def SpinUntil(condition: System.Func, timeout: System.TimeSpan) -> bool: ...
    @overload
    @staticmethod
    def SpinUntil(condition: System.Func, millisecondsTimeout: int) -> bool: ...

class SynchronizationLockException(System.SystemException):
    """    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, message: str): ...
    @overload
    def __init__(self, message: str, innerException: System.Exception): ...

class ThreadAbortException(System.SystemException):
    """    """
    @property
    def ExceptionState(self) -> object: ...

class ThreadExceptionEventArgs(System.EventArgs):
    """    """
    def __init__(self, t: System.Exception): ...
    @property
    def Exception(self) -> System.Exception: ...

class ThreadExceptionEventHandler(System.MulticastDelegate):
    """    """
    def __init__(self, object_: object, method: System.IntPtr): ...
    @overload
    def BeginInvoke(self, sender: object, e: ThreadExceptionEventArgs, callback: System.AsyncCallback, object_: object) -> System.IAsyncResult: ...
    @overload
    def EndInvoke(self, result: System.IAsyncResult) -> None: ...
    @overload
    def Invoke(self, sender: object, e: ThreadExceptionEventArgs) -> None: ...

class ThreadInterruptedException(System.SystemException):
    """    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, message: str): ...
    @overload
    def __init__(self, message: str, innerException: System.Exception): ...

class ThreadLocal(object):
    """    ThreadLocal[T]
    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, trackAllValues: bool): ...
    @overload
    def __init__(self, valueFactory: System.Func): ...
    @overload
    def __init__(self, valueFactory: System.Func, trackAllValues: bool): ...
    @overload
    def Dispose() -> None: ...
    @property
    def IsValueCreated(self) -> bool: ...
    @property
    def Value(self) -> T: ...
    @property
    def Values(self) -> Generic.IList: ...
    @Value.setter
    def Value(self, value: System.Void): ...
    @overload
    def ToString() -> str: ...

class WaitCallback(System.MulticastDelegate):
    """    """
    def __init__(self, object_: object, method: System.IntPtr): ...
    @overload
    def BeginInvoke(self, state: object, callback: System.AsyncCallback, object_: object) -> System.IAsyncResult: ...
    @overload
    def EndInvoke(self, result: System.IAsyncResult) -> None: ...
    @overload
    def Invoke(self, state: object) -> None: ...

class WaitOrTimerCallback(System.MulticastDelegate):
    """    """
    def __init__(self, object_: object, method: System.IntPtr): ...
    @overload
    def BeginInvoke(self, state: object, timedOut: bool, callback: System.AsyncCallback, object_: object) -> System.IAsyncResult: ...
    @overload
    def EndInvoke(self, result: System.IAsyncResult) -> None: ...
    @overload
    def Invoke(self, state: object, timedOut: bool) -> None: ...

class ThreadPriority(enum.Enum):
    Lowest = 0
    BelowNormal = 1
    Normal = 2
    AboveNormal = 3
    Highest = 4

class ThreadStart(System.MulticastDelegate):
    """    """
    def __init__(self, object_: object, method: System.IntPtr): ...
    @overload
    def BeginInvoke(self, callback: System.AsyncCallback, object_: object) -> System.IAsyncResult: ...
    @overload
    def EndInvoke(self, result: System.IAsyncResult) -> None: ...
    @overload
    def Invoke() -> None: ...

class ThreadStartException(System.SystemException):
    """    """

class ThreadState(enum.Enum):
    Running = 0
    StopRequested = 1
    SuspendRequested = 2
    Background = 4
    Unstarted = 8
    Stopped = 16
    WaitSleepJoin = 32
    Suspended = 64
    AbortRequested = 128
    Aborted = 256

class ThreadStateException(System.SystemException):
    """    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, message: str): ...
    @overload
    def __init__(self, message: str, innerException: System.Exception): ...

class Timeout(object):
    """    """
    @property
    def InfiniteTimeSpan(self) -> System.TimeSpan: ...
    @property
    def Infinite(self) -> int: ...

class PeriodicTimer(object):
    """    """
    def __init__(self, period: System.TimeSpan): ...
    @overload
    def Dispose() -> None: ...
    @overload
    def WaitForNextTickAsync(self, cancellationToken: CancellationToken) -> Tasks.ValueTask: ...

class TimerCallback(System.MulticastDelegate):
    """    """
    def __init__(self, object_: object, method: System.IntPtr): ...
    @overload
    def BeginInvoke(self, state: object, callback: System.AsyncCallback, object_: object) -> System.IAsyncResult: ...
    @overload
    def EndInvoke(self, result: System.IAsyncResult) -> None: ...
    @overload
    def Invoke(self, state: object) -> None: ...

class Timer(System.MarshalByRefObject):
    """    """
    @overload
    def __init__(self, callback: TimerCallback): ...
    @overload
    def __init__(self, callback: TimerCallback, state: object, dueTime: int, period: int): ...
    @overload
    def __init__(self, callback: TimerCallback, state: object, dueTime: System.TimeSpan, period: System.TimeSpan): ...
    @overload
    def __init__(self, callback: TimerCallback, state: object, dueTime: System.UInt32, period: System.UInt32): ...
    @overload
    def __init__(self, callback: TimerCallback, state: object, dueTime: System.Int64, period: System.Int64): ...
    @overload
    def Change(self, dueTime: int, period: int) -> bool: ...
    @overload
    def Change(self, dueTime: System.TimeSpan, period: System.TimeSpan) -> bool: ...
    @overload
    def Change(self, dueTime: System.UInt32, period: System.UInt32) -> bool: ...
    @overload
    def Change(self, dueTime: System.Int64, period: System.Int64) -> bool: ...
    @overload
    def Dispose() -> None: ...
    @overload
    def Dispose(self, notifyObject: WaitHandle) -> bool: ...
    @overload
    def DisposeAsync() -> Tasks.ValueTask: ...
    @property
    def ActiveCount(self) -> System.Int64: ...

class Volatile(object):
    """    """
    @overload
    @staticmethod
    def Read() -> (T, T): ...
    @overload
    @staticmethod
    def Read() -> (System.UIntPtr, System.UIntPtr): ...
    @overload
    @staticmethod
    def Read() -> (System.UInt64, System.UInt64): ...
    @overload
    @staticmethod
    def Read() -> (System.UInt32, System.UInt32): ...
    @overload
    @staticmethod
    def Read() -> (System.UInt16, System.UInt16): ...
    @overload
    @staticmethod
    def Read() -> (System.Single, System.Single): ...
    @overload
    @staticmethod
    def Read() -> (System.SByte, System.SByte): ...
    @overload
    @staticmethod
    def Read() -> (System.IntPtr, System.IntPtr): ...
    @overload
    @staticmethod
    def Read() -> (bool, bool): ...
    @overload
    @staticmethod
    def Read() -> (System.Int64, System.Int64): ...
    @overload
    @staticmethod
    def Read() -> (int, int): ...
    @overload
    @staticmethod
    def Read() -> (System.Byte, System.Byte): ...
    @overload
    @staticmethod
    def Read() -> (System.Int16, System.Int16): ...
    @overload
    @staticmethod
    def Read() -> (float, float): ...
    @overload
    @staticmethod
    def Write(value: bool) -> (bool): ...
    @overload
    @staticmethod
    def Write(value: T) -> (T): ...
    @overload
    @staticmethod
    def Write(value: System.UIntPtr) -> (System.UIntPtr): ...
    @overload
    @staticmethod
    def Write(value: System.Byte) -> (System.Byte): ...
    @overload
    @staticmethod
    def Write(value: System.UInt64) -> (System.UInt64): ...
    @overload
    @staticmethod
    def Write(value: System.UInt32) -> (System.UInt32): ...
    @overload
    @staticmethod
    def Write(value: float) -> (float): ...
    @overload
    @staticmethod
    def Write(value: System.UInt16) -> (System.UInt16): ...
    @overload
    @staticmethod
    def Write(value: System.Single) -> (System.Single): ...
    @overload
    @staticmethod
    def Write(value: System.Int16) -> (System.Int16): ...
    @overload
    @staticmethod
    def Write(value: int) -> (int): ...
    @overload
    @staticmethod
    def Write(value: System.IntPtr) -> (System.IntPtr): ...
    @overload
    @staticmethod
    def Write(value: System.Int64) -> (System.Int64): ...
    @overload
    @staticmethod
    def Write(value: System.SByte) -> (System.SByte): ...

class WaitHandleCannotBeOpenedException(System.ApplicationException):
    """    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, message: str): ...
    @overload
    def __init__(self, message: str, innerException: System.Exception): ...

class WaitHandleExtensions(object):
    """    """
    @overload
    @staticmethod
    def GetSafeWaitHandle(waitHandle: WaitHandle) -> SafeHandles.SafeWaitHandle: ...
    @overload
    @staticmethod
    def SetSafeWaitHandle(waitHandle: WaitHandle, value: SafeHandles.SafeWaitHandle) -> None: ...

class PreAllocatedOverlapped(object):
    """    """
    def __init__(self, callback: IOCompletionCallback, state: object, pinData: object): ...
    @overload
    def Dispose() -> None: ...
    @overload
    @staticmethod
    def UnsafeCreate(callback: IOCompletionCallback, state: object, pinData: object) -> PreAllocatedOverlapped: ...

class ThreadPoolBoundHandle(object):
    """    """
    @overload
    def AllocateNativeOverlapped(self, preAllocated: PreAllocatedOverlapped) -> NativeOverlapped: ...
    @overload
    def AllocateNativeOverlapped(self, callback: IOCompletionCallback, state: object, pinData: object) -> NativeOverlapped: ...
    @overload
    @staticmethod
    def BindHandle(handle: InteropServices.SafeHandle) -> ThreadPoolBoundHandle: ...
    @overload
    def Dispose() -> None: ...
    @overload
    def FreeNativeOverlapped(self, overlapped: NativeOverlapped) -> None: ...
    @property
    def Handle(self) -> InteropServices.SafeHandle: ...
    @overload
    @staticmethod
    def GetNativeOverlappedState(overlapped: NativeOverlapped) -> object: ...
    @overload
    def UnsafeAllocateNativeOverlapped(self, callback: IOCompletionCallback, state: object, pinData: object) -> NativeOverlapped: ...

# endregion

# region: System.Threading.AccessControl, Version=7.0.0.0

class EventWaitHandleAcl(object):
    """    """
    @overload
    @staticmethod
    def Create(initialState: bool, mode: EventResetMode, name: str, eventSecurity: AccessControl.EventWaitHandleSecurity) -> (EventWaitHandle, bool): ...
    @overload
    @staticmethod
    def OpenExisting(name: str, rights: AccessControl.EventWaitHandleRights) -> EventWaitHandle: ...
    @overload
    @staticmethod
    def TryOpenExisting(name: str, rights: AccessControl.EventWaitHandleRights) -> (bool, EventWaitHandle): ...

class MutexAcl(object):
    """    """
    @overload
    @staticmethod
    def Create(initiallyOwned: bool, name: str, mutexSecurity: AccessControl.MutexSecurity) -> (Mutex, bool): ...
    @overload
    @staticmethod
    def OpenExisting(name: str, rights: AccessControl.MutexRights) -> Mutex: ...
    @overload
    @staticmethod
    def TryOpenExisting(name: str, rights: AccessControl.MutexRights) -> (bool, Mutex): ...

class SemaphoreAcl(object):
    """    """
    @overload
    @staticmethod
    def Create(initialCount: int, maximumCount: int, name: str, semaphoreSecurity: AccessControl.SemaphoreSecurity) -> (Semaphore, bool): ...
    @overload
    @staticmethod
    def OpenExisting(name: str, rights: AccessControl.SemaphoreRights) -> Semaphore: ...
    @overload
    @staticmethod
    def TryOpenExisting(name: str, rights: AccessControl.SemaphoreRights) -> (bool, Semaphore): ...

class ThreadingAclExtensions(object):
    """    """
    @overload
    @staticmethod
    def GetAccessControl(handle: EventWaitHandle) -> AccessControl.EventWaitHandleSecurity: ...
    @overload
    @staticmethod
    def GetAccessControl(mutex: Mutex) -> AccessControl.MutexSecurity: ...
    @overload
    @staticmethod
    def GetAccessControl(semaphore: Semaphore) -> AccessControl.SemaphoreSecurity: ...
    @overload
    @staticmethod
    def SetAccessControl(handle: EventWaitHandle, eventSecurity: AccessControl.EventWaitHandleSecurity) -> None: ...
    @overload
    @staticmethod
    def SetAccessControl(mutex: Mutex, mutexSecurity: AccessControl.MutexSecurity) -> None: ...
    @overload
    @staticmethod
    def SetAccessControl(semaphore: Semaphore, semaphoreSecurity: AccessControl.SemaphoreSecurity) -> None: ...

# endregion

# region: System.Threading, Version=7.0.0.0

class BarrierPostPhaseException(System.Exception):
    """    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, innerException: System.Exception): ...
    @overload
    def __init__(self, message: str): ...
    @overload
    def __init__(self, message: str, innerException: System.Exception): ...

class Barrier(object):
    """    """
    @overload
    def __init__(self, participantCount: int): ...
    @overload
    def __init__(self, participantCount: int, postPhaseAction: System.Action): ...
    @overload
    def AddParticipant() -> System.Int64: ...
    @overload
    def AddParticipants(self, participantCount: int) -> System.Int64: ...
    @overload
    def Dispose() -> None: ...
    @property
    def CurrentPhaseNumber(self) -> System.Int64: ...
    @property
    def ParticipantCount(self) -> int: ...
    @property
    def ParticipantsRemaining(self) -> int: ...
    @overload
    def RemoveParticipant() -> None: ...
    @overload
    def RemoveParticipants(self, participantCount: int) -> None: ...
    @overload
    def SignalAndWait() -> None: ...
    @overload
    def SignalAndWait(self, timeout: System.TimeSpan) -> bool: ...
    @overload
    def SignalAndWait(self, millisecondsTimeout: int) -> bool: ...
    @overload
    def SignalAndWait(self, cancellationToken: CancellationToken) -> None: ...
    @overload
    def SignalAndWait(self, timeout: System.TimeSpan, cancellationToken: CancellationToken) -> bool: ...
    @overload
    def SignalAndWait(self, millisecondsTimeout: int, cancellationToken: CancellationToken) -> bool: ...

class CountdownEvent(object):
    """    """
    def __init__(self, initialCount: int): ...
    @overload
    def AddCount() -> None: ...
    @overload
    def AddCount(self, signalCount: int) -> None: ...
    @overload
    def Dispose() -> None: ...
    @property
    def CurrentCount(self) -> int: ...
    @property
    def InitialCount(self) -> int: ...
    @property
    def IsSet(self) -> bool: ...
    @property
    def WaitHandle(self) -> WaitHandle: ...
    @overload
    def Reset() -> None: ...
    @overload
    def Reset(self, count: int) -> None: ...
    @overload
    def Signal() -> bool: ...
    @overload
    def Signal(self, signalCount: int) -> bool: ...
    @overload
    def TryAddCount() -> bool: ...
    @overload
    def TryAddCount(self, signalCount: int) -> bool: ...
    @overload
    def Wait() -> None: ...
    @overload
    def Wait(self, cancellationToken: CancellationToken) -> None: ...
    @overload
    def Wait(self, timeout: System.TimeSpan) -> bool: ...
    @overload
    def Wait(self, millisecondsTimeout: int) -> bool: ...
    @overload
    def Wait(self, timeout: System.TimeSpan, cancellationToken: CancellationToken) -> bool: ...
    @overload
    def Wait(self, millisecondsTimeout: int, cancellationToken: CancellationToken) -> bool: ...

class HostExecutionContext(object):
    """    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, state: object): ...
    @overload
    def CreateCopy() -> HostExecutionContext: ...
    @overload
    def Dispose() -> None: ...
    @overload
    def Dispose(self, disposing: bool) -> None: ...

class HostExecutionContextManager(object):
    """    """
    def __init__(self): ...
    @overload
    def Capture() -> HostExecutionContext: ...
    @overload
    def Revert(self, previousState: object) -> None: ...
    @overload
    def SetHostExecutionContext(self, hostExecutionContext: HostExecutionContext) -> object: ...

class LockCookie(System.ValueType):
    """    """
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Equals(self, obj: LockCookie) -> bool: ...
    @overload
    def GetHashCode() -> int: ...

class ReaderWriterLock(ConstrainedExecution.CriticalFinalizerObject):
    """    """
    def __init__(self): ...
    @overload
    def AcquireReaderLock(self, millisecondsTimeout: int) -> None: ...
    @overload
    def AcquireReaderLock(self, timeout: System.TimeSpan) -> None: ...
    @overload
    def AcquireWriterLock(self, millisecondsTimeout: int) -> None: ...
    @overload
    def AcquireWriterLock(self, timeout: System.TimeSpan) -> None: ...
    @overload
    def AnyWritersSince(self, seqNum: int) -> bool: ...
    @overload
    def DowngradeFromWriterLock() -> (LockCookie): ...
    @property
    def IsReaderLockHeld(self) -> bool: ...
    @property
    def IsWriterLockHeld(self) -> bool: ...
    @property
    def WriterSeqNum(self) -> int: ...
    @overload
    def ReleaseLock() -> LockCookie: ...
    @overload
    def ReleaseReaderLock() -> None: ...
    @overload
    def ReleaseWriterLock() -> None: ...
    @overload
    def RestoreLock() -> (LockCookie): ...
    @overload
    def UpgradeToWriterLock(self, timeout: System.TimeSpan) -> LockCookie: ...
    @overload
    def UpgradeToWriterLock(self, millisecondsTimeout: int) -> LockCookie: ...

# endregion

