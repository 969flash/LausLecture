"""this file is auto-generated by rhinocode stubmaker. do not make changes"""

# region: Exports
__all__ = ["IAssemblyRestrictedObject", "Notification", "ButtonType", "NotificationButtonClickedArgs", "NotificationCenter", "TrulyObservableOrderedSet", "Severity"]
# endregion

# region: Imports
from System.Collections import Generic
from System.Runtime import CompilerServices
from typing import overload
import enum
import System
# endregion

# region: RhinoCommon, Version=8.19.25132.1001

class IAssemblyRestrictedObject:
    """A class that implements this interface signals its clients that its instances can only be modified by certain assemblies. This is useful in cases where only certain assemblies should be able to modify an object. The actual members of an instance that are restricted are left to the discretion of the instance's class, and should be documented.

    """
    @overload
    def Editable() -> bool: ...

class Notification(object):
    """A Notification instance can be used to inform the user about various events. For a Notification instance to be displayed in Rhino, it must be added to the
. When added, it will be displayed in the Notifications panel in Rhino. A Notification contains 1 to 3 buttons that are automatically wired to its
Action if it is not null. The buttons are displayed when the Notification is shown modally by either the user clicking on a particular notification in the Notifications panel, or by programatically showing it using
. Currently, only process-wide notifications are supported; document specific notifications are not possible. Notification instances contain metadata that can be added, modified, or removed during its life. The metadata is important for LINQ queries and other patterns. For example, a particular action may require that multiple notifications be modified. Thus, a LINQ query can be performed on the
using metadata to retrieve related Notification objects and modify them as a batch. Notification objects implement
. By default, a Notification can be editedby any assembly, but explicitly specifing allowed assemblies in the constructor changes this behavior. Notification objects are not thread-safe and should only be manipulated in UI thread.

    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, allowedAssemblies: Generic.IEnumerable): ...
    @overload
    def Editable() -> bool: ...
    @overload
    @staticmethod
    def ExecuteAssemblyProtectedCode(func: System.Func) -> TResult: ...
    @overload
    @staticmethod
    def ExecuteAssemblyProtectedCode(action: System.Action) -> None: ...
    @property
    def AllowedAssemblies(self) -> Generic.ICollection: ...
    @property
    def AlternateButtonTitle(self) -> str: ...
    @property
    def ButtonClicked(self) -> System.Action: ...
    @property
    def CancelButtonTitle(self) -> str: ...
    @property
    def ConfirmButtonTitle(self) -> str: ...
    @property
    def DateUpdated(self) -> System.DateTime: ...
    @property
    def Description(self) -> str: ...
    @property
    def Item(self) -> str: ...
    @property
    def Message(self) -> str: ...
    @property
    def MetadataCopy(self) -> Generic.IDictionary: ...
    @property
    def SeverityLevel(self) -> Severity: ...
    @property
    def ShowEventId(self) -> System.Nullable: ...
    @property
    def Title(self) -> str: ...
    @overload
    def HideModal() -> None: ...
    @overload
    def RemoveMetadata(self, key: str) -> bool: ...
    @AlternateButtonTitle.setter
    def AlternateButtonTitle(self, value: System.Void): ...
    @ButtonClicked.setter
    def ButtonClicked(self, value: System.Void): ...
    @CancelButtonTitle.setter
    def CancelButtonTitle(self, value: System.Void): ...
    @ConfirmButtonTitle.setter
    def ConfirmButtonTitle(self, value: System.Void): ...
    @Description.setter
    def Description(self, value: System.Void): ...
    @Item.setter
    def Item(self, value: System.Void): ...
    @Message.setter
    def Message(self, value: System.Void): ...
    @SeverityLevel.setter
    def SeverityLevel(self, value: System.Void): ...
    @Title.setter
    def Title(self, value: System.Void): ...
    @overload
    def ShowModal() -> None: ...
    @overload
    def ToString() -> str: ...
    @property
    def PropertyChanged(self): ...

class ButtonType(enum.Enum):
    CancelOrClose = 0
    Confirm = 1
    Alternate = 2

class NotificationButtonClickedArgs(System.EventArgs):
    """Used when a button is clicked for a notification.

    """
    def __init__(self, notification: Notification, buttonClicked: ButtonType): ...
    @property
    def ButtonClicked(self) -> ButtonType: ...
    @property
    def Notification(self) -> Notification: ...

class NotificationCenter(object):
    """The NotificationCenter holds all
objects that are displayed in the Notifications panel by Rhino. The NotificationCenter is not thread-safe and should only be used in the UI thread.

    """
    @property
    def Notifications(self) -> TrulyObservableOrderedSet: ...

class TrulyObservableOrderedSet(object):
    """An ordered set that notifies its subscribers whenever one of its INotifyPropertyChanged elements raises its PropertyChanged event.

    TrulyObservableOrderedSet[T]
    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, items: Generic.IEnumerable): ...
    @overload
    def Add(self, item: T) -> None: ...
    @overload
    def Clear() -> None: ...
    @overload
    def Contains(self, item: T) -> bool: ...
    @overload
    def CopyTo(self, array: System.Array[T], arrayIndex: int) -> None: ...
    @property
    def Count(self) -> int: ...
    @property
    def IsReadOnly(self) -> bool: ...
    @property
    def Item(self) -> T: ...
    @overload
    def GetEnumerator() -> Generic.IEnumerator: ...
    @overload
    def IndexOf(self, item: T) -> int: ...
    @overload
    def Insert(self, index: int, item: T) -> None: ...
    @overload
    def Remove(self, item: T) -> bool: ...
    @overload
    def RemoveAt(self, index: int) -> None: ...
    @Item.setter
    def Item(self, value: System.Void): ...
    @overload
    def Sort(self, keySelector: System.Func, descending: bool) -> None: ...
    @property
    def CollectionChanged(self): ...

class Severity(enum.Enum):
    Debug = 0
    Info = 1
    Warning = 2
    Serious = 3
    Critical = 4

# endregion
