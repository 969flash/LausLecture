"""this file is auto-generated by rhinocode stubmaker. do not make changes"""

# region: Exports
__all__ = ["Morphs", "MeshRefinements", "Intersect", "Collections", "AnnotationType", "Dimension", "OrdinateDimension", "SubDComponentLocation", "SubDVertexTag", "SubDEdgeTag", "SubDEdgeType", "SubDHashType", "SubDToBrepOptions", "SubDFromSurfaceMethods", "SubDEndCapStyle", "SubDVertexFacetType", "SubDChainType", "SubDFriendlyKnotType", "SubDAutomaticMeshToSubDContext", "SubDPatchStyle", "SubD", "SubDCreationOptions", "SubDSurfaceInterpolator", "MeshPipeCapStyle", "MeshExtruderParameterMode", "MeshExtruderFaceDirectionMode", "MeshUnwrapMethod", "SquishDeformation", "SquishFlatteningAlgorithm", "FilletSurfaceSplitType", "RefitTrimSectionMode", "RefitTrimKnotMode", "TextJustification", "TextDot", "AnnotationBase", "InvalidDimensionStyleIdException", "ArcCurve", "Extrusion", "BezierCurve", "BezierSurface", "Box", "PipeCapMode", "LoftType", "ExtrudeCornerType", "BlendType", "RailType", "BrepEdgeFilletDistance", "SweepRebuild", "SweepFrame", "SweepBlend", "SweepMiter", "Brep", "PointFaceRelation", "BrepSolidOrientation", "EdgeAdjacency", "Concavity", "BrepVertex", "BrepEdge", "BrepTrimType", "BrepTrim", "BrepLoopType", "BrepLoop", "BrepFace", "BrepRegion", "BrepRegionFaceSide", "ComponentStatus", "CurveProxy", "DetailView", "LinearDimension", "AngularDimension", "RadialDimension", "Centermark", "Hatch", "HiddenLineDrawingParameters", "HiddenLineDrawing", "HiddenLineDrawingObject", "HiddenLineDrawingPoint", "HiddenLineDrawingObjectCurve", "HiddenLineDrawingSegment", "InstanceDefinitionGeometry", "InstanceReferenceGeometry", "Arrowhead", "Leader", "Light", "LineCurve", "AreaMassProperties", "VolumeMassProperties", "LengthMassProperties", "Matrix", "MeshingParameterStyle", "SmoothingCoordinateSystem", "MeshCheckParameters", "MeshingParameterTextureRange", "SubDDisplayParameters", "MeshingParameters", "MeshPart", "MeshThicknessMeasurement", "ReduceMeshParameters", "QuadRemeshParameters", "QuadRemeshSymmetryAxis", "ShrinkWrapParameters", "Mesh", "MeshBooleanOptions", "MeshUnsafeLock", "MeshFace", "MeshNgon", "ShutLiningCurveInfo", "MeshDisplacementInfo", "NurbsSurface", "MorphControl", "HermiteSurface", "PlaneSurface", "ClippingPlaneSurface", "MeshPoint", "SilhouetteType", "Silhouette", "PointCloudUnsafeLock", "PointCloudItem", "PointCloud", "Point", "Point3dGrid", "PolyCurve", "Polyline", "PolylineCurve", "Rectangle3d", "RevSurface", "RTreeEventArgs", "RTree", "SquishParameters", "Squisher", "SubDComponent", "SubDFace", "SubDVertex", "SubDEdge", "SumSurface", "IsoStatus", "SurfaceCurvature", "Surface", "SurfaceProxy", "TextRunType", "TextEntity", "DistancingMode", "MeshExtruder", "MeshUnwrapper", "Interpolator", "Particle", "ParticleSystem", "Arc", "BoundingBox", "Circle", "Cone", "BlendContinuity", "PreserveEnd", "CurveOffsetCornerStyle", "CurveOffsetEndStyle", "CurveKnotStyle", "CurveOrientation", "PointContainment", "RegionContainment", "CurveExtensionStyle", "CurveSimplifyOptions", "CurveEnd", "CurveEvaluationSide", "ConicSectionType", "CurveBooleanRegions", "Curve", "RibbonOffsetParameters", "RibbonOffsetSurfaceMethod", "Cylinder", "Ellipse", "GeometryBase", "Line", "Triangle3d", "KnotStyle", "NurbsCurve", "ControlPoint", "PlaneFitResult", "Plane", "Point2f", "Point3f", "Vector2f", "Vector3f", "Quaternion", "Sphere", "Torus", "Transform", "TransformSimilarityType", "TransformRigidType", "SpaceMorph", "Interval", "Point2d", "Point3d", "Point4d", "Vector2d", "Vector3d", "Ray3d", "Continuity", "MeshType", "LightStyle", "ComponentIndexType", "ComponentIndex", "SurfaceFilletBase", "SweepOneRail", "SweepTwoRail", "Unroller", "DevelopableSrf", "ForceArrow", "ForceText", "MeasuredDirection", "ExtraordinaryVertexProcessOption", "NurbsSurfaceType", "InteriorCreaseOption", "ConvexCornerOption", "ConcaveCornerOption", "TextureCoordinateOption", "MaximumCounts", "ShrinkDisableSide", "Visibility", "SideFill", "Attenuation", "Density", "NurbsCurveEndConditionType"]
# endregion

# region: Imports
from Rhino import ApplicationSettings
from Rhino import Collections
from Rhino import Commands
from Rhino import Display
from Rhino import DocObjects
from Rhino import FileIO
from Rhino import Render
from Rhino import Runtime
from Rhino.Geometry import Collections
from Rhino.Geometry import MeshRefinements
from System import Drawing
from System import Threading
from System.Collections import Generic
from System.Collections import ObjectModel
from System.Collections import Specialized
from System.Runtime import CompilerServices
from System.Runtime import Serialization
from System.Threading import Tasks
from typing import overload
import enum
import Rhino
import System
# endregion

# region: RhinoCommon, Version=8.19.25132.1001

class AnnotationType(enum.Enum):
    Unset = 0
    Aligned = 1
    Angular = 2
    Diameter = 3
    Radius = 4
    Rotated = 5
    Ordinate = 6
    ArcLen = 7
    CenterMark = 8
    Text = 9
    Leader = 10
    Angular3pt = 11

class Dimension(AnnotationBase):
    """Base class for dimensions

    """
    @overload
    def Explode() -> System.Array[GeometryBase]: ...
    @property
    def AlternateBelowLine(self) -> bool: ...
    @property
    def AltLengthFactor(self) -> float: ...
    @property
    def AltLengthResolution(self) -> int: ...
    @property
    def AltLengthRoundoff(self) -> float: ...
    @property
    def AltPrefix(self) -> str: ...
    @property
    def AltSuffix(self) -> str: ...
    @property
    def AltToleranceResolution(self) -> int: ...
    @property
    def AltUnitsDisplay(self) -> bool: ...
    @property
    def AltZeroSuppression(self) -> DocObjects.ZeroSuppression: ...
    @property
    def ArrowBlockId1(self) -> System.Guid: ...
    @property
    def ArrowBlockId2(self) -> System.Guid: ...
    @property
    def ArrowFit(self) -> DocObjects.ArrowFit: ...
    @property
    def ArrowheadType1(self) -> DocObjects.ArrowType: ...
    @property
    def ArrowheadType2(self) -> DocObjects.ArrowType: ...
    @property
    def ArrowSize(self) -> float: ...
    @property
    def BaselineSpacing(self) -> float: ...
    @property
    def CentermarkSize(self) -> float: ...
    @property
    def CentermarkStyle(self) -> DocObjects.CenterMarkStyle: ...
    @property
    def DetailMeasured(self) -> System.Guid: ...
    @property
    def DimensionLineExtension(self) -> float: ...
    @property
    def DistanceScale(self) -> float: ...
    @property
    def ExtensionLineExtension(self) -> float: ...
    @property
    def ExtensionLineOffset(self) -> float: ...
    @property
    def FixedExtensionLength(self) -> float: ...
    @property
    def FixedLengthExtensionOn(self) -> bool: ...
    @property
    def ForceArrowPosition(self) -> ForceArrow: ...
    @property
    def ForceDimensionLineBetweenExtensionLines(self) -> bool: ...
    @property
    def ForceDimLine(self) -> bool: ...
    @property
    def ForceTextPosition(self) -> ForceText: ...
    @property
    def LengthFactor(self) -> float: ...
    @property
    def LengthResolution(self) -> int: ...
    @property
    def LengthRoundoff(self) -> float: ...
    @property
    def NumericValue(self) -> float: ...
    @property
    def PlainUserText(self) -> str: ...
    @property
    def Prefix(self) -> str: ...
    @property
    def Suffix(self) -> str: ...
    @property
    def SuppressExtension1(self) -> bool: ...
    @property
    def SuppressExtension2(self) -> bool: ...
    @property
    def TextAngleType(self) -> DocObjects.LeaderContentAngleStyle: ...
    @property
    def TextFit(self) -> DocObjects.TextFit: ...
    @property
    def TextFormula(self) -> str: ...
    @property
    def TextLocation(self) -> DocObjects.TextLocation: ...
    @property
    def TextOrientation(self) -> DocObjects.TextOrientation: ...
    @property
    def TextPosition(self) -> Point2d: ...
    @property
    def TextRotation(self) -> float: ...
    @property
    def ToleranceFormat(self) -> DocObjects.ToleranceDisplayFormat: ...
    @property
    def ToleranceHeightScale(self) -> float: ...
    @property
    def ToleranceLowerValue(self) -> float: ...
    @property
    def ToleranceResolution(self) -> int: ...
    @property
    def ToleranceUpperValue(self) -> float: ...
    @property
    def UseDefaultTextPoint(self) -> bool: ...
    @property
    def ZeroSuppression(self) -> DocObjects.ZeroSuppression: ...
    @overload
    def GetTextTransform(self, viewport: DocObjects.ViewportInfo, style: DocObjects.DimensionStyle, textScale: float, drawForward: bool) -> Transform: ...
    @AlternateBelowLine.setter
    def AlternateBelowLine(self, value: System.Void): ...
    @AltLengthFactor.setter
    def AltLengthFactor(self, value: System.Void): ...
    @AltLengthResolution.setter
    def AltLengthResolution(self, value: System.Void): ...
    @AltLengthRoundoff.setter
    def AltLengthRoundoff(self, value: System.Void): ...
    @AltPrefix.setter
    def AltPrefix(self, value: System.Void): ...
    @AltSuffix.setter
    def AltSuffix(self, value: System.Void): ...
    @AltToleranceResolution.setter
    def AltToleranceResolution(self, value: System.Void): ...
    @AltUnitsDisplay.setter
    def AltUnitsDisplay(self, value: System.Void): ...
    @AltZeroSuppression.setter
    def AltZeroSuppression(self, value: System.Void): ...
    @ArrowBlockId1.setter
    def ArrowBlockId1(self, value: System.Void): ...
    @ArrowBlockId2.setter
    def ArrowBlockId2(self, value: System.Void): ...
    @ArrowFit.setter
    def ArrowFit(self, value: System.Void): ...
    @ArrowheadType1.setter
    def ArrowheadType1(self, value: System.Void): ...
    @ArrowheadType2.setter
    def ArrowheadType2(self, value: System.Void): ...
    @ArrowSize.setter
    def ArrowSize(self, value: System.Void): ...
    @BaselineSpacing.setter
    def BaselineSpacing(self, value: System.Void): ...
    @CentermarkSize.setter
    def CentermarkSize(self, value: System.Void): ...
    @CentermarkStyle.setter
    def CentermarkStyle(self, value: System.Void): ...
    @DetailMeasured.setter
    def DetailMeasured(self, value: System.Void): ...
    @DimensionLineExtension.setter
    def DimensionLineExtension(self, value: System.Void): ...
    @DistanceScale.setter
    def DistanceScale(self, value: System.Void): ...
    @ExtensionLineExtension.setter
    def ExtensionLineExtension(self, value: System.Void): ...
    @ExtensionLineOffset.setter
    def ExtensionLineOffset(self, value: System.Void): ...
    @FixedExtensionLength.setter
    def FixedExtensionLength(self, value: System.Void): ...
    @FixedLengthExtensionOn.setter
    def FixedLengthExtensionOn(self, value: System.Void): ...
    @ForceArrowPosition.setter
    def ForceArrowPosition(self, value: System.Void): ...
    @ForceDimensionLineBetweenExtensionLines.setter
    def ForceDimensionLineBetweenExtensionLines(self, value: System.Void): ...
    @ForceDimLine.setter
    def ForceDimLine(self, value: System.Void): ...
    @ForceTextPosition.setter
    def ForceTextPosition(self, value: System.Void): ...
    @LengthFactor.setter
    def LengthFactor(self, value: System.Void): ...
    @LengthResolution.setter
    def LengthResolution(self, value: System.Void): ...
    @LengthRoundoff.setter
    def LengthRoundoff(self, value: System.Void): ...
    @Prefix.setter
    def Prefix(self, value: System.Void): ...
    @Suffix.setter
    def Suffix(self, value: System.Void): ...
    @SuppressExtension1.setter
    def SuppressExtension1(self, value: System.Void): ...
    @SuppressExtension2.setter
    def SuppressExtension2(self, value: System.Void): ...
    @TextAngleType.setter
    def TextAngleType(self, value: System.Void): ...
    @TextFit.setter
    def TextFit(self, value: System.Void): ...
    @TextFormula.setter
    def TextFormula(self, value: System.Void): ...
    @TextLocation.setter
    def TextLocation(self, value: System.Void): ...
    @TextOrientation.setter
    def TextOrientation(self, value: System.Void): ...
    @TextPosition.setter
    def TextPosition(self, value: System.Void): ...
    @TextRotation.setter
    def TextRotation(self, value: System.Void): ...
    @ToleranceFormat.setter
    def ToleranceFormat(self, value: System.Void): ...
    @ToleranceHeightScale.setter
    def ToleranceHeightScale(self, value: System.Void): ...
    @ToleranceLowerValue.setter
    def ToleranceLowerValue(self, value: System.Void): ...
    @ToleranceResolution.setter
    def ToleranceResolution(self, value: System.Void): ...
    @ToleranceUpperValue.setter
    def ToleranceUpperValue(self, value: System.Void): ...
    @UseDefaultTextPoint.setter
    def UseDefaultTextPoint(self, value: System.Void): ...
    @ZeroSuppression.setter
    def ZeroSuppression(self, value: System.Void): ...
    @overload
    def SetAltDimensionLengthDisplayWithZeroSuppressionReset(self, ld: DocObjects.LengthDisplay) -> None: ...
    @overload
    def SetDimensionLengthDisplayWithZeroSuppressionReset(self, ld: DocObjects.LengthDisplay) -> None: ...
    @overload
    def UpdateDimensionText(self, style: DocObjects.DimensionStyle, units: Rhino.UnitSystem) -> None: ...

class OrdinateDimension(Dimension):
    """Represents an ordinate dimension

    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, plane: Plane, direction: MeasuredDirection, basepoint: Point3d, defpoint: Point3d, leaderpoint: Point3d, kinkoffset1: float, kinkoffset2: float): ...
    @overload
    def AdjustFromPoints(self, plane: Plane, direction: MeasuredDirection, basepoint: Point3d, defpoint: Point3d, leaderpoint: Point3d, kinkoffset1: float, kinkoffset2: float) -> bool: ...
    @overload
    @staticmethod
    def Create(dimStyle: DocObjects.DimensionStyle, plane: Plane, direction: MeasuredDirection, basepoint: Point3d, defpoint: Point3d, leaderpoint: Point3d, kinkoffset1: float, kinkoffset2: float) -> OrdinateDimension: ...
    @property
    def DefPoint(self) -> Point2d: ...
    @property
    def Direction(self) -> MeasuredDirection: ...
    @property
    def KinkOffset1(self) -> float: ...
    @property
    def KinkOffset2(self) -> float: ...
    @property
    def KinkPoint1(self) -> Point2d: ...
    @property
    def KinkPoint2(self) -> Point2d: ...
    @property
    def LeaderPoint(self) -> Point2d: ...
    @overload
    def Get3dPoints() -> (bool, Point3d, Point3d, Point3d, Point3d, Point3d): ...
    @overload
    def GetDisplayLines(self, style: DocObjects.DimensionStyle, scale: float) -> (bool, Generic.IEnumerable): ...
    @overload
    def GetDistanceDisplayText(self, unitsystem: Rhino.UnitSystem, style: DocObjects.DimensionStyle) -> str: ...
    @overload
    def GetTextRectangle() -> (bool, System.Array[Point3d]): ...
    @DefPoint.setter
    def DefPoint(self, value: System.Void): ...
    @Direction.setter
    def Direction(self, value: System.Void): ...
    @KinkOffset1.setter
    def KinkOffset1(self, value: System.Void): ...
    @KinkOffset2.setter
    def KinkOffset2(self, value: System.Void): ...
    @LeaderPoint.setter
    def LeaderPoint(self, value: System.Void): ...

class SubDComponentLocation(enum.Enum):
    Unset = 0
    ControlNet = 1
    Surface = 2

class SubDVertexTag(enum.Enum):
    Unset = 0
    Smooth = 1
    Crease = 2
    Corner = 3
    Dart = 4

class SubDEdgeTag(enum.Enum):
    Unset = 0
    Smooth = 1
    Crease = 2
    SmoothX = 4

class SubDEdgeType(enum.Enum):
    Unset = 0
    Wire = 1
    Boundary = 2
    InteriorSmooth = 4
    InteriorSharp = 8
    InteriorCrease = 16
    InteriorMask = 28
    Nonmanifold = 32
    ValidTypesMask = 63
    Invalid = 64

class SubDHashType(enum.Enum):
    Unset = 0
    TopologyAndEdgeCreases = 1
    Geometry = 2
    Topology = 3

class SubDToBrepOptions(object):
    """Options used for converting a SubD to a Brep

    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, packFaces: bool, vertexProcess: ExtraordinaryVertexProcessOption): ...
    @overload
    def Dispose() -> None: ...
    @property
    def Default(self) -> SubDToBrepOptions: ...
    @property
    def DefaultPacked(self) -> SubDToBrepOptions: ...
    @property
    def DefaultUnpacked(self) -> SubDToBrepOptions: ...
    @property
    def ExtraordinaryVertexProcess(self) -> ExtraordinaryVertexProcessOption: ...
    @property
    def PackFaces(self) -> bool: ...
    @ExtraordinaryVertexProcess.setter
    def ExtraordinaryVertexProcess(self, value: System.Void): ...
    @PackFaces.setter
    def PackFaces(self, value: System.Void): ...

class SubDFromSurfaceMethods(enum.Enum):
    Unset = 0
    SubDFriendlyFit = 1
    FromNurbsControlNet = 2

class SubDEndCapStyle(enum.Enum):
    Unset = 0
    None_ = 1
    Triangles = 2
    Quads = 3
    Ngon = 4

class SubDVertexFacetType(enum.Enum):
    Unset = 0
    Tri = 3
    Quad = 4
    Ngon = 5
    Mixed = 255

class SubDChainType(enum.Enum):
    Unset = 0
    MixedTag = 1
    EqualEdgeTag = 2
    EqualEdgeAndVertexTag = 3
    EqualEdgeTagAndOrdinary = 4
    EqualEdgeAndVertexTagAndOrdinary = 5

class SubDFriendlyKnotType(enum.Enum):
    Unset = 0
    UnclampedUniform = 1
    ClampedUniform = 2
    ClampedPiecewiseUniform = 4
    Unfriendly = 127

class SubDAutomaticMeshToSubDContext(enum.Enum):
    Unset = 0
    Rhino5BoxModeTSpline = 1
    FBXMeshWithDivisionLevels = 2

class SubDPatchStyle(enum.Enum):
    Unset = 0
    Automatic = 1
    SingleFace = 2
    TriangleFan = 3
    QuadOrTriangleFan = 4
    Triangulated = 5

class SubD(GeometryBase):
    """Subdivision surface

    """
    def __init__(self): ...
    @overload
    def ClearEvaluationCache() -> None: ...
    @overload
    def ComponentFromComponentIndex(self, componentIndex: ComponentIndex) -> SubDComponent: ...
    @overload
    def CopyEvaluationCache() -> (bool, SubD): ...
    @overload
    @staticmethod
    def CreateFromCylinder(cylinder: Cylinder, circumferenceFaceCount: System.UInt32, heightFaceCount: System.UInt32, endCapStyle: SubDEndCapStyle, endCapEdgeTag: SubDEdgeTag, radiusLocation: SubDComponentLocation) -> SubD: ...
    @overload
    @staticmethod
    def CreateFromLoft(curves: Generic.IEnumerable, closed: bool, addCorners: bool, addCreases: bool, divisions: int) -> SubD: ...
    @overload
    @staticmethod
    def CreateFromMesh(mesh: Mesh) -> SubD: ...
    @overload
    @staticmethod
    def CreateFromMesh(mesh: Mesh, options: SubDCreationOptions) -> SubD: ...
    @overload
    @staticmethod
    def CreateFromSurface(surface: Surface, method: SubDFromSurfaceMethods, corners: bool) -> SubD: ...
    @overload
    @staticmethod
    def CreateFromSweep(rail1: NurbsCurve, rail2: NurbsCurve, shapes: Generic.IEnumerable, closed: bool, addCorners: bool) -> SubD: ...
    @overload
    @staticmethod
    def CreateFromSweep(rail1: NurbsCurve, shapes: Generic.IEnumerable, closed: bool, addCorners: bool, roadlikeFrame: bool, roadlikeNormal: Vector3d) -> SubD: ...
    @overload
    @staticmethod
    def CreateGlobeSphere(sphere: Sphere, vertexLocation: SubDComponentLocation, axialFaceCount: System.UInt32, equatorialFaceCount: System.UInt32) -> SubD: ...
    @overload
    @staticmethod
    def CreateIcosahedron(sphere: Sphere, vertexLocation: SubDComponentLocation) -> SubD: ...
    @overload
    @staticmethod
    def CreateQuadSphere(sphere: Sphere, vertexLocation: SubDComponentLocation, quadSubdivisionLevel: System.UInt32) -> SubD: ...
    @overload
    @staticmethod
    def CreateTriSphere(sphere: Sphere, vertexLocation: SubDComponentLocation, triSubdivisionLevel: System.UInt32) -> SubD: ...
    @overload
    def DuplicateEdgeCurves() -> System.Array[Curve]: ...
    @overload
    def DuplicateEdgeCurves(self, boundaryOnly: bool, interiorOnly: bool, smoothOnly: bool, sharpOnly: bool, creaseOnly: bool, clampEnds: bool) -> System.Array[Curve]: ...
    @overload
    def Flip() -> bool: ...
    @property
    def Edges(self) -> Collections.SubDEdgeList: ...
    @property
    def Empty(self) -> SubD: ...
    @property
    def Faces(self) -> Collections.SubDFaceList: ...
    @property
    def IsSolid(self) -> bool: ...
    @property
    def Vertices(self) -> Collections.SubDVertexList: ...
    @overload
    def InterpolateSurfacePoints(self, surfacePoints: System.Array[Point3d]) -> bool: ...
    @overload
    def InterpolateSurfacePoints(self, vertexIndices: System.System.Array[System.UInt32], surfacePoints: System.Array[Point3d]) -> bool: ...
    @overload
    @staticmethod
    def JoinSubDs(subdsToJoin: Generic.IEnumerable, tolerance: float, joinedEdgesAreCreases: bool) -> System.Array[SubD]: ...
    @overload
    @staticmethod
    def JoinSubDs(subdsToJoin: Generic.IEnumerable, tolerance: float, joinedEdgesAreCreases: bool, preserveSymmetry: bool) -> System.Array[SubD]: ...
    @overload
    def MergeAllCoplanarFaces(self, tolerance: float) -> bool: ...
    @overload
    def MergeAllCoplanarFaces(self, tolerance: float, angleTolerance: float) -> bool: ...
    @overload
    def Offset(self, distance: float, solidify: bool) -> SubD: ...
    @overload
    def PackFaces() -> System.UInt32: ...
    @overload
    def SetVertexSurfacePoint(self, vertexIndex: System.UInt32, surfacePoint: Point3d) -> bool: ...
    @overload
    def Subdivide() -> bool: ...
    @overload
    def Subdivide(self, count: int) -> bool: ...
    @overload
    def Subdivide(self, faceIndices: Generic.IEnumerable) -> bool: ...
    @overload
    def SurfaceMeshCacheExists(self, bTextureCoordinatesExist: bool, bCurvaturesExist: bool, bColorsExist: bool) -> bool: ...
    @overload
    def ToBrep() -> Brep: ...
    @overload
    def ToBrep(self, options: SubDToBrepOptions) -> Brep: ...
    @overload
    def TransformComponents(self, components: Generic.IEnumerable, xform: Transform, componentLocation: SubDComponentLocation) -> System.UInt32: ...
    @overload
    def UpdateAllTagsAndSectorCoefficients() -> System.UInt32: ...
    @overload
    def UpdateSurfaceMeshCache(self, lazyUpdate: bool) -> System.UInt32: ...

class SubDCreationOptions(object):
    """Options used for creating a SubD

    """
    def __init__(self): ...
    @overload
    def Dispose() -> None: ...
    @property
    def ConcaveCornerTest(self) -> ConcaveCornerOption: ...
    @property
    def ConvexAndConcaveCornersAndInteriorCreases(self) -> SubDCreationOptions: ...
    @property
    def ConvexCornersAndInteriorCreases(self) -> SubDCreationOptions: ...
    @property
    def ConvexCornerTest(self) -> ConvexCornerOption: ...
    @property
    def InteriorCreases(self) -> SubDCreationOptions: ...
    @property
    def InteriorCreaseTest(self) -> InteriorCreaseOption: ...
    @property
    def InterpolateMeshVertices(self) -> bool: ...
    @property
    def MaximumConvexCornerAngleRadians(self) -> float: ...
    @property
    def MaximumConvexCornerEdgeCount(self) -> System.UInt32: ...
    @property
    def MinimumConcaveCornerAngleRadians(self) -> float: ...
    @property
    def MinimumConcaveCornerEdgeCount(self) -> System.UInt32: ...
    @property
    def Smooth(self) -> SubDCreationOptions: ...
    @ConcaveCornerTest.setter
    def ConcaveCornerTest(self, value: System.Void): ...
    @ConvexCornerTest.setter
    def ConvexCornerTest(self, value: System.Void): ...
    @InteriorCreaseTest.setter
    def InteriorCreaseTest(self, value: System.Void): ...
    @InterpolateMeshVertices.setter
    def InterpolateMeshVertices(self, value: System.Void): ...
    @MaximumConvexCornerAngleRadians.setter
    def MaximumConvexCornerAngleRadians(self, value: System.Void): ...
    @MaximumConvexCornerEdgeCount.setter
    def MaximumConvexCornerEdgeCount(self, value: System.Void): ...
    @MinimumConcaveCornerAngleRadians.setter
    def MinimumConcaveCornerAngleRadians(self, value: System.Void): ...
    @MinimumConcaveCornerEdgeCount.setter
    def MinimumConcaveCornerEdgeCount(self, value: System.Void): ...

class SubDSurfaceInterpolator(object):
    """Interpolate some or all of the vertices limit surface positions in a SubD to specified locations. NB: It is recommended not to use these methods to interpolate more than 1000 vertices.

    """
    def __init__(self): ...
    @overload
    def Clear() -> None: ...
    @overload
    @staticmethod
    def CreateFromMarkedVertices(subd: SubD, interpolatedVerticesMark: bool) -> (SubDSurfaceInterpolator, System.UInt32): ...
    @overload
    @staticmethod
    def CreateFromSelectedVertices(subd: SubD) -> (SubDSurfaceInterpolator, System.UInt32): ...
    @overload
    @staticmethod
    def CreateFromSubD(subd: SubD) -> (SubDSurfaceInterpolator, System.UInt32): ...
    @overload
    @staticmethod
    def CreateFromVertexIdList(subd: SubD, vertexIndices: Generic.IEnumerable) -> (SubDSurfaceInterpolator, System.UInt32): ...
    @overload
    def Dispose() -> None: ...
    @overload
    def FixedVertexCount() -> System.UInt32: ...
    @property
    def ContextId(self) -> System.Guid: ...
    @property
    def MaximumRecommendedInterpolatedVertexCount(self) -> System.UInt32: ...
    @overload
    def InterpolatedVertexCount() -> System.UInt32: ...
    @overload
    def InterpolatedVertexIndex(self, vertexId: System.UInt32) -> System.UInt32: ...
    @overload
    def IsInterpolatedVertex(self, vertexId: System.UInt32) -> bool: ...
    @overload
    def IsInterpolatedVertex(self, vertex: SubDVertex) -> bool: ...
    @ContextId.setter
    def ContextId(self, value: System.Void): ...
    @overload
    def Solve(self, surfacePoints: System.Array[Point3d]) -> bool: ...
    @overload
    def Transform(self, transform: Transform) -> None: ...
    @overload
    def VertexIdList() -> System.System.Array[System.UInt32]: ...

class MeshPipeCapStyle(enum.Enum):
    None_ = 0
    Flat = 1
    Box = 2
    Dome = 3

class MeshExtruderParameterMode(enum.Enum):
    CoverWalls = 0
    KeepAndStretch = 1

class MeshExtruderFaceDirectionMode(enum.Enum):
    Keep = 0
    OrientClosedFrontOut = 1

class MeshUnwrapMethod(enum.Enum):
    LSCM = 0
    ABFPP = 1
    ARAP = 2

class SquishDeformation(enum.Enum):
    Free = 0
    StretchMostly = 1
    StretchOnly = 2
    CompressMostly = 3
    CompressOnly = 4
    Custom = 5

class SquishFlatteningAlgorithm(enum.Enum):
    Geometric = 0
    PhysicalStress = 1

class FilletSurfaceSplitType(enum.Enum):
    Nothing = 0
    Trim = 1
    Split = 2

class RefitTrimSectionMode(enum.Enum):
    NoSections = 0
    DivideAtInputKnots = 1
    DivideAtAddedKnots = 2
    DivideAtAllKnots = 3

class RefitTrimKnotMode(enum.Enum):
    None_ = 0
    UniformEntireSurface = 1
    UniformPerSpan = 2
    Custom = 3

class TextJustification(enum.Enum):
    None_ = 0
    Left = 1
    Center = 2
    Right = 4
    Bottom = 65536
    BottomLeft = 65537
    BottomCenter = 65538
    BottomRight = 65540
    Middle = 131072
    MiddleLeft = 131073
    MiddleCenter = 131074
    MiddleRight = 131076
    Top = 262144
    TopLeft = 262145
    TopCenter = 262146
    TopRight = 262148

class TextDot(GeometryBase):
    """Represents a text dot, or an annotation entity with text that always faces the camera and always has the same size.
This class refers to the geometric element that is independent from the document.

    """
    def __init__(self, text: str, location: Point3d): ...
    @property
    def FontFace(self) -> str: ...
    @property
    def FontHeight(self) -> int: ...
    @property
    def Point(self) -> Point3d: ...
    @property
    def SecondaryText(self) -> str: ...
    @property
    def Text(self) -> str: ...
    @FontFace.setter
    def FontFace(self, value: System.Void): ...
    @FontHeight.setter
    def FontHeight(self, value: System.Void): ...
    @Point.setter
    def Point(self, value: System.Void): ...
    @SecondaryText.setter
    def SecondaryText(self, value: System.Void): ...
    @Text.setter
    def Text(self, value: System.Void): ...

class AnnotationBase(GeometryBase):
    """Provides a common base class to all annotation geometry.
This class refers to the geometric element that is independent from the document.

    """
    @overload
    def ClearPropertyOverrides() -> bool: ...
    @overload
    @staticmethod
    def FirstCharProperties(rtf_str: str) -> (bool, bool, bool, bool, str): ...
    @overload
    @staticmethod
    def FormatRtfString(rtf_in: str, clear_bold: bool, set_bold: bool, clear_italic: bool, set_italic: bool, clear_underline: bool, set_underline: bool, clear_facename: bool, set_facename: bool, facename: str) -> str: ...
    @property
    def AlternateDimensionLengthDisplay(self) -> DocObjects.LengthDisplay: ...
    @property
    def AnnotationType(self) -> AnnotationType: ...
    @property
    def DecimalSeparator(self) -> System.Char: ...
    @property
    def DimensionLengthDisplay(self) -> DocObjects.LengthDisplay: ...
    @property
    def DimensionScale(self) -> float: ...
    @property
    def DimensionStyle(self) -> DocObjects.DimensionStyle: ...
    @property
    def DimensionStyleId(self) -> System.Guid: ...
    @property
    def DrawForward(self) -> bool: ...
    @property
    def DrawTextFrame(self) -> bool: ...
    @property
    def FirstCharFont(self) -> DocObjects.Font: ...
    @property
    def Font(self) -> DocObjects.Font: ...
    @property
    def FontIndex(self) -> int: ...
    @property
    def FormatWidth(self) -> float: ...
    @property
    def HasPropertyOverrides(self) -> bool: ...
    @property
    def MaskColor(self) -> Drawing.Color: ...
    @property
    def MaskColorSource(self) -> DocObjects.MaskType: ...
    @property
    def MaskEnabled(self) -> bool: ...
    @property
    def MaskFrame(self) -> DocObjects.MaskFrame: ...
    @property
    def MaskOffset(self) -> float: ...
    @property
    def MaskUsesViewportColor(self) -> bool: ...
    @property
    def ParentDimensionStyle(self) -> DocObjects.DimensionStyle: ...
    @property
    def PlainText(self) -> str: ...
    @property
    def PlainTextWithFields(self) -> str: ...
    @property
    def Plane(self) -> Plane: ...
    @property
    def RichText(self) -> str: ...
    @property
    def Text(self) -> str: ...
    @property
    def TextFormula(self) -> str: ...
    @property
    def TextHasRtfFormatting(self) -> bool: ...
    @property
    def TextHeight(self) -> float: ...
    @property
    def TextIsWrapped(self) -> bool: ...
    @property
    def TextModelWidth(self) -> float: ...
    @property
    def TextRotationDegrees(self) -> float: ...
    @property
    def TextRotationRadians(self) -> float: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    @staticmethod
    def GetDimensionScale(doc: Rhino.RhinoDoc, dimstyle: DocObjects.DimensionStyle, vport: Display.RhinoViewport) -> float: ...
    @overload
    def GetDimensionStyle(self, parentDimStyle: DocObjects.DimensionStyle) -> DocObjects.DimensionStyle: ...
    @overload
    def GetPlainTextWithRunMap() -> (str, System.System.Array[int]): ...
    @overload
    def IsAllBold() -> bool: ...
    @overload
    def IsAllItalic() -> bool: ...
    @overload
    def IsAllUnderlined() -> bool: ...
    @overload
    def IsPropertyOverridden(self, field: DocObjects.Field) -> bool: ...
    @overload
    @staticmethod
    def PlainTextToRtf(str_: str) -> str: ...
    @overload
    def RunReplace(self, replaceString: str, startRunIndex: int, startRunPosition: int, endRunIndex: int, endRunPosition: int) -> bool: ...
    @AlternateDimensionLengthDisplay.setter
    def AlternateDimensionLengthDisplay(self, value: System.Void): ...
    @DecimalSeparator.setter
    def DecimalSeparator(self, value: System.Void): ...
    @DimensionLengthDisplay.setter
    def DimensionLengthDisplay(self, value: System.Void): ...
    @DimensionScale.setter
    def DimensionScale(self, value: System.Void): ...
    @DimensionStyleId.setter
    def DimensionStyleId(self, value: System.Void): ...
    @DrawForward.setter
    def DrawForward(self, value: System.Void): ...
    @DrawTextFrame.setter
    def DrawTextFrame(self, value: System.Void): ...
    @Font.setter
    def Font(self, value: System.Void): ...
    @FontIndex.setter
    def FontIndex(self, value: System.Void): ...
    @FormatWidth.setter
    def FormatWidth(self, value: System.Void): ...
    @MaskColor.setter
    def MaskColor(self, value: System.Void): ...
    @MaskColorSource.setter
    def MaskColorSource(self, value: System.Void): ...
    @MaskEnabled.setter
    def MaskEnabled(self, value: System.Void): ...
    @MaskFrame.setter
    def MaskFrame(self, value: System.Void): ...
    @MaskOffset.setter
    def MaskOffset(self, value: System.Void): ...
    @MaskUsesViewportColor.setter
    def MaskUsesViewportColor(self, value: System.Void): ...
    @ParentDimensionStyle.setter
    def ParentDimensionStyle(self, value: System.Void): ...
    @PlainText.setter
    def PlainText(self, value: System.Void): ...
    @Plane.setter
    def Plane(self, value: System.Void): ...
    @RichText.setter
    def RichText(self, value: System.Void): ...
    @Text.setter
    def Text(self, value: System.Void): ...
    @TextFormula.setter
    def TextFormula(self, value: System.Void): ...
    @TextHeight.setter
    def TextHeight(self, value: System.Void): ...
    @TextIsWrapped.setter
    def TextIsWrapped(self, value: System.Void): ...
    @TextRotationDegrees.setter
    def TextRotationDegrees(self, value: System.Void): ...
    @TextRotationRadians.setter
    def TextRotationRadians(self, value: System.Void): ...
    @overload
    def SetBold(self, set_on: bool) -> bool: ...
    @overload
    def SetFacename(self, set_on: bool, facename: str) -> bool: ...
    @overload
    def SetItalic(self, set_on: bool) -> bool: ...
    @overload
    def SetOverrideDimStyle(self, OverrideStyle: DocObjects.DimensionStyle) -> bool: ...
    @overload
    def SetRichText(self, rtfText: str, dimstyle: DocObjects.DimensionStyle) -> None: ...
    @overload
    def SetUnderline(self, set_on: bool) -> bool: ...
    @overload
    def WrapText() -> None: ...

class InvalidDimensionStyleIdException(System.InvalidOperationException):
    """General exception that can be thrown by annotations

    """
    def __init__(self, msg: str): ...

class ArcCurve(Curve):
    """Represent arcs and circles.
ArcCurve.IsCircle returns true if the curve is a complete circle.

    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: ArcCurve): ...
    @overload
    def __init__(self, arc: Arc): ...
    @overload
    def __init__(self, circle: Circle): ...
    @overload
    def __init__(self, arc: Arc, t0: float, t1: float): ...
    @overload
    def __init__(self, circle: Circle, t0: float, t1: float): ...
    @property
    def AngleDegrees(self) -> float: ...
    @property
    def AngleRadians(self) -> float: ...
    @property
    def Arc(self) -> Arc: ...
    @property
    def IsCompleteCircle(self) -> bool: ...
    @property
    def Radius(self) -> float: ...

class Extrusion(Surface):
    """Represents an extrusion, or objects such as beams or linearly extruded elements, that can be represented by profile curves and two miter planes at the extremes.

    """
    def __init__(self): ...
    @overload
    def AddInnerProfile(self, innerProfile: Curve) -> bool: ...
    @overload
    @staticmethod
    def Create(planarCurve: Curve, height: float, cap: bool) -> Extrusion: ...
    @overload
    @staticmethod
    def Create(curve: Curve, plane: Plane, height: float, cap: bool) -> Extrusion: ...
    @overload
    @staticmethod
    def CreateBoxExtrusion(box: Box, cap: bool) -> Extrusion: ...
    @overload
    @staticmethod
    def CreateCylinderExtrusion(cylinder: Cylinder, capBottom: bool, capTop: bool) -> Extrusion: ...
    @overload
    @staticmethod
    def CreatePipeExtrusion(cylinder: Cylinder, otherRadius: float, capTop: bool, capBottom: bool) -> Extrusion: ...
    @property
    def CapCount(self) -> int: ...
    @property
    def IsCappedAtBottom(self) -> bool: ...
    @property
    def IsCappedAtTop(self) -> bool: ...
    @property
    def IsMiteredAtEnd(self) -> bool: ...
    @property
    def IsMiteredAtStart(self) -> bool: ...
    @property
    def IsSolid(self) -> bool: ...
    @property
    def MiterPlaneNormalAtEnd(self) -> Vector3d: ...
    @property
    def MiterPlaneNormalAtStart(self) -> Vector3d: ...
    @property
    def PathEnd(self) -> Point3d: ...
    @property
    def PathStart(self) -> Point3d: ...
    @property
    def PathTangent(self) -> Vector3d: ...
    @property
    def ProfileCount(self) -> int: ...
    @overload
    def GetBrepFormComponentIndex(self, extrusionComponentIndex: ComponentIndex) -> ComponentIndex: ...
    @overload
    def GetMesh(self, meshType: MeshType) -> Mesh: ...
    @overload
    def GetPathPlane(self, s: float) -> Plane: ...
    @overload
    def GetProfilePlane(self, s: float) -> Plane: ...
    @overload
    def GetProfileTransformation(self, s: float) -> Transform: ...
    @overload
    def GetWireframe() -> System.Array[Curve]: ...
    @overload
    def PathLineCurve() -> LineCurve: ...
    @overload
    def Profile3d(self, ci: ComponentIndex) -> Curve: ...
    @overload
    def Profile3d(self, profileIndex: int, s: float) -> Curve: ...
    @overload
    def ProfileIndex(self, profileParameter: float) -> int: ...
    @MiterPlaneNormalAtEnd.setter
    def MiterPlaneNormalAtEnd(self, value: System.Void): ...
    @MiterPlaneNormalAtStart.setter
    def MiterPlaneNormalAtStart(self, value: System.Void): ...
    @overload
    def SetMesh(self, mesh: Mesh, meshType: MeshType) -> bool: ...
    @overload
    def SetOuterProfile(self, outerProfile: Curve, cap: bool) -> bool: ...
    @overload
    def SetPathAndUp(self, a: Point3d, b: Point3d, up: Vector3d) -> bool: ...
    @overload
    def ToBrep(self, splitKinkyFaces: bool) -> Brep: ...
    @overload
    def WallEdge(self, ci: ComponentIndex) -> Curve: ...
    @overload
    def WallSurface(self, ci: ComponentIndex) -> Surface: ...

class BezierCurve(object):
    """Represents a Bezier curve.
Note: as an exception, the bezier curve
is not
derived from
.

    """
    @overload
    def __init__(self, controlPoints: Generic.IEnumerable): ...
    @overload
    def __init__(self, controlPoints: Generic.IEnumerable): ...
    @overload
    def __init__(self, controlPoints: Generic.IEnumerable): ...
    @overload
    def ChangeDimension(self, desiredDimension: int) -> bool: ...
    @overload
    @staticmethod
    def CreateBeziers(sourceCurve: Curve) -> System.Array[BezierCurve]: ...
    @overload
    @staticmethod
    def CreateCubicBeziers(sourceCurve: Curve, distanceTolerance: float, kinkTolerance: float) -> System.Array[BezierCurve]: ...
    @overload
    @staticmethod
    def CreateLoftedBezier(points: Generic.IEnumerable) -> BezierCurve: ...
    @overload
    @staticmethod
    def CreateLoftedBezier(points: Generic.IEnumerable) -> BezierCurve: ...
    @overload
    def CurvatureAt(self, t: float) -> Vector3d: ...
    @overload
    def Dispose() -> None: ...
    @property
    def ControlVertexCount(self) -> int: ...
    @property
    def Dimension(self) -> int: ...
    @property
    def IsRational(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetControlVertex2d(self, index: int) -> Point2d: ...
    @overload
    def GetControlVertex3d(self, index: int) -> Point3d: ...
    @overload
    def GetControlVertex4d(self, index: int) -> Point4d: ...
    @overload
    def GetObjectData(self, info: Serialization.SerializationInfo, context: Serialization.StreamingContext) -> None: ...
    @overload
    def IncreaseDegree(self, desiredDegree: int) -> bool: ...
    @overload
    def MakeNonRational() -> bool: ...
    @overload
    def MakeRational() -> bool: ...
    @overload
    def PointAt(self, t: float) -> Point3d: ...
    @overload
    def Split(self, t: float) -> (bool, BezierCurve, BezierCurve): ...
    @overload
    def TangentAt(self, t: float) -> Vector3d: ...
    @overload
    def ToNurbsCurve() -> NurbsCurve: ...

class BezierSurface(object):
    """Represents a Bezier surface.

    """
    @overload
    def ControlVertexCount(self, direction: int) -> int: ...
    @overload
    @staticmethod
    def CreateLoftedBezier(curves: Generic.IEnumerable) -> BezierSurface: ...
    @overload
    def Dispose() -> None: ...
    @overload
    def Domain(self, direction: int) -> Interval: ...
    @property
    def Dimension(self) -> int: ...
    @property
    def IsRational(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetControlVertex2d(self, i: int, j: int) -> Point2d: ...
    @overload
    def GetControlVertex3d(self, i: int, j: int) -> Point3d: ...
    @overload
    def GetControlVertex4d(self, i: int, j: int) -> Point4d: ...
    @overload
    def MakeNonRational() -> bool: ...
    @overload
    def MakeRational() -> bool: ...
    @overload
    def PointAt(self, u: float, v: float) -> Point3d: ...
    @overload
    def Reverse(self, direction: int) -> BezierSurface: ...
    @overload
    def Split(self, direction: int, t: float) -> (bool, BezierSurface, BezierSurface): ...
    @overload
    def ToNurbsSurface() -> NurbsSurface: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Transpose() -> BezierSurface: ...

class Box(System.ValueType):
    """Represents the value of a plane and three intervals in an orthogonal, oriented box that is not necessarily parallel to the world Y, X, Z axes.

    """
    @overload
    def __init__(self, other: Box): ...
    @overload
    def __init__(self, bbox: BoundingBox): ...
    @overload
    def __init__(self, basePlane: Plane, points: Generic.IEnumerable): ...
    @overload
    def __init__(self, basePlane: Plane, geometry: GeometryBase): ...
    @overload
    def __init__(self, basePlane: Plane, boundingbox: BoundingBox): ...
    @overload
    def __init__(self, basePlane: Plane, xSize: Interval, ySize: Interval, zSize: Interval): ...
    @overload
    def ClosestPoint(self, point: Point3d) -> Point3d: ...
    @overload
    def Contains(self, box: BoundingBox) -> bool: ...
    @overload
    def Contains(self, point: Point3d) -> bool: ...
    @overload
    def Contains(self, box: Box) -> bool: ...
    @overload
    def Contains(self, box: BoundingBox, strict: bool) -> bool: ...
    @overload
    def Contains(self, box: Box, strict: bool) -> bool: ...
    @overload
    def Contains(self, point: Point3d, strict: bool) -> bool: ...
    @overload
    def EpsilonEquals(self, other: Box, epsilon: float) -> bool: ...
    @overload
    def FurthestPoint(self, point: Point3d) -> Point3d: ...
    @property
    def Area(self) -> float: ...
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @property
    def Center(self) -> Point3d: ...
    @property
    def Empty(self) -> Box: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Plane(self) -> Plane: ...
    @property
    def Unset(self) -> Box: ...
    @property
    def Volume(self) -> float: ...
    @property
    def X(self) -> Interval: ...
    @property
    def Y(self) -> Interval: ...
    @property
    def Z(self) -> Interval: ...
    @overload
    def GetCorners() -> System.Array[Point3d]: ...
    @overload
    def Inflate(self, amount: float) -> None: ...
    @overload
    def Inflate(self, xAmount: float, yAmount: float, zAmount: float) -> None: ...
    @overload
    def MakeValid() -> bool: ...
    @overload
    def PointAt(self, x: float, y: float, z: float) -> Point3d: ...
    @overload
    def RepositionBasePlane(self, origin: Point3d) -> None: ...
    @Plane.setter
    def Plane(self, value: System.Void): ...
    @X.setter
    def X(self, value: System.Void): ...
    @Y.setter
    def Y(self, value: System.Void): ...
    @Z.setter
    def Z(self, value: System.Void): ...
    @overload
    def ToBrep() -> Brep: ...
    @overload
    def ToExtrusion() -> Extrusion: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Union(self, point: Point3d) -> None: ...

class PipeCapMode(enum.Enum):
    None_ = 0
    Flat = 1
    Round = 2

class LoftType(enum.Enum):
    Normal = 0
    Loose = 1
    Tight = 2
    Straight = 3
    Developable = 4
    Uniform = 5

class ExtrudeCornerType(enum.Enum):
    None_ = 0
    Sharp = 1
    Round = 2
    Smooth = 3
    Chamfer = 4

class BlendType(enum.Enum):
    Chamfer = 0
    Fillet = 1
    Blend = 2

class RailType(enum.Enum):
    DistanceFromEdge = 0
    RollingBall = 1
    DistanceBetweenRails = 2

class BrepEdgeFilletDistance(object):
    """Fillet distances along a BrepEdge

    """
    def __init__(self, edgeParameter: float, filletDistance: float): ...
    @property
    def EdgeParameter(self) -> float: ...
    @property
    def FilletDistance(self) -> float: ...

class SweepRebuild(enum.Enum):
    None_ = 0
    Rebuild = 1
    Refit = 2

class SweepFrame(enum.Enum):
    Freeform = 0
    Roadlike = 1

class SweepBlend(enum.Enum):
    Local = 0
    Global = 1

class SweepMiter(enum.Enum):
    None_ = 0
    Trimmed = 1
    Untrimmed = 2

class Brep(GeometryBase):
    """Boundary Representation. A surface or polysurface along with trim curve information.

    """
    def __init__(self): ...
    @overload
    def AddEdgeCurve(self, curve: Curve) -> int: ...
    @overload
    def AddSurface(self, surface: Surface) -> int: ...
    @overload
    def AddTrimCurve(self, curve: Curve) -> int: ...
    @overload
    def Append(self, other: Brep) -> None: ...
    @overload
    def CapPlanarHoles(self, tolerance: float) -> Brep: ...
    @overload
    @staticmethod
    def ChangeSeam(face: BrepFace, direction: int, parameter: float, tolerance: float) -> Brep: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> (bool, Point3d, ComponentIndex, float, float, Vector3d): ...
    @overload
    def Compact() -> None: ...
    @overload
    @staticmethod
    def CopyTrimCurves(trimSource: BrepFace, surfaceSource: Surface, tolerance: float) -> Brep: ...
    @overload
    @staticmethod
    def CreateBaseballSphere(center: Point3d, radius: float, tolerance: float) -> Brep: ...
    @overload
    @staticmethod
    def CreateBlendShape(face0: BrepFace, edge0: BrepEdge, t0: float, rev0: bool, continuity0: BlendContinuity, face1: BrepFace, edge1: BrepEdge, t1: float, rev1: bool, continuity1: BlendContinuity) -> Curve: ...
    @overload
    @staticmethod
    def CreateBlendSurface(face0: BrepFace, edge0: BrepEdge, domain0: Interval, rev0: bool, continuity0: BlendContinuity, face1: BrepFace, edge1: BrepEdge, domain1: Interval, rev1: bool, continuity1: BlendContinuity) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanDifference(firstBrep: Brep, secondBrep: Brep, tolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanDifference(firstSet: Generic.IEnumerable, secondSet: Generic.IEnumerable, tolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanDifference(firstBrep: Brep, secondBrep: Brep, tolerance: float, manifoldOnly: bool) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanDifference(firstSet: Generic.IEnumerable, secondSet: Generic.IEnumerable, tolerance: float, manifoldOnly: bool) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanDifferenceWithIndexMap(firstSet: Generic.IEnumerable, secondSet: Generic.IEnumerable, tolerance: float, manifoldOnly: bool) -> (System.Array[Brep], System.System.Array[int]): ...
    @overload
    @staticmethod
    def CreateBooleanIntersection(firstBrep: Brep, secondBrep: Brep, tolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanIntersection(firstSet: Generic.IEnumerable, secondSet: Generic.IEnumerable, tolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanIntersection(firstSet: Generic.IEnumerable, secondSet: Generic.IEnumerable, tolerance: float, manifoldOnly: bool) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanIntersection(firstBrep: Brep, secondBrep: Brep, tolerance: float, manifoldOnly: bool) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanSplit(firstSet: Generic.IEnumerable, secondSet: Generic.IEnumerable, tolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanSplit(firstBrep: Brep, secondBrep: Brep, tolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanUnion(breps: Generic.IEnumerable, tolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanUnion(breps: Generic.IEnumerable, tolerance: float, manifoldOnly: bool) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateBooleanUnion(breps: Generic.IEnumerable, tolerance: float, manifoldOnly: bool) -> (System.Array[Brep], System.Array[Point3d], System.Array[Point3d], System.Array[Point3d]): ...
    @overload
    @staticmethod
    def CreateChamferSurface(face0: BrepFace, uv0: Point2d, radius0: float, face1: BrepFace, uv1: Point2d, radius1: float, extend: bool, tolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateChamferSurface(face0: BrepFace, uv0: Point2d, radius0: float, face1: BrepFace, uv1: Point2d, radius1: float, trim: bool, extend: bool, tolerance: float) -> (System.Array[Brep], System.Array[Brep], System.Array[Brep]): ...
    @overload
    @staticmethod
    def CreateContourCurves(brepToContour: Brep, sectionPlane: Plane) -> System.Array[Curve]: ...
    @overload
    @staticmethod
    def CreateContourCurves(brepToContour: Brep, contourStart: Point3d, contourEnd: Point3d, interval: float) -> System.Array[Curve]: ...
    @overload
    @staticmethod
    def CreateCurvatureAnalysisMesh(brep: Brep, state: ApplicationSettings.CurvatureAnalysisSettingsState) -> System.Array[Mesh]: ...
    @overload
    @staticmethod
    def CreateDevelopableLoft(rail0: NurbsCurve, rail1: NurbsCurve, fixedRulings: Generic.IEnumerable) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateDevelopableLoft(crv0: Curve, crv1: Curve, reverse0: bool, reverse1: bool, density: int) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateEdgeSurface(curves: Generic.IEnumerable) -> Brep: ...
    @overload
    @staticmethod
    def CreateFilletEdges(brep: Brep, edgeIndices: Generic.IEnumerable, startRadii: Generic.IEnumerable, endRadii: Generic.IEnumerable, blendType: BlendType, railType: RailType, tolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateFilletEdges(brep: Brep, edgeIndices: Generic.IEnumerable, startRadii: Generic.IEnumerable, endRadii: Generic.IEnumerable, blendType: BlendType, railType: RailType, setbackFillets: bool, tolerance: float, angleTolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateFilletEdgesVariableRadius(brep: Brep, edgeIndices: Generic.IEnumerable, edgeDistances: Generic.IDictionary, blendType: BlendType, railType: RailType, setbackFillets: bool, tolerance: float, angleTolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateFilletSurface(face0: BrepFace, uv0: Point2d, face1: BrepFace, uv1: Point2d, radius: float, extend: bool, tolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateFilletSurface(face0: BrepFace, uv0: Point2d, face1: BrepFace, uv1: Point2d, radius: float, trim: bool, extend: bool, tolerance: float) -> (System.Array[Brep], System.Array[Brep], System.Array[Brep]): ...
    @overload
    @staticmethod
    def CreateFromBox(box: BoundingBox) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromBox(box: Box) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromBox(corners: Generic.IEnumerable) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromCone(cone: Cone, capBottom: bool) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromCornerPoints(corner1: Point3d, corner2: Point3d, corner3: Point3d, tolerance: float) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromCornerPoints(corner1: Point3d, corner2: Point3d, corner3: Point3d, corner4: Point3d, tolerance: float) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromCylinder(cylinder: Cylinder, capBottom: bool, capTop: bool) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromJoinedEdges(brep0: Brep, edgeIndex0: int, brep1: Brep, edgeIndex1: int, joinTolerance: float) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromLoft(curves: Generic.IEnumerable, start: Point3d, end: Point3d, loftType: LoftType, closed: bool) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateFromLoft(curves: Generic.IEnumerable, start: Point3d, end: Point3d, StartTangent: bool, EndTangent: bool, StartTrim: BrepTrim, EndTrim: BrepTrim, loftType: LoftType, closed: bool) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateFromLoftRebuild(curves: Generic.IEnumerable, start: Point3d, end: Point3d, loftType: LoftType, closed: bool, rebuildPointCount: int) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateFromLoftRefit(curves: Generic.IEnumerable, start: Point3d, end: Point3d, loftType: LoftType, closed: bool, refitTolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateFromMesh(mesh: Mesh, trimmedTriangles: bool) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromOffsetFace(face: BrepFace, offsetDistance: float, offsetTolerance: float, bothSides: bool, createSolid: bool) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromRevSurface(surface: RevSurface, capStart: bool, capEnd: bool) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromSphere(sphere: Sphere) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromSurface(surface: Surface) -> Brep: ...
    @overload
    @staticmethod
    def CreateFromSweep(rail: Curve, shapes: Generic.IEnumerable, closed: bool, tolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateFromSweep(rail: Curve, shape: Curve, closed: bool, tolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateFromSweep(rail1: Curve, rail2: Curve, shapes: Generic.IEnumerable, closed: bool, tolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateFromSweep(rail1: Curve, rail2: Curve, shape: Curve, closed: bool, tolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateFromSweep(rail1: Curve, rail2: Curve, shapes: Generic.IEnumerable, start: Point3d, end: Point3d, closed: bool, tolerance: float, rebuild: SweepRebuild, rebuildPointCount: int, refitTolerance: float, preserveHeight: bool) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateFromSweep(rail1: Curve, rail2: Curve, shapes: Generic.IEnumerable, start: Point3d, end: Point3d, closed: bool, tolerance: float, rebuild: SweepRebuild, rebuildPointCount: int, refitTolerance: float, preserveHeight: bool, autoAdjust: bool) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateFromSweep(rail: Curve, shapes: Generic.IEnumerable, startPoint: Point3d, endPoint: Point3d, frameType: SweepFrame, roadlikeNormal: Vector3d, closed: bool, blendType: SweepBlend, miterType: SweepMiter, tolerance: float, rebuildType: SweepRebuild, rebuildPointCount: int, refitTolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateFromSweepInParts(rail1: Curve, rail2: Curve, shapes: Generic.IEnumerable, rail_params: Generic.IEnumerable, closed: bool, tolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateFromSweepSegmented(rail: Curve, shape: Curve, closed: bool, tolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateFromSweepSegmented(rail: Curve, shapes: Generic.IEnumerable, closed: bool, tolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateFromSweepSegmented(rail: Curve, shapes: Generic.IEnumerable, startPoint: Point3d, endPoint: Point3d, frameType: SweepFrame, roadlikeNormal: Vector3d, closed: bool, blendType: SweepBlend, miterType: SweepMiter, tolerance: float, rebuildType: SweepRebuild, rebuildPointCount: int, refitTolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateFromTaperedExtrude(curveToExtrude: Curve, distance: float, direction: Vector3d, basePoint: Point3d, draftAngleRadians: float, cornerType: ExtrudeCornerType, tolerance: float, angleToleranceRadians: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateFromTaperedExtrudeWithRef(curve: Curve, direction: Vector3d, distance: float, draftAngle: float, plane: Plane, tolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateFromTorus(torus: Torus) -> Brep: ...
    @overload
    @staticmethod
    def CreateOffsetBrep(brep: Brep, distance: float, solid: bool, extend: bool, tolerance: float) -> (System.Array[Brep], System.Array[Brep], System.Array[Brep]): ...
    @overload
    @staticmethod
    def CreateOffsetBrep(brep: Brep, distance: float, solid: bool, extend: bool, shrink: bool, tolerance: float) -> (System.Array[Brep], System.Array[Brep], System.Array[Brep]): ...
    @overload
    @staticmethod
    def CreatePatch(geometry: Generic.IEnumerable, startingSurface: Surface, tolerance: float) -> Brep: ...
    @overload
    @staticmethod
    def CreatePatch(geometry: Generic.IEnumerable, uSpans: int, vSpans: int, tolerance: float) -> Brep: ...
    @overload
    @staticmethod
    def CreatePatch(geometry: Generic.IEnumerable, startingSurface: Surface, uSpans: int, vSpans: int, trim: bool, tangency: bool, pointSpacing: float, flexibility: float, surfacePull: float, fixEdges: System.System.Array[bool], tolerance: float) -> Brep: ...
    @overload
    @staticmethod
    def CreatePipe(rail: Curve, radius: float, localBlending: bool, cap: PipeCapMode, fitRail: bool, absoluteTolerance: float, angleToleranceRadians: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreatePipe(rail: Curve, railRadiiParameters: Generic.IEnumerable, radii: Generic.IEnumerable, localBlending: bool, cap: PipeCapMode, fitRail: bool, absoluteTolerance: float, angleToleranceRadians: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreatePlanarBreps(inputLoops: Generic.IEnumerable, tolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreatePlanarBreps(inputLoop: Curve, tolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreatePlanarBreps(inputLoops: Collections.CurveList, tolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreatePlanarDifference(b0: Brep, b1: Brep, plane: Plane, tolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreatePlanarIntersection(b0: Brep, b1: Brep, plane: Plane, tolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreatePlanarUnion(breps: Generic.IEnumerable, plane: Plane, tolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreatePlanarUnion(b0: Brep, b1: Brep, plane: Plane, tolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateQuadSphere(sphere: Sphere) -> Brep: ...
    @overload
    @staticmethod
    def CreateShell(brep: Brep, facesToRemove: Generic.IEnumerable, distance: float, tolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateSolid(breps: Generic.IEnumerable, tolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateThickPipe(rail: Curve, radius0: float, radius1: float, localBlending: bool, cap: PipeCapMode, fitRail: bool, absoluteTolerance: float, angleToleranceRadians: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateThickPipe(rail: Curve, railRadiiParameters: Generic.IEnumerable, radii0: Generic.IEnumerable, radii1: Generic.IEnumerable, localBlending: bool, cap: PipeCapMode, fitRail: bool, absoluteTolerance: float, angleToleranceRadians: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CreateTrimmedPlane(plane: Plane, curve: Curve) -> Brep: ...
    @overload
    @staticmethod
    def CreateTrimmedPlane(plane: Plane, curves: Generic.IEnumerable) -> Brep: ...
    @overload
    @staticmethod
    def CreateTrimmedSurface(trimSource: BrepFace, surfaceSource: Surface, tolerance: float) -> Brep: ...
    @overload
    def CullUnused2dCurves() -> bool: ...
    @overload
    def CullUnused3dCurves() -> bool: ...
    @overload
    def CullUnusedEdges() -> bool: ...
    @overload
    def CullUnusedFaces() -> bool: ...
    @overload
    def CullUnusedLoops() -> bool: ...
    @overload
    def CullUnusedSurfaces() -> bool: ...
    @overload
    def CullUnusedTrims() -> bool: ...
    @overload
    def CullUnusedVertices() -> bool: ...
    @overload
    @staticmethod
    def CutUpSurface(surface: Surface, curves: Generic.IEnumerable, useEdgeCurves: bool, tolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def CutUpSurface(surface: Surface, curves: Generic.IEnumerable, flip: bool, fitTolerance: float, keepTolerance: float) -> System.Array[Brep]: ...
    @overload
    def DestroyRegionTopology() -> None: ...
    @overload
    def Duplicate() -> GeometryBase: ...
    @overload
    def DuplicateBrep() -> Brep: ...
    @overload
    def DuplicateEdgeCurves() -> System.Array[Curve]: ...
    @overload
    def DuplicateEdgeCurves(self, nakedOnly: bool) -> System.Array[Curve]: ...
    @overload
    def DuplicateNakedEdgeCurves(self, nakedOuter: bool, nakedInner: bool) -> System.Array[Curve]: ...
    @overload
    def DuplicateSubBrep(self, faceIndices: Generic.IEnumerable) -> Brep: ...
    @overload
    def DuplicateVertices() -> System.Array[Point3d]: ...
    @overload
    @staticmethod
    def ExtendBrepFacesToConnect(Face0: BrepFace, f0_sel_pt: Point3d, Face1: BrepFace, f1_sel_pt: Point3d, tol: float, angleTol: float) -> (bool, Brep, Brep): ...
    @overload
    @staticmethod
    def ExtendBrepFacesToConnect(Face0: BrepFace, edgeIndex0: int, Face1: BrepFace, edgeIndex1: int, tol: float, angleTol: float) -> (bool, Brep, Brep): ...
    @overload
    def FindCoincidentBrepComponents(self, point: Point3d, tolerance: float) -> (System.System.Array[int], System.System.Array[int], System.System.Array[int]): ...
    @overload
    def Flip() -> None: ...
    @property
    def Curves2D(self) -> Collections.BrepCurveList: ...
    @property
    def Curves3D(self) -> Collections.BrepCurveList: ...
    @property
    def Edges(self) -> Collections.BrepEdgeList: ...
    @property
    def Faces(self) -> Collections.BrepFaceList: ...
    @property
    def HasRegionTopology(self) -> bool: ...
    @property
    def IsManifold(self) -> bool: ...
    @property
    def IsSolid(self) -> bool: ...
    @property
    def IsSurface(self) -> bool: ...
    @property
    def Loops(self) -> Collections.BrepLoopList: ...
    @property
    def SolidOrientation(self) -> BrepSolidOrientation: ...
    @property
    def Surfaces(self) -> Collections.BrepSurfaceList: ...
    @property
    def Trims(self) -> Collections.BrepTrimList: ...
    @property
    def Vertices(self) -> Collections.BrepVertexList: ...
    @overload
    def GetArea() -> float: ...
    @overload
    def GetArea(self, relativeTolerance: float, absoluteTolerance: float) -> float: ...
    @overload
    def GetConnectedComponents() -> System.Array[Brep]: ...
    @overload
    def GetPointInside(self, tolerance: float) -> (bool, Point3d): ...
    @overload
    def GetRegions() -> System.Array[BrepRegion]: ...
    @overload
    def GetTangentConnectedComponents(self, angleTolerance: float, includeMeshes: bool) -> System.Array[Brep]: ...
    @overload
    def GetVolume() -> float: ...
    @overload
    def GetVolume(self, relativeTolerance: float, absoluteTolerance: float) -> float: ...
    @overload
    def GetWireframe(self, density: int) -> System.Array[Curve]: ...
    @overload
    def InsetFaces(self, faceIndices: Generic.IEnumerable, distance: float, loose: bool, ignoreSeams: bool, creaseCorners: bool, tolerance: float, angleTolerance: float) -> Brep: ...
    @overload
    def IsBox() -> bool: ...
    @overload
    def IsBox(self, tolerance: float) -> bool: ...
    @overload
    def IsDuplicate(self, other: Brep, tolerance: float) -> bool: ...
    @overload
    def IsPointInside(self, point: Point3d, tolerance: float, strictlyIn: bool) -> bool: ...
    @overload
    def IsValidGeometry() -> (bool, str): ...
    @overload
    def IsValidTolerancesAndFlags() -> (bool, str): ...
    @overload
    def IsValidTopology() -> (bool, str): ...
    @overload
    def Join(self, otherBrep: Brep, tolerance: float, compact: bool) -> bool: ...
    @overload
    @staticmethod
    def JoinBreps(brepsToJoin: Generic.IEnumerable, tolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def JoinBreps(brepsToJoin: Generic.IEnumerable, tolerance: float, angleTolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def JoinBreps(brepsToJoin: Generic.IEnumerable, tolerance: float, angleTolerance: float) -> (System.Array[Brep], Generic.List): ...
    @overload
    def JoinEdges(self, edgeIndex0: int, edgeIndex1: int, joinTolerance: float, compact: bool) -> bool: ...
    @overload
    def JoinNakedEdges(self, tolerance: float) -> int: ...
    @overload
    def MakeValidForV2() -> bool: ...
    @overload
    @staticmethod
    def MergeBreps(brepsToMerge: Generic.IEnumerable, tolerance: float) -> Brep: ...
    @overload
    def MergeCoplanarFaces(self, tolerance: float) -> bool: ...
    @overload
    def MergeCoplanarFaces(self, tolerance: float, angleTolerance: float) -> bool: ...
    @overload
    def MergeCoplanarFaces(self, faceIndex: int, tolerance: float, angleTolerance: float) -> bool: ...
    @overload
    def MergeCoplanarFaces(self, faceIndex0: int, faceIndex1: int, tolerance: float, angleTolerance: float) -> bool: ...
    @overload
    @staticmethod
    def MergeSurfaces(surface0: Surface, surface1: Surface, tolerance: float, angleToleranceRadians: float) -> Brep: ...
    @overload
    @staticmethod
    def MergeSurfaces(brep0: Brep, brep1: Brep, tolerance: float, angleToleranceRadians: float) -> Brep: ...
    @overload
    @staticmethod
    def MergeSurfaces(brep0: Brep, brep1: Brep, tolerance: float, angleToleranceRadians: float, point0: Point2d, point1: Point2d, roundness: float, smooth: bool) -> Brep: ...
    @overload
    def PushPullExtend(self, faceIndex: int, transform: Transform, tolerance: float) -> Brep: ...
    @overload
    def RebuildTrimsForV2(self, face: BrepFace, nurbsSurface: NurbsSurface) -> None: ...
    @overload
    def RemoveFins() -> bool: ...
    @overload
    def RemoveHoles(self, tolerance: float) -> Brep: ...
    @overload
    def RemoveHoles(self, loops: Generic.IEnumerable, tolerance: float) -> Brep: ...
    @overload
    def Repair(self, tolerance: float) -> bool: ...
    @overload
    def SetTolerancesBoxesAndFlags() -> None: ...
    @overload
    def SetTolerancesBoxesAndFlags(self, bLazy: bool, bSetVertexTolerances: bool, bSetEdgeTolerances: bool, bSetTrimTolerances: bool, bSetTrimIsoFlags: bool, bSetTrimTypeFlags: bool, bSetLoopTypeFlags: bool, bSetTrimBoxes: bool) -> None: ...
    @overload
    def SetTrimIsoFlags() -> None: ...
    @overload
    def SetVertices() -> None: ...
    @overload
    def Split(self, cutter: Brep, intersectionTolerance: float) -> System.Array[Brep]: ...
    @overload
    def Split(self, cutters: Generic.IEnumerable, intersectionTolerance: float) -> System.Array[Brep]: ...
    @overload
    def Split(self, cutters: Generic.IEnumerable, intersectionTolerance: float) -> System.Array[Brep]: ...
    @overload
    def Split(self, cutter: Brep, intersectionTolerance: float) -> (System.Array[Brep], bool): ...
    @overload
    def Split(self, cutters: Generic.IEnumerable, normal: Vector3d, planView: bool, intersectionTolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def SplitDisjointPieces(brep: Brep) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def SplitDisjointPieces(brep: Brep) -> (System.Array[Brep], Generic.List): ...
    @overload
    def Standardize() -> None: ...
    @overload
    def TransformComponent(self, components: Generic.IEnumerable, xform: Transform, tolerance: float, timeLimit: float, useMultipleThreads: bool) -> bool: ...
    @overload
    def Trim(self, cutter: Brep, intersectionTolerance: float) -> System.Array[Brep]: ...
    @overload
    def Trim(self, cutter: Plane, intersectionTolerance: float) -> System.Array[Brep]: ...
    @overload
    @staticmethod
    def TryConvertBrep(geometry: GeometryBase) -> Brep: ...
    @overload
    def UnjoinEdges(self, edgesToUnjoin: Generic.IEnumerable) -> System.Array[Brep]: ...

class PointFaceRelation(enum.Enum):
    Exterior = 0
    Interior = 1
    Boundary = 2

class BrepSolidOrientation(enum.Enum):
    None_ = 0
    Outward = 1
    Unknown = 2
    Inward = -1

class EdgeAdjacency(enum.Enum):
    None_ = 0
    Naked = 1
    Interior = 2
    NonManifold = 3

class Concavity(enum.Enum):
    Tangent = 0
    Convex = 1
    Concave = 2
    None_ = -1

class BrepVertex(Point):
    """Brep vertex information

    """
    @overload
    def EdgeIndices() -> System.System.Array[int]: ...
    @property
    def Brep(self) -> Brep: ...
    @property
    def ProxyBrepSubDVertexId(self) -> System.UInt32: ...
    @property
    def Tolerance(self) -> float: ...
    @property
    def VertexIndex(self) -> int: ...

class BrepEdge(CurveProxy):
    """Represents a single edge curve in a Brep object.

    """
    @overload
    def AdjacentFaces() -> System.System.Array[int]: ...
    @overload
    def ConcavityAt(self, t: float, tolerance: float) -> Concavity: ...
    @property
    def Brep(self) -> Brep: ...
    @property
    def EdgeCurve(self) -> Curve: ...
    @property
    def EdgeCurveIndex(self) -> int: ...
    @property
    def EdgeIndex(self) -> int: ...
    @property
    def EndVertex(self) -> BrepVertex: ...
    @property
    def ProxyBrepSubDEdgeId(self) -> System.UInt32: ...
    @property
    def StartVertex(self) -> BrepVertex: ...
    @property
    def Tolerance(self) -> float: ...
    @property
    def TrimCount(self) -> int: ...
    @property
    def Valence(self) -> EdgeAdjacency: ...
    @overload
    def GetEdgeParameter(self, trimIndex: int, trimParameter: float) -> (bool, float): ...
    @overload
    def IsSmoothManifoldEdge(self, angleToleranceRadians: float) -> bool: ...
    @Tolerance.setter
    def Tolerance(self, value: System.Void): ...
    @overload
    def SetEdgeCurve(self, curve3dIndex: int) -> bool: ...
    @overload
    def SetEdgeCurve(self, curve3dIndex: int, subDomain: Interval) -> bool: ...
    @overload
    def TrimIndices() -> System.System.Array[int]: ...

class BrepTrimType(enum.Enum):
    Unknown = 0
    Boundary = 1
    Mated = 2
    Seam = 3
    Singular = 4
    CurveOnSurface = 5
    PointOnSurface = 6
    Slit = 7

class BrepTrim(CurveProxy):
    """Brep trim information is stored in BrepTrim classes. Brep.Trims is an array of all the trims in the brep. A BrepTrim is derived from CurveProxy so the trim can supply easy to use evaluation tools via the Curve virtual member functions. Note well that the domains and orientations of the curve m_C2[trim.m_c2i] and the trim as a curve may not agree.

    """
    @property
    def Brep(self) -> Brep: ...
    @property
    def Edge(self) -> BrepEdge: ...
    @property
    def EndVertex(self) -> BrepVertex: ...
    @property
    def Face(self) -> BrepFace: ...
    @property
    def IsoStatus(self) -> IsoStatus: ...
    @property
    def Loop(self) -> BrepLoop: ...
    @property
    def StartVertex(self) -> BrepVertex: ...
    @property
    def TrimCurve(self) -> Curve: ...
    @property
    def TrimCurveIndex(self) -> int: ...
    @property
    def TrimIndex(self) -> int: ...
    @property
    def TrimType(self) -> BrepTrimType: ...
    @overload
    def GetTolerances() -> (float, float): ...
    @overload
    def GetTrimParameter(self, edgeParameter: float) -> (bool, float): ...
    @overload
    def IsReversed() -> bool: ...
    @IsoStatus.setter
    def IsoStatus(self, value: System.Void): ...
    @TrimType.setter
    def TrimType(self, value: System.Void): ...
    @overload
    def SetTolerances(self, toleranceU: float, toleranceV: float) -> None: ...
    @overload
    def SetTrimCurve(self, curve2dIndex: int) -> bool: ...
    @overload
    def SetTrimCurve(self, curve2dIndex: int, subDomain: Interval) -> bool: ...

class BrepLoopType(enum.Enum):
    Unknown = 0
    Outer = 1
    Inner = 2
    Slit = 3
    CurveOnSurface = 4
    PointOnSurface = 5

class BrepLoop(GeometryBase):
    """Represent a single loop in a Brep object. A loop is composed of a list of trim curves.

    """
    @property
    def Brep(self) -> Brep: ...
    @property
    def Face(self) -> BrepFace: ...
    @property
    def LoopIndex(self) -> int: ...
    @property
    def LoopType(self) -> BrepLoopType: ...
    @property
    def Trims(self) -> Collections.BrepTrimList: ...
    @overload
    def To2dCurve() -> Curve: ...
    @overload
    def To3dCurve() -> Curve: ...

class BrepFace(SurfaceProxy):
    """Provides strongly-typed access to brep faces.
A Brep face is composed of one surface and trimming curves.

    """
    @overload
    def AdjacentEdges() -> System.System.Array[int]: ...
    @overload
    def AdjacentFaces() -> System.System.Array[int]: ...
    @overload
    def ChangeSurface(self, surfaceIndex: int) -> bool: ...
    @overload
    def ClearMaterialChannelIndex() -> None: ...
    @overload
    def ClearPackId() -> None: ...
    @overload
    def CreateExtrusion(self, pathCurve: Curve, cap: bool) -> Brep: ...
    @overload
    def DraftAnglePoint(self, testPoint: Point2d, testAngle: float, pullDirection: Vector3d, edge: bool) -> (bool, Point3d, float): ...
    @overload
    def DuplicateFace(self, duplicateMeshes: bool) -> Brep: ...
    @overload
    def DuplicateSurface() -> Surface: ...
    @overload
    def FilletSurfaceToCurve(self, curve: Curve, t: float, u: float, v: float, radius: float, alignToCurve: int, railDegree: int, arcDegree: int, arcSliders: Generic.IEnumerable, numBezierSrfs: int, tolerance: float, out_fillets: Generic.List) -> (bool, System.System.Array[float]): ...
    @overload
    def FilletSurfaceToRail(self, curveOnFace: Curve, secondFace: BrepFace, u1: float, v1: float, railDegree: int, arcDegree: int, arcSliders: Generic.IEnumerable, numBezierSrfs: int, extend: bool, split_type: FilletSurfaceSplitType, tolerance: float, out_fillets: Generic.List, out_breps0: Generic.List, out_breps1: Generic.List) -> (bool, System.System.Array[float]): ...
    @property
    def Brep(self) -> Brep: ...
    @property
    def FaceIndex(self) -> int: ...
    @property
    def Id(self) -> System.Guid: ...
    @property
    def IsSurface(self) -> bool: ...
    @property
    def Loops(self) -> Collections.BrepLoopList: ...
    @property
    def MaterialChannelIndex(self) -> int: ...
    @property
    def OrientationIsReversed(self) -> bool: ...
    @property
    def OuterLoop(self) -> BrepLoop: ...
    @property
    def PackId(self) -> System.UInt32: ...
    @property
    def PerFaceColor(self) -> Drawing.Color: ...
    @property
    def ProxyBrepSubDFaceId(self) -> System.UInt32: ...
    @property
    def SurfaceIndex(self) -> int: ...
    @overload
    def GetMesh(self, meshType: MeshType) -> Mesh: ...
    @overload
    def IsPointOnFace(self, u: float, v: float) -> PointFaceRelation: ...
    @overload
    def IsPointOnFace(self, u: float, v: float, tolerance: float) -> PointFaceRelation: ...
    @overload
    def PullPointsToFace(self, points: Generic.IEnumerable, tolerance: float) -> System.Array[Point3d]: ...
    @overload
    def RebuildEdges(self, tolerance: float, rebuildSharedEdges: bool, rebuildVertices: bool) -> bool: ...
    @overload
    def RefitTrim(self, edge: BrepEdge, knots: Generic.IEnumerable, tolerance: float, bSections: bool) -> (System.Array[Surface], float): ...
    @overload
    def RemoveHoles(self, tolerance: float) -> Brep: ...
    @Id.setter
    def Id(self, value: System.Void): ...
    @MaterialChannelIndex.setter
    def MaterialChannelIndex(self, value: System.Void): ...
    @OrientationIsReversed.setter
    def OrientationIsReversed(self, value: System.Void): ...
    @PerFaceColor.setter
    def PerFaceColor(self, value: System.Void): ...
    @overload
    def SetDomain(self, direction: int, domain: Interval) -> bool: ...
    @overload
    def SetMesh(self, meshType: MeshType, mesh: Mesh) -> bool: ...
    @overload
    def SetPackId(self, packId: System.UInt32) -> None: ...
    @overload
    def ShrinkFace(self, disableSide: ShrinkDisableSide) -> bool: ...
    @overload
    def ShrinkSurfaceToEdge() -> bool: ...
    @overload
    def Split(self, curves: Generic.IEnumerable, tolerance: float) -> Brep: ...
    @overload
    def TrimAwareIsoCurve(self, direction: int, constantParameter: float) -> System.Array[Curve]: ...
    @overload
    def TrimAwareIsoIntervals(self, direction: int, constantParameter: float) -> System.Array[Interval]: ...
    @overload
    def UnderlyingSurface() -> Surface: ...

class BrepRegion(Runtime.CommonObject):
    """Represents a brep topological region that has sides.

    """
    @overload
    def BoundaryBrep() -> Brep: ...
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @property
    def Brep(self) -> Brep: ...
    @property
    def Index(self) -> int: ...
    @property
    def IsFinite(self) -> bool: ...
    @overload
    def GetFaceSides() -> System.Array[BrepRegionFaceSide]: ...

class BrepRegionFaceSide(Runtime.CommonObject):
    """Represents a side of a
entity.

    """
    @property
    def Brep(self) -> Brep: ...
    @property
    def Face(self) -> BrepFace: ...
    @property
    def Region(self) -> BrepRegion: ...
    @property
    def SurfaceNormalPointsIntoRegion(self) -> bool: ...

class ComponentStatus(System.ValueType):
    """Provides information about selection, highlighting, visibility, editability and integrity states of a component.
This structure is immutable.

    """
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Equals(self, other: ComponentStatus) -> bool: ...
    @property
    def AllSet(self) -> ComponentStatus: ...
    @property
    def Clear(self) -> ComponentStatus: ...
    @property
    def Damaged(self) -> ComponentStatus: ...
    @property
    def Hidden(self) -> ComponentStatus: ...
    @property
    def Highlighted(self) -> ComponentStatus: ...
    @property
    def IsClear(self) -> bool: ...
    @property
    def IsDamaged(self) -> bool: ...
    @property
    def IsHidden(self) -> bool: ...
    @property
    def IsHighlighted(self) -> bool: ...
    @property
    def IsLocked(self) -> bool: ...
    @property
    def IsSelected(self) -> bool: ...
    @property
    def IsSelectedPersistent(self) -> bool: ...
    @property
    def Locked(self) -> ComponentStatus: ...
    @property
    def Selected(self) -> ComponentStatus: ...
    @property
    def SelectedPersistent(self) -> ComponentStatus: ...
    @overload
    def GetHashCode() -> int: ...
    @overload
    def HasAllEqualStates(self, statesFilter: ComponentStatus, comparand: ComponentStatus) -> bool: ...
    @overload
    def HasNoEqualStates(self, statesFilter: ComponentStatus, comparand: ComponentStatus) -> bool: ...
    @overload
    def HasSomeEqualStates(self, statesFilter: ComponentStatus, comparand: ComponentStatus) -> bool: ...
    @overload
    def ToString() -> str: ...
    @overload
    def WithStates(self, additionalStatus: ComponentStatus) -> ComponentStatus: ...

class CurveProxy(Curve):
    """Represent curve geometry. Usually this is part of another piece of geometry that can be represented as a "proxy".

    """
    @property
    def ProxyCurveIsReversed(self) -> bool: ...

class DetailView(GeometryBase):
    """Represents a view of the model placed on a page layout.

    """
    @property
    def IsParallelProjection(self) -> bool: ...
    @property
    def IsPerspectiveProjection(self) -> bool: ...
    @property
    def IsProjectionLocked(self) -> bool: ...
    @property
    def PageToModelRatio(self) -> float: ...
    @IsParallelProjection.setter
    def IsParallelProjection(self, value: System.Void): ...
    @IsPerspectiveProjection.setter
    def IsPerspectiveProjection(self, value: System.Void): ...
    @IsProjectionLocked.setter
    def IsProjectionLocked(self, value: System.Void): ...
    @overload
    def SetScale(self, modelLength: float, modelUnits: Rhino.UnitSystem, pageLength: float, pageUnits: Rhino.UnitSystem) -> bool: ...

class LinearDimension(Dimension):
    """Represents a linear dimension

    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, dimensionPlane: Plane, extensionLine1End: Point2d, extensionLine2End: Point2d, pointOnDimensionLine: Point2d): ...
    @overload
    @staticmethod
    def Create(dimtype: AnnotationType, dimStyle: DocObjects.DimensionStyle, plane: Plane, horizontal: Vector3d, defpoint1: Point3d, defpoint2: Point3d, dimlinepoint: Point3d, rotationInPlane: float) -> LinearDimension: ...
    @overload
    @staticmethod
    def FromPoints(extensionLine1End: Point3d, extensionLine2End: Point3d, pointOnDimensionLine: Point3d) -> LinearDimension: ...
    @property
    def Aligned(self) -> bool: ...
    @property
    def AnnotationType(self) -> AnnotationType: ...
    @property
    def Arrowhead1End(self) -> Point2d: ...
    @property
    def Arrowhead2End(self) -> Point2d: ...
    @property
    def DimensionLinePoint(self) -> Point2d: ...
    @property
    def DistanceBetweenArrowTips(self) -> float: ...
    @property
    def ExtensionLine1End(self) -> Point2d: ...
    @property
    def ExtensionLine2End(self) -> Point2d: ...
    @overload
    def Get3dPoints() -> (bool, Point3d, Point3d, Point3d, Point3d, Point3d, Point3d): ...
    @overload
    def GetDisplayLines(self, style: DocObjects.DimensionStyle, scale: float) -> (bool, Generic.IEnumerable): ...
    @overload
    def GetDistanceDisplayText(self, unitsystem: Rhino.UnitSystem, style: DocObjects.DimensionStyle) -> str: ...
    @overload
    def GetTextRectangle() -> (bool, System.Array[Point3d]): ...
    @Aligned.setter
    def Aligned(self, value: System.Void): ...
    @AnnotationType.setter
    def AnnotationType(self, value: System.Void): ...
    @DimensionLinePoint.setter
    def DimensionLinePoint(self, value: System.Void): ...
    @ExtensionLine1End.setter
    def ExtensionLine1End(self, value: System.Void): ...
    @ExtensionLine2End.setter
    def ExtensionLine2End(self, value: System.Void): ...
    @overload
    def SetLocations(self, extensionLine1End: Point2d, extensionLine2End: Point2d, pointOnDimensionLine: Point2d) -> None: ...

class AngularDimension(Dimension):
    """Represents a dimension of an entity that can be measured with an angle.

    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, arc: Arc, offset: float): ...
    @overload
    def __init__(self, plane: Plane, horizontal: Vector3d, centerpoint: Point3d, defpoint1: Point3d, defpoint2: Point3d, dimlinepoint: Point3d): ...
    @overload
    def __init__(self, line1: Line, pointOnLine1: Point3d, line2: Line, pointOnLine2: Point3d, pointOnAngularDimensionArc: Point3d, bSetExtensionPoints: bool): ...
    @overload
    def __init__(self, plane: Plane, horizontal: Vector3d, extpoint1: Point3d, extpoint2: Point3d, dirpoint1: Point3d, dirpoint2: Point3d, dimlinepoint: Point3d): ...
    @overload
    def AdjustFromPoints(self, plane: Plane, centerpoint: Point3d, defpoint1: Point3d, defpoint2: Point3d, dimlinepoint: Point3d) -> bool: ...
    @overload
    def AdjustFromPoints(self, plane: Plane, extpoint1: Point3d, extpoint2: Point3d, dirpoint1: Point3d, dirpoint2: Point3d, dimlinepoint: Point3d) -> bool: ...
    @overload
    @staticmethod
    def Create(dimStyle: DocObjects.DimensionStyle, plane: Plane, horizontal: Vector3d, centerpoint: Point3d, defpoint1: Point3d, defpoint2: Point3d, dimlinepoint: Point3d) -> AngularDimension: ...
    @overload
    @staticmethod
    def Create(dimStyle: DocObjects.DimensionStyle, line1: Line, pointOnLine1: Point3d, line2: Line, pointOnLine2: Point3d, pointOnAngularDimensionArc: Point3d, bSetExtensionPoints: bool) -> AngularDimension: ...
    @overload
    @staticmethod
    def Create(dimStyle: DocObjects.DimensionStyle, plane: Plane, horizontal: Vector3d, extpoint1: Point3d, extpoint2: Point3d, dirpoint1: Point3d, dirpoint2: Point3d, dimlinepoint: Point3d) -> AngularDimension: ...
    @property
    def AngleFormat(self) -> DocObjects.AngleDisplayFormat: ...
    @property
    def AngleResolution(self) -> int: ...
    @property
    def AngleRoundoff(self) -> float: ...
    @property
    def AngleZeroSuppression(self) -> DocObjects.ZeroSuppression: ...
    @property
    def ArrowPoint1(self) -> Point2d: ...
    @property
    def ArrowPoint2(self) -> Point2d: ...
    @property
    def CenterPoint(self) -> Point2d: ...
    @property
    def DefPoint1(self) -> Point2d: ...
    @property
    def DefPoint2(self) -> Point2d: ...
    @property
    def DimlinePoint(self) -> Point2d: ...
    @overload
    def Get3dPoints() -> (bool, Point3d, Point3d, Point3d, Point3d, Point3d, Point3d, Point3d): ...
    @overload
    def GetAngleDisplayText(self, style: DocObjects.DimensionStyle) -> str: ...
    @overload
    def GetDisplayLines(self, style: DocObjects.DimensionStyle, scale: float) -> (bool, System.Array[Line], System.Array[Arc]): ...
    @overload
    def GetTextRectangle() -> (bool, System.Array[Point3d]): ...
    @AngleFormat.setter
    def AngleFormat(self, value: System.Void): ...
    @AngleResolution.setter
    def AngleResolution(self, value: System.Void): ...
    @AngleRoundoff.setter
    def AngleRoundoff(self, value: System.Void): ...
    @AngleZeroSuppression.setter
    def AngleZeroSuppression(self, value: System.Void): ...
    @CenterPoint.setter
    def CenterPoint(self, value: System.Void): ...
    @DefPoint1.setter
    def DefPoint1(self, value: System.Void): ...
    @DefPoint2.setter
    def DefPoint2(self, value: System.Void): ...
    @DimlinePoint.setter
    def DimlinePoint(self, value: System.Void): ...

class RadialDimension(Dimension):
    """Represents a dimension of a circular entity that can be measured with radius or diameter.

    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, dimtype: AnnotationType, plane: Plane, centerpoint: Point3d, radiuspoint: Point3d, dimlinepoint: Point3d): ...
    @overload
    def AdjustFromPoints(self, plane: Plane, centerpoint: Point3d, radiuspoint: Point3d, dimlinepoint: Point3d, rotationInPlane: float) -> bool: ...
    @overload
    @staticmethod
    def Create(dimStyle: DocObjects.DimensionStyle, dimtype: AnnotationType, plane: Plane, centerpoint: Point3d, radiuspoint: Point3d, dimlinepoint: Point3d) -> RadialDimension: ...
    @property
    def AnnotationType(self) -> AnnotationType: ...
    @property
    def CenterPoint(self) -> Point2d: ...
    @property
    def DimlinePoint(self) -> Point2d: ...
    @property
    def IsDiameterDimension(self) -> bool: ...
    @property
    def KneePoint(self) -> Point2d: ...
    @property
    def LeaderArrowBlockId(self) -> System.Guid: ...
    @property
    def LeaderArrowSize(self) -> float: ...
    @property
    def LeaderArrowType(self) -> DocObjects.ArrowType: ...
    @property
    def LeaderCurveStyle(self) -> DocObjects.LeaderCurveStyle: ...
    @property
    def LeaderTextHorizontalAlignment(self) -> DocObjects.TextHorizontalAlignment: ...
    @property
    def RadiusPoint(self) -> Point2d: ...
    @property
    def TextAngleType(self) -> DocObjects.LeaderContentAngleStyle: ...
    @property
    def TextLocation(self) -> DocObjects.TextLocation: ...
    @property
    def TextOrientation(self) -> DocObjects.TextOrientation: ...
    @overload
    def Get3dPoints() -> (bool, Point3d, Point3d, Point3d, Point3d): ...
    @overload
    def GetDisplayLines(self, style: DocObjects.DimensionStyle, scale: float) -> (bool, Generic.IEnumerable): ...
    @overload
    def GetDistanceDisplayText(self, unitsystem: Rhino.UnitSystem, style: DocObjects.DimensionStyle) -> str: ...
    @overload
    def GetTextRectangle() -> (bool, System.Array[Point3d]): ...
    @AnnotationType.setter
    def AnnotationType(self, value: System.Void): ...
    @CenterPoint.setter
    def CenterPoint(self, value: System.Void): ...
    @DimlinePoint.setter
    def DimlinePoint(self, value: System.Void): ...
    @LeaderArrowBlockId.setter
    def LeaderArrowBlockId(self, value: System.Void): ...
    @LeaderArrowSize.setter
    def LeaderArrowSize(self, value: System.Void): ...
    @LeaderArrowType.setter
    def LeaderArrowType(self, value: System.Void): ...
    @LeaderCurveStyle.setter
    def LeaderCurveStyle(self, value: System.Void): ...
    @LeaderTextHorizontalAlignment.setter
    def LeaderTextHorizontalAlignment(self, value: System.Void): ...
    @RadiusPoint.setter
    def RadiusPoint(self, value: System.Void): ...
    @TextAngleType.setter
    def TextAngleType(self, value: System.Void): ...
    @TextLocation.setter
    def TextLocation(self, value: System.Void): ...
    @TextOrientation.setter
    def TextOrientation(self, value: System.Void): ...

class Centermark(Dimension):
    """Represents a center mark dimension.

    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, plane: Plane, centerPoint: Point3d, radius: float): ...
    @overload
    def __init__(self, plane: Plane, curve: Curve, curveParameter: float): ...
    @overload
    def AdjustFromPoints(self, plane: Plane, centerPoint: Point3d) -> bool: ...
    @overload
    @staticmethod
    def Create(dimStyle: DocObjects.DimensionStyle, plane: Plane, centerPoint: Point3d, radius: float) -> Centermark: ...
    @overload
    @staticmethod
    def Create(dimStyle: DocObjects.DimensionStyle, plane: Plane, curve: Curve, curveParameter: float) -> Centermark: ...
    @property
    def Radius(self) -> float: ...
    @Radius.setter
    def Radius(self, value: System.Void): ...

class Hatch(GeometryBase):
    """Represents a hatch in planar boundary loop or loops. This is a 2d entity with a plane defining a local coordinate system. The loops, patterns, angles, etc are all in this local coordinate system. The Hatch object manages the plane and loop array Fill definitions are in the HatchPattern or class derived from HatchPattern Hatch has an index to get the pattern definition from the pattern table.

    """
    @overload
    @staticmethod
    def Create(curves: Generic.IEnumerable, hatchPatternIndex: int, rotationRadians: float, scale: float, tolerance: float) -> System.Array[Hatch]: ...
    @overload
    @staticmethod
    def Create(curve: Curve, hatchPatternIndex: int, rotationRadians: float, scale: float, tolerance: float) -> System.Array[Hatch]: ...
    @overload
    @staticmethod
    def Create(hatchPlane: Plane, outerLoop: Curve, innerLoops: Generic.IEnumerable, hatchPatternIndex: int, rotationRadians: float, scale: float) -> Hatch: ...
    @overload
    def CreateDisplayGeometry(self, pattern: DocObjects.HatchPattern, patternScale: float) -> (System.Array[Curve], System.Array[Line], Brep): ...
    @overload
    @staticmethod
    def CreateFromBrep(brep: Brep, brepFaceIndex: int, hatchPatternIndex: int, rotationRadians: float, scale: float, basePoint: Point3d) -> Hatch: ...
    @overload
    def Explode() -> System.Array[GeometryBase]: ...
    @property
    def BasePoint(self) -> Point3d: ...
    @property
    def PatternIndex(self) -> int: ...
    @property
    def PatternRotation(self) -> float: ...
    @property
    def PatternScale(self) -> float: ...
    @property
    def Plane(self) -> Plane: ...
    @overload
    def Get2dCurves(self, outer: bool) -> System.Array[Curve]: ...
    @overload
    def Get3dCurves(self, outer: bool) -> System.Array[Curve]: ...
    @overload
    def GetGradientFill() -> Display.ColorGradient: ...
    @overload
    def ScalePattern(self, xform: Transform) -> None: ...
    @BasePoint.setter
    def BasePoint(self, value: System.Void): ...
    @PatternIndex.setter
    def PatternIndex(self, value: System.Void): ...
    @PatternRotation.setter
    def PatternRotation(self, value: System.Void): ...
    @PatternScale.setter
    def PatternScale(self, value: System.Void): ...
    @Plane.setter
    def Plane(self, value: System.Void): ...
    @overload
    def SetGradientFill(self, fill: Display.ColorGradient) -> None: ...
    @overload
    def ToBrep() -> Brep: ...

class HiddenLineDrawingParameters(object):
    """Input used for computing a hidden line drawing

    """
    def __init__(self): ...
    @overload
    def AddClippingPlane(self, plane: Plane) -> None: ...
    @overload
    def AddGeometry(self, geometry: GeometryBase, tag: object) -> bool: ...
    @overload
    def AddGeometry(self, geometry: GeometryBase, xform: Transform, tag: object) -> bool: ...
    @overload
    def AddGeometry(self, geometry: GeometryBase, tag: object, occluding_sections: bool) -> bool: ...
    @overload
    def AddGeometry(self, geometry: GeometryBase, xform: Transform, tag: object, occluding_sections: bool) -> bool: ...
    @overload
    def AddGeometryAndPlanes(self, geometry: GeometryBase, tag: object, clips: Generic.List) -> bool: ...
    @overload
    def AddGeometryAndPlanes(self, geometry: GeometryBase, xform: Transform, tag: object, clips: Generic.List) -> bool: ...
    @overload
    def AddGeometryAndPlanes(self, geometry: GeometryBase, tag: object, occluding_sections: bool, clips: Generic.List) -> bool: ...
    @overload
    def AddGeometryAndPlanes(self, geometry: GeometryBase, xform: Transform, tag: object, occluding_sections: bool, clips: Generic.List) -> bool: ...
    @property
    def AbsoluteTolerance(self) -> float: ...
    @property
    def Flatten(self) -> bool: ...
    @property
    def IncludeHiddenCurves(self) -> bool: ...
    @property
    def IncludeTangentEdges(self) -> bool: ...
    @property
    def IncludeTangentSeams(self) -> bool: ...
    @property
    def OccludingSectionOption(self) -> bool: ...
    @AbsoluteTolerance.setter
    def AbsoluteTolerance(self, value: System.Void): ...
    @Flatten.setter
    def Flatten(self, value: System.Void): ...
    @IncludeHiddenCurves.setter
    def IncludeHiddenCurves(self, value: System.Void): ...
    @IncludeTangentEdges.setter
    def IncludeTangentEdges(self, value: System.Void): ...
    @IncludeTangentSeams.setter
    def IncludeTangentSeams(self, value: System.Void): ...
    @OccludingSectionOption.setter
    def OccludingSectionOption(self, value: System.Void): ...
    @overload
    def SetViewport(self, viewport: Display.RhinoViewport) -> None: ...
    @overload
    def SetViewport(self, viewport: DocObjects.ViewportInfo) -> None: ...

class HiddenLineDrawing(object):
    """Represents a hidden line drawing object. A hidden line drawing consists of curves generated from source objects. The curves correspond to edges, and silhouettes of source objects and intersections with cutting planes.

    """
    @overload
    def BoundingBox(self, includeHidden: bool) -> BoundingBox: ...
    @overload
    @staticmethod
    def Compute(parameters: HiddenLineDrawingParameters, multipleThreads: bool) -> HiddenLineDrawing: ...
    @overload
    @staticmethod
    def Compute(parameters: HiddenLineDrawingParameters, multipleThreads: bool, progress: System.IProgress, cancelToken: Threading.CancellationToken) -> HiddenLineDrawing: ...
    @overload
    def Dispose() -> None: ...
    @property
    def Points(self) -> Generic.IEnumerable: ...
    @property
    def Segments(self) -> Generic.IEnumerable: ...
    @property
    def Viewport(self) -> DocObjects.ViewportInfo: ...
    @property
    def WorldToHiddenLine(self) -> Transform: ...
    @overload
    def RejoinCompatibleVisible() -> None: ...

class HiddenLineDrawingObject(object):
    """Represents an object added to a HiddenLineDrawing

    """
    @property
    def Geometry(self) -> GeometryBase: ...
    @property
    def OccludingSections(self) -> bool: ...
    @property
    def Tag(self) -> object: ...
    @property
    def Transform(self) -> Transform: ...
    @OccludingSections.setter
    def OccludingSections(self, value: System.Void): ...

class HiddenLineDrawingPoint(object):
    """Points generated from source objects which correspond to point and point cloud source objects.

    """
    @property
    def ClippingPlaneIndex(self) -> int: ...
    @property
    def Index(self) -> int: ...
    @property
    def Location(self) -> Point3d: ...
    @property
    def PointVisibility(self) -> Visibility: ...
    @property
    def SourceObject(self) -> HiddenLineDrawingObject: ...
    @property
    def SourceObjectComponentIndex(self) -> ComponentIndex: ...

class HiddenLineDrawingObjectCurve(object):
    """Curves generated from source objects which correspond to edges, and silhouettes of source objects and intersections with cutting planes. A HiddenLineDrawingObjectCurve is partitioned into hidden and visible segments called HiddenLineDrawingSegment

    """
    @overload
    def Curve(self, t: float) -> HiddenLineDrawingSegment: ...
    @overload
    def Curve(self, t: float, side: int) -> HiddenLineDrawingSegment: ...
    @property
    def ClippingPlaneIndex(self) -> int: ...
    @property
    def Index(self) -> int: ...
    @property
    def IsProjecting(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def OriginalDomainStart(self) -> float: ...
    @property
    def Parameters(self) -> System.System.Array[float]: ...
    @property
    def Segments(self) -> System.Array[HiddenLineDrawingSegment]: ...
    @property
    def SilhouetteType(self) -> SilhouetteType: ...
    @property
    def SourceObject(self) -> HiddenLineDrawingObject: ...
    @property
    def SourceObjectComponentIndex(self) -> ComponentIndex: ...

class HiddenLineDrawingSegment(object):
    """The results of HiddenLineDrawing calculation are a collection of segments. A segment is a sub-curve of a HiddenLineDrawingObjectCurve.

    """
    @property
    def CurveGeometry(self) -> Curve: ...
    @property
    def CurveSideFills(self) -> System.Array[SideFill]: ...
    @property
    def Index(self) -> int: ...
    @property
    def IsSceneSilhouette(self) -> bool: ...
    @property
    def ParentCurve(self) -> HiddenLineDrawingObjectCurve: ...
    @property
    def SegmentVisibility(self) -> Visibility: ...

class InstanceDefinitionGeometry(DocObjects.ModelComponent):
    """Represents a block definition in a File3dm. This is the same as Rhino.DocObjects.InstanceDefinition, but not associated with a RhinoDoc.

    """
    def __init__(self): ...
    @overload
    def DeleteAllUserStrings() -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @property
    def ComponentType(self) -> DocObjects.ModelComponentType: ...
    @property
    def Description(self) -> str: ...
    @property
    def SourceArchive(self) -> str: ...
    @property
    def Url(self) -> str: ...
    @property
    def UrlDescription(self) -> str: ...
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetObjectIds() -> System.System.Array[System.Guid]: ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings() -> Specialized.NameValueCollection: ...
    @Description.setter
    def Description(self, value: System.Void): ...
    @Url.setter
    def Url(self, value: System.Void): ...
    @UrlDescription.setter
    def UrlDescription(self, value: System.Void): ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...

class InstanceReferenceGeometry(GeometryBase):
    """Represents a reference to the geometry in a block definition.

    """
    def __init__(self, instanceDefinitionId: System.Guid, transform: Transform): ...
    @property
    def ParentIdefId(self) -> System.Guid: ...
    @property
    def Xform(self) -> Transform: ...

class Arrowhead(object):
    """Arrowhead used by annotation

    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, arrowType: DocObjects.ArrowType, blockId: System.Guid): ...
    @property
    def ArrowType(self) -> DocObjects.ArrowType: ...
    @property
    def BlockId(self) -> System.Guid: ...

class Leader(AnnotationBase):
    """Leader geometry class

    """
    def __init__(self): ...
    @overload
    @staticmethod
    def Create(text: str, plane: Plane, dimstyle: DocObjects.DimensionStyle, points: System.Array[Point3d]) -> Leader: ...
    @overload
    @staticmethod
    def CreateWithRichText(richText: str, plane: Plane, dimstyle: DocObjects.DimensionStyle, points: System.Array[Point3d]) -> Leader: ...
    @overload
    def Explode() -> System.Array[GeometryBase]: ...
    @property
    def Curve(self) -> NurbsCurve: ...
    @property
    def LeaderArrowBlockId(self) -> System.Guid: ...
    @property
    def LeaderArrowSize(self) -> float: ...
    @property
    def LeaderArrowType(self) -> DocObjects.ArrowType: ...
    @property
    def LeaderContentAngleStyle(self) -> DocObjects.LeaderContentAngleStyle: ...
    @property
    def LeaderCurveStyle(self) -> DocObjects.LeaderCurveStyle: ...
    @property
    def LeaderHasLanding(self) -> bool: ...
    @property
    def LeaderLandingLength(self) -> float: ...
    @property
    def LeaderTextHorizontalAlignment(self) -> DocObjects.TextHorizontalAlignment: ...
    @property
    def LeaderTextVerticalAlignment(self) -> DocObjects.TextVerticalAlignment: ...
    @property
    def Points2D(self) -> System.Array[Point2d]: ...
    @property
    def Points3D(self) -> System.Array[Point3d]: ...
    @LeaderArrowBlockId.setter
    def LeaderArrowBlockId(self, value: System.Void): ...
    @LeaderArrowSize.setter
    def LeaderArrowSize(self, value: System.Void): ...
    @LeaderArrowType.setter
    def LeaderArrowType(self, value: System.Void): ...
    @LeaderContentAngleStyle.setter
    def LeaderContentAngleStyle(self, value: System.Void): ...
    @LeaderCurveStyle.setter
    def LeaderCurveStyle(self, value: System.Void): ...
    @LeaderHasLanding.setter
    def LeaderHasLanding(self, value: System.Void): ...
    @LeaderLandingLength.setter
    def LeaderLandingLength(self, value: System.Void): ...
    @LeaderTextHorizontalAlignment.setter
    def LeaderTextHorizontalAlignment(self, value: System.Void): ...
    @LeaderTextVerticalAlignment.setter
    def LeaderTextVerticalAlignment(self, value: System.Void): ...
    @Points2D.setter
    def Points2D(self, value: System.Void): ...
    @Points3D.setter
    def Points3D(self, value: System.Void): ...

class Light(GeometryBase):
    """Represents a light that shines in the modeling space.

    """
    def __init__(self): ...
    @property
    def ConstantAttenuationVector(self) -> Vector3d: ...
    @property
    def LinearAttenuationVector(self) -> Vector3d: ...
    @property
    def InverseSquaredAttenuationVector(self) -> Vector3d: ...
    @overload
    @staticmethod
    def CreateSunLight(sun: Render.Sun) -> Light: ...
    @overload
    @staticmethod
    def CreateSunLight(northAngleDegrees: float, azimuthDegrees: float, altitudeDegrees: float) -> Light: ...
    @overload
    @staticmethod
    def CreateSunLight(northAngleDegrees: float, when: System.DateTime, latitudeDegrees: float, longitudeDegrees: float) -> Light: ...
    @property
    def Ambient(self) -> Drawing.Color: ...
    @property
    def AttenuationType(self) -> Attenuation: ...
    @property
    def AttenuationVector(self) -> Vector3d: ...
    @property
    def CoordinateSystem(self) -> DocObjects.CoordinateSystem: ...
    @property
    def Diffuse(self) -> Drawing.Color: ...
    @property
    def Direction(self) -> Vector3d: ...
    @property
    def HotSpot(self) -> float: ...
    @property
    def Id(self) -> System.Guid: ...
    @property
    def Intensity(self) -> float: ...
    @property
    def IsDirectionalLight(self) -> bool: ...
    @property
    def IsEnabled(self) -> bool: ...
    @property
    def IsLinearLight(self) -> bool: ...
    @property
    def IsPointLight(self) -> bool: ...
    @property
    def IsRectangularLight(self) -> bool: ...
    @property
    def IsSpotLight(self) -> bool: ...
    @property
    def IsSunLight(self) -> bool: ...
    @property
    def Length(self) -> Vector3d: ...
    @property
    def LightStyle(self) -> LightStyle: ...
    @property
    def Location(self) -> Point3d: ...
    @property
    def Name(self) -> str: ...
    @property
    def PerpendicularDirection(self) -> Vector3d: ...
    @property
    def PowerCandela(self) -> float: ...
    @property
    def PowerLumens(self) -> float: ...
    @property
    def PowerWatts(self) -> float: ...
    @property
    def ShadowIntensity(self) -> float: ...
    @property
    def Specular(self) -> Drawing.Color: ...
    @property
    def SpotAngleRadians(self) -> float: ...
    @property
    def SpotExponent(self) -> float: ...
    @property
    def SpotLightShadowIntensity(self) -> float: ...
    @property
    def Width(self) -> Vector3d: ...
    @overload
    def GetAttenuation(self, d: float) -> float: ...
    @overload
    def GetSpotLightRadii() -> (bool, float, float): ...
    @Ambient.setter
    def Ambient(self, value: System.Void): ...
    @AttenuationType.setter
    def AttenuationType(self, value: System.Void): ...
    @AttenuationVector.setter
    def AttenuationVector(self, value: System.Void): ...
    @Diffuse.setter
    def Diffuse(self, value: System.Void): ...
    @Direction.setter
    def Direction(self, value: System.Void): ...
    @HotSpot.setter
    def HotSpot(self, value: System.Void): ...
    @Id.setter
    def Id(self, value: System.Void): ...
    @Intensity.setter
    def Intensity(self, value: System.Void): ...
    @IsEnabled.setter
    def IsEnabled(self, value: System.Void): ...
    @Length.setter
    def Length(self, value: System.Void): ...
    @LightStyle.setter
    def LightStyle(self, value: System.Void): ...
    @Location.setter
    def Location(self, value: System.Void): ...
    @Name.setter
    def Name(self, value: System.Void): ...
    @PowerCandela.setter
    def PowerCandela(self, value: System.Void): ...
    @PowerLumens.setter
    def PowerLumens(self, value: System.Void): ...
    @PowerWatts.setter
    def PowerWatts(self, value: System.Void): ...
    @ShadowIntensity.setter
    def ShadowIntensity(self, value: System.Void): ...
    @Specular.setter
    def Specular(self, value: System.Void): ...
    @SpotAngleRadians.setter
    def SpotAngleRadians(self, value: System.Void): ...
    @SpotExponent.setter
    def SpotExponent(self, value: System.Void): ...
    @SpotLightShadowIntensity.setter
    def SpotLightShadowIntensity(self, value: System.Void): ...
    @Width.setter
    def Width(self, value: System.Void): ...
    @overload
    def SetAttenuation(self, a0: float, a1: float, a2: float) -> None: ...

class LineCurve(Curve):
    """Represents a linear curve.

    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: LineCurve): ...
    @overload
    def __init__(self, line: Line): ...
    @overload
    def __init__(self, from_: Point2d, to: Point2d): ...
    @overload
    def __init__(self, from_: Point3d, to: Point3d): ...
    @overload
    def __init__(self, line: Line, t0: float, t1: float): ...
    @property
    def Line(self) -> Line: ...
    @Line.setter
    def Line(self, value: System.Void): ...

class AreaMassProperties(object):
    """Contains static initialization methods and allows access to the computed metrics of area, area centroid and area moments in closed planar curves, in meshes, in surfaces, in hatches and in boundary representations.

    """
    @overload
    def CentroidCoordinatesPrincipalMoments() -> (bool, float, Vector3d, float, Vector3d, float, Vector3d): ...
    @overload
    def CentroidCoordinatesPrincipalMomentsOfInertia() -> (bool, float, Vector3d, float, Vector3d, float, Vector3d): ...
    @overload
    @staticmethod
    def Compute(closedPlanarCurve: Curve) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(hatch: Hatch) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(mesh: Mesh) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(brep: Brep) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(surface: Surface) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(geometry: Generic.IEnumerable) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(closedPlanarCurve: Curve, planarTolerance: float) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(mesh: Mesh, area: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(brep: Brep, area: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(surface: Surface, area: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(geometry: Generic.IEnumerable, area: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> AreaMassProperties: ...
    @overload
    @staticmethod
    def Compute(brep: Brep, area: bool, firstMoments: bool, secondMoments: bool, productMoments: bool, relativeTolerance: float, absoluteTolerance: float) -> AreaMassProperties: ...
    @overload
    def Dispose() -> None: ...
    @property
    def Area(self) -> float: ...
    @property
    def AreaError(self) -> float: ...
    @property
    def Centroid(self) -> Point3d: ...
    @property
    def CentroidCoordinatesMomentsOfInertia(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesMomentsOfInertiaError(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesProductMoments(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesProductMomentsError(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesRadiiOfGyration(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesSecondMoments(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesSecondMomentsError(self) -> Vector3d: ...
    @property
    def CentroidError(self) -> Vector3d: ...
    @property
    def WorldCoordinatesFirstMoments(self) -> Vector3d: ...
    @property
    def WorldCoordinatesFirstMomentsError(self) -> Vector3d: ...
    @property
    def WorldCoordinatesMomentsOfInertia(self) -> Vector3d: ...
    @property
    def WorldCoordinatesMomentsOfInertiaError(self) -> Vector3d: ...
    @property
    def WorldCoordinatesProductMoments(self) -> Vector3d: ...
    @property
    def WorldCoordinatesProductMomentsError(self) -> Vector3d: ...
    @property
    def WorldCoordinatesRadiiOfGyration(self) -> Vector3d: ...
    @property
    def WorldCoordinatesSecondMoments(self) -> Vector3d: ...
    @property
    def WorldCoordinatesSecondMomentsError(self) -> Vector3d: ...
    @overload
    def WorldCoordinatesPrincipalMoments() -> (bool, float, Vector3d, float, Vector3d, float, Vector3d): ...
    @overload
    def WorldCoordinatesPrincipalMomentsOfInertia() -> (bool, float, Vector3d, float, Vector3d, float, Vector3d): ...

class VolumeMassProperties(object):
    """Contains static initialization methods and allows access to the computed metrics of volume, volume centroid and volume moments in in solid meshes, in solid surfaces and in solid (closed) boundary representations.

    """
    @overload
    def CentroidCoordinatesPrincipalMoments() -> (bool, float, Vector3d, float, Vector3d, float, Vector3d): ...
    @overload
    def CentroidCoordinatesPrincipalMomentsOfInertia() -> (bool, float, Vector3d, float, Vector3d, float, Vector3d): ...
    @overload
    @staticmethod
    def Compute(mesh: Mesh) -> VolumeMassProperties: ...
    @overload
    @staticmethod
    def Compute(brep: Brep) -> VolumeMassProperties: ...
    @overload
    @staticmethod
    def Compute(surface: Surface) -> VolumeMassProperties: ...
    @overload
    @staticmethod
    def Compute(geometry: Generic.IEnumerable) -> VolumeMassProperties: ...
    @overload
    @staticmethod
    def Compute(mesh: Mesh, volume: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> VolumeMassProperties: ...
    @overload
    @staticmethod
    def Compute(brep: Brep, volume: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> VolumeMassProperties: ...
    @overload
    @staticmethod
    def Compute(surface: Surface, volume: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> VolumeMassProperties: ...
    @overload
    @staticmethod
    def Compute(geometry: Generic.IEnumerable, volume: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> VolumeMassProperties: ...
    @overload
    @staticmethod
    def Compute(brep: Brep, volume: bool, firstMoments: bool, secondMoments: bool, productMoments: bool, relativeTolerance: float, absoluteTolerance: float) -> VolumeMassProperties: ...
    @overload
    def Dispose() -> None: ...
    @property
    def Centroid(self) -> Point3d: ...
    @property
    def CentroidCoordinatesMomentsOfInertia(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesMomentsOfInertiaError(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesProductMoments(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesProductMomentsError(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesRadiiOfGyration(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesSecondMoments(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesSecondMomentsError(self) -> Vector3d: ...
    @property
    def CentroidError(self) -> Vector3d: ...
    @property
    def Volume(self) -> float: ...
    @property
    def VolumeError(self) -> float: ...
    @property
    def WorldCoordinatesFirstMoments(self) -> Vector3d: ...
    @property
    def WorldCoordinatesFirstMomentsError(self) -> Vector3d: ...
    @property
    def WorldCoordinatesMomentsOfInertia(self) -> Vector3d: ...
    @property
    def WorldCoordinatesMomentsOfInertiaError(self) -> Vector3d: ...
    @property
    def WorldCoordinatesProductMoments(self) -> Vector3d: ...
    @property
    def WorldCoordinatesProductMomentsError(self) -> Vector3d: ...
    @property
    def WorldCoordinatesRadiiOfGyration(self) -> Vector3d: ...
    @property
    def WorldCoordinatesSecondMoments(self) -> Vector3d: ...
    @property
    def WorldCoordinatesSecondMomentsError(self) -> Vector3d: ...
    @overload
    def Sum(self, summand: VolumeMassProperties) -> bool: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def WorldCoordinatesPrincipalMoments() -> (bool, float, Vector3d, float, Vector3d, float, Vector3d): ...
    @overload
    def WorldCoordinatesPrincipalMomentsOfInertia() -> (bool, float, Vector3d, float, Vector3d, float, Vector3d): ...

class LengthMassProperties(object):
    """Contains static initialization methods and allows access to the computed metrics of length, length centroid, and length moments in curves.

    """
    @overload
    def CentroidCoordinatesPrincipalMoments() -> (bool, float, Vector3d, float, Vector3d, float, Vector3d): ...
    @overload
    def CentroidCoordinatesPrincipalMomentsOfInertia() -> (bool, float, Vector3d, float, Vector3d, float, Vector3d): ...
    @overload
    @staticmethod
    def Compute(curve: Curve) -> LengthMassProperties: ...
    @overload
    @staticmethod
    def Compute(curves: Generic.IEnumerable) -> LengthMassProperties: ...
    @overload
    @staticmethod
    def Compute(curve: Curve, length: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> LengthMassProperties: ...
    @overload
    @staticmethod
    def Compute(curves: Generic.IEnumerable, length: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> LengthMassProperties: ...
    @overload
    def Dispose() -> None: ...
    @property
    def Centroid(self) -> Point3d: ...
    @property
    def CentroidCoordinatesMomentsOfInertia(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesMomentsOfInertiaError(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesProductMoments(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesProductMomentsError(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesRadiiOfGyration(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesSecondMoments(self) -> Vector3d: ...
    @property
    def CentroidCoordinatesSecondMomentsError(self) -> Vector3d: ...
    @property
    def CentroidError(self) -> Vector3d: ...
    @property
    def Length(self) -> float: ...
    @property
    def LengthError(self) -> float: ...
    @property
    def WorldCoordinatesFirstMoments(self) -> Vector3d: ...
    @property
    def WorldCoordinatesFirstMomentsError(self) -> Vector3d: ...
    @property
    def WorldCoordinatesMomentsOfInertia(self) -> Vector3d: ...
    @property
    def WorldCoordinatesMomentsOfInertiaError(self) -> Vector3d: ...
    @property
    def WorldCoordinatesProductMoments(self) -> Vector3d: ...
    @property
    def WorldCoordinatesProductMomentsError(self) -> Vector3d: ...
    @property
    def WorldCoordinatesRadiiOfGyration(self) -> Vector3d: ...
    @property
    def WorldCoordinatesSecondMoments(self) -> Vector3d: ...
    @property
    def WorldCoordinatesSecondMomentsError(self) -> Vector3d: ...
    @overload
    def WorldCoordinatesPrincipalMoments() -> (bool, float, Vector3d, float, Vector3d, float, Vector3d): ...
    @overload
    def WorldCoordinatesPrincipalMomentsOfInertia() -> (bool, float, Vector3d, float, Vector3d, float, Vector3d): ...

class Matrix(object):
    """Represents an arbitrarily sized matrix of
double
-precision floating point numbers. If you are working with a 4x4 matrix, then you may want to use the
class instead.

    """
    @overload
    def __init__(self, xform: Transform): ...
    @overload
    def __init__(self, rowCount: int, columnCount: int): ...
    @overload
    def BackSolve(self, zeroTolerance: float, b: System.System.Array[float]) -> System.System.Array[float]: ...
    @overload
    def BackSolvePoints(self, zeroTolerance: float, b: System.Array[Point3d]) -> System.Array[Point3d]: ...
    @overload
    def Dispose() -> None: ...
    @overload
    def Duplicate() -> Matrix: ...
    @property
    def ColumnCount(self) -> int: ...
    @property
    def IsColumnOrthogonal(self) -> bool: ...
    @property
    def IsColumnOrthoNormal(self) -> bool: ...
    @property
    def IsRowOrthogonal(self) -> bool: ...
    @property
    def IsRowOrthoNormal(self) -> bool: ...
    @property
    def IsSquare(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Item(self) -> float: ...
    @property
    def RowCount(self) -> int: ...
    @overload
    def GetHashCode() -> int: ...
    @overload
    def Invert(self, zeroTolerance: float) -> bool: ...
    @overload
    def RowReduce(self, zeroTolerance: float, b: System.Array[Point3d]) -> (int, float): ...
    @overload
    def RowReduce(self, zeroTolerance: float, b: System.System.Array[float]) -> (int, float): ...
    @overload
    def RowReduce(self, zeroTolerance: float) -> (int, float, float): ...
    @overload
    def Scale(self, s: float) -> None: ...
    @Item.setter
    def Item(self, value: System.Void): ...
    @overload
    def SetDiagonal(self, d: float) -> None: ...
    @overload
    def SwapColumns(self, columnA: int, columnB: int) -> bool: ...
    @overload
    def SwapRows(self, rowA: int, rowB: int) -> bool: ...
    @overload
    def Transpose() -> bool: ...
    @overload
    def Zero() -> None: ...

class MeshingParameterStyle(enum.Enum):
    None_ = 0
    Fast = 1
    Quality = 2
    Custom = 9
    PerObject = 10

class SmoothingCoordinateSystem(enum.Enum):
    World = 0
    CPlane = 1
    Object = 2

class MeshCheckParameters(System.ValueType):
    """Output of a mesh checking operations.

    """
    @overload
    @staticmethod
    def Defaults() -> MeshCheckParameters: ...
    @property
    def CheckForBadNormals(self) -> bool: ...
    @property
    def CheckForDegenerateFaces(self) -> bool: ...
    @property
    def CheckForDisjointMeshes(self) -> bool: ...
    @property
    def CheckForDuplicateFaces(self) -> bool: ...
    @property
    def CheckForExtremelyShortEdges(self) -> bool: ...
    @property
    def CheckForInvalidNgons(self) -> bool: ...
    @property
    def CheckForNakedEdges(self) -> bool: ...
    @property
    def CheckForNonManifoldEdges(self) -> bool: ...
    @property
    def CheckForRandomFaceNormals(self) -> bool: ...
    @property
    def CheckForSelfIntersection(self) -> bool: ...
    @property
    def CheckForUnusedVertices(self) -> bool: ...
    @property
    def DegenerateFaceCount(self) -> int: ...
    @property
    def DisjointMeshCount(self) -> int: ...
    @property
    def DuplicateFaceCount(self) -> int: ...
    @property
    def ExtremelyShortEdgeCount(self) -> int: ...
    @property
    def InvalidNgonCount(self) -> int: ...
    @property
    def NakedEdgeCount(self) -> int: ...
    @property
    def NonManifoldEdgeCount(self) -> int: ...
    @property
    def NonUnitVectorNormalCount(self) -> int: ...
    @property
    def RandomFaceNormalCount(self) -> int: ...
    @property
    def SelfIntersectingPairsCount(self) -> int: ...
    @property
    def UnusedVertexCount(self) -> int: ...
    @property
    def VertexFaceNormalsDifferCount(self) -> int: ...
    @property
    def ZeroLengthNormalCount(self) -> int: ...
    @CheckForBadNormals.setter
    def CheckForBadNormals(self, value: System.Void): ...
    @CheckForDegenerateFaces.setter
    def CheckForDegenerateFaces(self, value: System.Void): ...
    @CheckForDisjointMeshes.setter
    def CheckForDisjointMeshes(self, value: System.Void): ...
    @CheckForDuplicateFaces.setter
    def CheckForDuplicateFaces(self, value: System.Void): ...
    @CheckForExtremelyShortEdges.setter
    def CheckForExtremelyShortEdges(self, value: System.Void): ...
    @CheckForInvalidNgons.setter
    def CheckForInvalidNgons(self, value: System.Void): ...
    @CheckForNakedEdges.setter
    def CheckForNakedEdges(self, value: System.Void): ...
    @CheckForNonManifoldEdges.setter
    def CheckForNonManifoldEdges(self, value: System.Void): ...
    @CheckForRandomFaceNormals.setter
    def CheckForRandomFaceNormals(self, value: System.Void): ...
    @CheckForSelfIntersection.setter
    def CheckForSelfIntersection(self, value: System.Void): ...
    @CheckForUnusedVertices.setter
    def CheckForUnusedVertices(self, value: System.Void): ...

class MeshingParameterTextureRange(enum.Enum):
    Unset = 0
    UnpackedUnscaledNormalized = 1
    PackedScaledNormalized = 2

class SubDDisplayParameters(object):
    """A collection of parameters that are passed to functions that calculate a various representations of SubD objects.

    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, info: Serialization.SerializationInfo, context: Serialization.StreamingContext): ...
    @overload
    @staticmethod
    def AbsoluteDisplayDensityFromSubD(adaptiveSubDDisplayDensity: System.UInt32, subd: SubD) -> System.UInt32: ...
    @overload
    @staticmethod
    def AbsoluteDisplayDensityFromSubDFaceCount(adaptiveSubDDisplayDensity: System.UInt32, subDFaceCount: System.UInt32) -> System.UInt32: ...
    @overload
    @staticmethod
    def ClampDisplayDensity(displayDensity: System.UInt32) -> System.UInt32: ...
    @overload
    @staticmethod
    def Coarse() -> SubDDisplayParameters: ...
    @overload
    @staticmethod
    def CreateFromAbsoluteDisplayDensity(absoluteSubDDisplayDensity: System.UInt32) -> SubDDisplayParameters: ...
    @overload
    @staticmethod
    def CreateFromDisplayDensity(adaptiveSubDDisplayDensity: System.UInt32) -> SubDDisplayParameters: ...
    @overload
    @staticmethod
    def CreateFromMeshDensity(normalizedMeshDensity: float) -> SubDDisplayParameters: ...
    @overload
    @staticmethod
    def Default() -> SubDDisplayParameters: ...
    @overload
    def DisplayDensity(self, subd: SubD) -> System.UInt32: ...
    @overload
    def Dispose() -> None: ...
    @overload
    @staticmethod
    def Empty() -> SubDDisplayParameters: ...
    @overload
    @staticmethod
    def ExtraCoarse() -> SubDDisplayParameters: ...
    @overload
    @staticmethod
    def ExtraFine() -> SubDDisplayParameters: ...
    @overload
    @staticmethod
    def Fine() -> SubDDisplayParameters: ...
    @overload
    @staticmethod
    def FromEncodedString(value: str) -> SubDDisplayParameters: ...
    @property
    def AdaptiveDisplayMeshQuadMaximum(self) -> System.UInt32: ...
    @property
    def DisplayDensityIsAbsolute(self) -> bool: ...
    @property
    def DisplayDensityIsAdaptive(self) -> bool: ...
    @property
    def MeshLocation(self) -> SubDComponentLocation: ...
    @overload
    def GetObjectData(self, info: Serialization.SerializationInfo, context: Serialization.StreamingContext) -> None: ...
    @overload
    @staticmethod
    def Medium() -> SubDDisplayParameters: ...
    @MeshLocation.setter
    def MeshLocation(self, value: System.Void): ...
    @overload
    def SetAbsoluteDisplayDensity(self, absoluteDisplayDensity: System.UInt32) -> None: ...
    @overload
    def SetAdaptiveDisplayDensity(self, adaptiveDisplayDensity: System.UInt32) -> None: ...
    @overload
    def ToEncodedString() -> str: ...

class MeshingParameters(object):
    """Represents settings used for creating a mesh representation of a brep or surface.

    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, source: MeshingParameters): ...
    @overload
    def __init__(self, density: float): ...
    @overload
    def __init__(self, density: float, minimumEdgeLength: float): ...
    @overload
    def __init__(self, info: Serialization.SerializationInfo, context: Serialization.StreamingContext): ...
    @overload
    def CopyFrom(self, source: MeshingParameters) -> None: ...
    @overload
    def Dispose() -> None: ...
    @overload
    @staticmethod
    def DocumentCurrentSetting(doc: Rhino.RhinoDoc) -> MeshingParameters: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Equals(self, other: MeshingParameters) -> bool: ...
    @overload
    @staticmethod
    def FromEncodedString(value: str) -> MeshingParameters: ...
    @property
    def ClosedObjectPostProcess(self) -> bool: ...
    @property
    def Coarse(self) -> MeshingParameters: ...
    @property
    def ComputeCurvature(self) -> bool: ...
    @property
    def Default(self) -> MeshingParameters: ...
    @property
    def DefaultAnalysisMesh(self) -> MeshingParameters: ...
    @property
    def DoublePrecision(self) -> bool: ...
    @property
    def FastRenderMesh(self) -> MeshingParameters: ...
    @property
    def GridAmplification(self) -> float: ...
    @property
    def GridAngle(self) -> float: ...
    @property
    def GridAspectRatio(self) -> float: ...
    @property
    def GridMaxCount(self) -> int: ...
    @property
    def GridMinCount(self) -> int: ...
    @property
    def JaggedSeams(self) -> bool: ...
    @property
    def MaximumEdgeLength(self) -> float: ...
    @property
    def Minimal(self) -> MeshingParameters: ...
    @property
    def MinimumEdgeLength(self) -> float: ...
    @property
    def MinimumTolerance(self) -> float: ...
    @property
    def QualityRenderMesh(self) -> MeshingParameters: ...
    @property
    def RefineAngle(self) -> float: ...
    @property
    def RefineAngleInDegrees(self) -> float: ...
    @property
    def RefineGrid(self) -> bool: ...
    @property
    def RelativeTolerance(self) -> float: ...
    @property
    def SimplePlanes(self) -> bool: ...
    @property
    def Smooth(self) -> MeshingParameters: ...
    @property
    def TextureRange(self) -> MeshingParameterTextureRange: ...
    @property
    def Tolerance(self) -> float: ...
    @overload
    def GetHashCode() -> int: ...
    @overload
    def GetObjectData(self, info: Serialization.SerializationInfo, context: Serialization.StreamingContext) -> None: ...
    @ClosedObjectPostProcess.setter
    def ClosedObjectPostProcess(self, value: System.Void): ...
    @ComputeCurvature.setter
    def ComputeCurvature(self, value: System.Void): ...
    @DoublePrecision.setter
    def DoublePrecision(self, value: System.Void): ...
    @GridAmplification.setter
    def GridAmplification(self, value: System.Void): ...
    @GridAngle.setter
    def GridAngle(self, value: System.Void): ...
    @GridAspectRatio.setter
    def GridAspectRatio(self, value: System.Void): ...
    @GridMaxCount.setter
    def GridMaxCount(self, value: System.Void): ...
    @GridMinCount.setter
    def GridMinCount(self, value: System.Void): ...
    @JaggedSeams.setter
    def JaggedSeams(self, value: System.Void): ...
    @MaximumEdgeLength.setter
    def MaximumEdgeLength(self, value: System.Void): ...
    @MinimumEdgeLength.setter
    def MinimumEdgeLength(self, value: System.Void): ...
    @MinimumTolerance.setter
    def MinimumTolerance(self, value: System.Void): ...
    @RefineAngle.setter
    def RefineAngle(self, value: System.Void): ...
    @RefineAngleInDegrees.setter
    def RefineAngleInDegrees(self, value: System.Void): ...
    @RefineGrid.setter
    def RefineGrid(self, value: System.Void): ...
    @RelativeTolerance.setter
    def RelativeTolerance(self, value: System.Void): ...
    @SimplePlanes.setter
    def SimplePlanes(self, value: System.Void): ...
    @TextureRange.setter
    def TextureRange(self, value: System.Void): ...
    @Tolerance.setter
    def Tolerance(self, value: System.Void): ...
    @overload
    def SetSubDDisplayParameters(self, subDDisplayParameters: SubDDisplayParameters) -> None: ...
    @overload
    def SubDDisplayParameters() -> SubDDisplayParameters: ...
    @overload
    def ToEncodedString() -> str: ...

class MeshPart(object):
    """Represents a portion of a mesh for partitioning

    """
    @property
    def EndFaceIndex(self) -> int: ...
    @property
    def EndVertexIndex(self) -> int: ...
    @property
    def StartFaceIndex(self) -> int: ...
    @property
    def StartVertexIndex(self) -> int: ...
    @property
    def TriangleCount(self) -> int: ...
    @property
    def VertexCount(self) -> int: ...

class MeshThicknessMeasurement(System.ValueType):
    """Thickness measurement used in the mesh thickness solver.

    """
    def __init__(self, meshIndex: int, vertexIndex: int, thickness: float, point: Point3d, oppositePoint: Point3d): ...
    @property
    def MeshIndex(self) -> int: ...
    @property
    def OppositePoint(self) -> Point3d: ...
    @property
    def Point(self) -> Point3d: ...
    @property
    def Thickness(self) -> float: ...
    @property
    def VertexIndex(self) -> int: ...

class ReduceMeshParameters(object):
    """Parameters for Reduce method

    """
    def __init__(self): ...
    @property
    def Accuracy(self) -> int: ...
    @property
    def AllowDistortion(self) -> bool: ...
    @property
    def CancelToken(self) -> Threading.CancellationToken: ...
    @property
    def DesiredPolygonCount(self) -> int: ...
    @property
    def Error(self) -> str: ...
    @property
    def FaceTags(self) -> System.System.Array[int]: ...
    @property
    def LockedComponents(self) -> System.Array[ComponentIndex]: ...
    @property
    def NormalizeMeshSize(self) -> bool: ...
    @property
    def ProgressReporter(self) -> System.IProgress: ...
    @Accuracy.setter
    def Accuracy(self, value: System.Void): ...
    @AllowDistortion.setter
    def AllowDistortion(self, value: System.Void): ...
    @CancelToken.setter
    def CancelToken(self, value: System.Void): ...
    @DesiredPolygonCount.setter
    def DesiredPolygonCount(self, value: System.Void): ...
    @FaceTags.setter
    def FaceTags(self, value: System.Void): ...
    @LockedComponents.setter
    def LockedComponents(self, value: System.Void): ...
    @NormalizeMeshSize.setter
    def NormalizeMeshSize(self, value: System.Void): ...
    @ProgressReporter.setter
    def ProgressReporter(self, value: System.Void): ...

class QuadRemeshParameters(object):
    """Parameters for QuadRemesh method

    """
    def __init__(self): ...
    @property
    def AdaptiveQuadCount(self) -> bool: ...
    @property
    def AdaptiveSize(self) -> float: ...
    @property
    def DetectHardEdges(self) -> bool: ...
    @property
    def GuideCurveInfluence(self) -> int: ...
    @property
    def PreserveMeshArrayEdgesMode(self) -> int: ...
    @property
    def SymmetryAxis(self) -> QuadRemeshSymmetryAxis: ...
    @property
    def TargetEdgeLength(self) -> float: ...
    @property
    def TargetQuadCount(self) -> int: ...
    @AdaptiveQuadCount.setter
    def AdaptiveQuadCount(self, value: System.Void): ...
    @AdaptiveSize.setter
    def AdaptiveSize(self, value: System.Void): ...
    @DetectHardEdges.setter
    def DetectHardEdges(self, value: System.Void): ...
    @GuideCurveInfluence.setter
    def GuideCurveInfluence(self, value: System.Void): ...
    @PreserveMeshArrayEdgesMode.setter
    def PreserveMeshArrayEdgesMode(self, value: System.Void): ...
    @SymmetryAxis.setter
    def SymmetryAxis(self, value: System.Void): ...
    @TargetEdgeLength.setter
    def TargetEdgeLength(self, value: System.Void): ...
    @TargetQuadCount.setter
    def TargetQuadCount(self, value: System.Void): ...

class QuadRemeshSymmetryAxis(enum.Enum):
    None_ = 0
    X = 1
    Y = 2
    Z = 4

class ShrinkWrapParameters(object):
    """Parameters for ShrinkWrap method

    """
    def __init__(self): ...
    @property
    def FillHolesInInputObjects(self) -> bool: ...
    @property
    def InflateVerticesAndPoints(self) -> bool: ...
    @property
    def Offset(self) -> float: ...
    @property
    def PolygonOptimization(self) -> int: ...
    @property
    def SmoothingIterations(self) -> int: ...
    @property
    def TargetEdgeLength(self) -> float: ...
    @FillHolesInInputObjects.setter
    def FillHolesInInputObjects(self, value: System.Void): ...
    @InflateVerticesAndPoints.setter
    def InflateVerticesAndPoints(self, value: System.Void): ...
    @Offset.setter
    def Offset(self, value: System.Void): ...
    @PolygonOptimization.setter
    def PolygonOptimization(self, value: System.Void): ...
    @SmoothingIterations.setter
    def SmoothingIterations(self, value: System.Void): ...
    @TargetEdgeLength.setter
    def TargetEdgeLength(self, value: System.Void): ...

class Mesh(GeometryBase):
    """Represents a geometry type that is defined by vertices and faces.
This is often called a face-vertex mesh.

    """
    def __init__(self): ...
    @overload
    def Append(self, meshes: Generic.IEnumerable) -> None: ...
    @overload
    def Append(self, other: Mesh) -> None: ...
    @overload
    def Check(self, textLog: FileIO.TextLog) -> (bool, MeshCheckParameters): ...
    @overload
    def ClearSurfaceData() -> None: ...
    @overload
    def ClearTextureData() -> None: ...
    @overload
    def ClosestMeshPoint(self, testPoint: Point3d, maximumDistance: float) -> MeshPoint: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> (int, Point3d): ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> (int, Point3d, Vector3d): ...
    @overload
    def CollapseFacesByArea(self, lessThanArea: float, greaterThanArea: float) -> int: ...
    @overload
    def CollapseFacesByByAspectRatio(self, aspectRatio: float) -> int: ...
    @overload
    def CollapseFacesByEdgeLength(self, bGreaterThan: bool, edgeLength: float) -> int: ...
    @overload
    def ColorAt(self, meshPoint: MeshPoint) -> Drawing.Color: ...
    @overload
    def ColorAt(self, faceIndex: int, t0: float, t1: float, t2: float, t3: float) -> Drawing.Color: ...
    @overload
    def Compact() -> bool: ...
    @overload
    def ComputeAutoCreaseInformation() -> System.System.Array[System.Byte]: ...
    @overload
    def ComputeCurvatureApproximation(self, type_: int) -> (bool, System.System.Array[float]): ...
    @overload
    @staticmethod
    def ComputeThickness(meshes: Generic.IEnumerable, maximumThickness: float) -> System.Array[MeshThicknessMeasurement]: ...
    @overload
    @staticmethod
    def ComputeThickness(meshes: Generic.IEnumerable, maximumThickness: float, cancelToken: Threading.CancellationToken) -> System.Array[MeshThicknessMeasurement]: ...
    @overload
    @staticmethod
    def ComputeThickness(meshes: Generic.IEnumerable, maximumThickness: float, sharpAngle: float, cancelToken: Threading.CancellationToken) -> System.Array[MeshThicknessMeasurement]: ...
    @overload
    def CopyFrom(self, other: Mesh) -> None: ...
    @overload
    @staticmethod
    def CreateBooleanDifference(firstSet: Generic.IEnumerable, secondSet: Generic.IEnumerable) -> System.Array[Mesh]: ...
    @overload
    @staticmethod
    def CreateBooleanDifference(firstSet: Generic.IEnumerable, secondSet: Generic.IEnumerable, options: MeshBooleanOptions) -> (System.Array[Mesh], Commands.Result): ...
    @overload
    @staticmethod
    def CreateBooleanIntersection(firstSet: Generic.IEnumerable, secondSet: Generic.IEnumerable) -> System.Array[Mesh]: ...
    @overload
    @staticmethod
    def CreateBooleanIntersection(firstSet: Generic.IEnumerable, secondSet: Generic.IEnumerable, options: MeshBooleanOptions) -> (System.Array[Mesh], Commands.Result): ...
    @overload
    @staticmethod
    def CreateBooleanSplit(meshesToSplit: Generic.IEnumerable, meshSplitters: Generic.IEnumerable) -> System.Array[Mesh]: ...
    @overload
    @staticmethod
    def CreateBooleanSplit(meshesToSplit: Generic.IEnumerable, meshSplitters: Generic.IEnumerable, options: MeshBooleanOptions) -> (System.Array[Mesh], Commands.Result): ...
    @overload
    @staticmethod
    def CreateBooleanUnion(meshes: Generic.IEnumerable) -> System.Array[Mesh]: ...
    @overload
    @staticmethod
    def CreateBooleanUnion(meshes: Generic.IEnumerable, tolerance: float) -> System.Array[Mesh]: ...
    @overload
    @staticmethod
    def CreateBooleanUnion(meshes: Generic.IEnumerable, options: MeshBooleanOptions) -> (System.Array[Mesh], Commands.Result): ...
    @overload
    @staticmethod
    def CreateContourCurves(meshToContour: Mesh, sectionPlane: Plane, tolerance: float) -> System.Array[Curve]: ...
    @overload
    @staticmethod
    def CreateContourCurves(meshToContour: Mesh, contourStart: Point3d, contourEnd: Point3d, interval: float, tolerance: float) -> System.Array[Curve]: ...
    @overload
    @staticmethod
    def CreateConvexHull3D(points: Generic.IEnumerable, tolerance: float, angleTolerance: float) -> (Mesh, System.System.Array[System.System.Array[int]]): ...
    @overload
    @staticmethod
    def CreateExtrusion(profile: Curve, direction: Vector3d) -> Mesh: ...
    @overload
    @staticmethod
    def CreateExtrusion(profile: Curve, direction: Vector3d, parameters: MeshingParameters) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromBox(corners: Generic.IEnumerable, xCount: int, yCount: int, zCount: int) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromBox(box: BoundingBox, xCount: int, yCount: int, zCount: int) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromBox(box: Box, xCount: int, yCount: int, zCount: int) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromBrep(brep: Brep, meshingParameters: MeshingParameters) -> System.Array[Mesh]: ...
    @overload
    @staticmethod
    def CreateFromClosedPolyline(polyline: Polyline) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromCone(cone: Cone, vertical: int, around: int) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromCone(cone: Cone, vertical: int, around: int, solid: bool) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromCone(cone: Cone, vertical: int, around: int, solid: bool, quadCaps: bool) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromCurveExtrusion(curve: Curve, direction: Vector3d, parameters: MeshingParameters, boundingBox: BoundingBox) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromCurvePipe(curve: Curve, radius: float, segments: int, accuracy: int, capType: MeshPipeCapStyle, faceted: bool, intervals: Generic.IEnumerable) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromCylinder(cylinder: Cylinder, vertical: int, around: int) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromCylinder(cylinder: Cylinder, vertical: int, around: int, capBottom: bool, capTop: bool) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromCylinder(cylinder: Cylinder, vertical: int, around: int, capBottom: bool, capTop: bool, quadCaps: bool) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromCylinder(cylinder: Cylinder, vertical: int, around: int, capBottom: bool, capTop: bool, circumscribe: bool, quadCaps: bool) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromExtrusion(extrusion: Extrusion, meshingParameters: MeshingParameters) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromFilteredFaceList(original: Mesh, inclusion: Generic.IEnumerable) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromIterativeCleanup(meshes: Generic.IEnumerable, tolerance: float) -> System.Array[Mesh]: ...
    @overload
    @staticmethod
    def CreateFromLines(lines: System.Array[Curve], maxFaceValence: int, tolerance: float) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromPatchSingleFace(mesh: Mesh, components: Generic.IEnumerable) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromPlanarBoundary(boundary: Curve, parameters: MeshingParameters, tolerance: float) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromPlane(plane: Plane, xInterval: Interval, yInterval: Interval, xCount: int, yCount: int) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromSphere(sphere: Sphere, xCount: int, yCount: int) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromSubD(subd: SubD, displayDensity: int) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromSubDControlNet(subd: SubD) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromSubDControlNetWithTextureCoordinates(subd: SubD) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromSurface(surface: Surface) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromSurface(surface: Surface, meshingParameters: MeshingParameters) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromSurfaceControlNet(surface: Surface) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromTessellation(points: Generic.IEnumerable, edges: Generic.IEnumerable, plane: Plane, allowNewVertices: bool) -> Mesh: ...
    @overload
    @staticmethod
    def CreateFromTorus(torus: Torus, vertical: int, around: int) -> Mesh: ...
    @overload
    @staticmethod
    def CreateIcoSphere(sphere: Sphere, subdivisions: int) -> Mesh: ...
    @overload
    def CreatePartitions(self, maximumVertexCount: int, maximumTriangleCount: int) -> bool: ...
    @overload
    @staticmethod
    def CreatePatch(outerBoundary: Polyline, angleToleranceRadians: float, pullbackSurface: Surface, innerBoundaryCurves: Generic.IEnumerable, innerBothSideCurves: Generic.IEnumerable, innerPoints: Generic.IEnumerable, trimback: bool, divisions: int) -> Mesh: ...
    @overload
    @staticmethod
    def CreateQuadSphere(sphere: Sphere, subdivisions: int) -> Mesh: ...
    @overload
    @staticmethod
    def CreateRefinedCatmullClarkMesh(mesh: Mesh, settings: MeshRefinements.RefinementSettings) -> Mesh: ...
    @overload
    @staticmethod
    def CreateRefinedLoopMesh(mesh: Mesh, formula: MeshRefinements.LoopFormula, settings: MeshRefinements.RefinementSettings) -> Mesh: ...
    @overload
    @staticmethod
    def CreateUnweldedMesh(mesh: Mesh) -> Mesh: ...
    @overload
    def CreateVertexColorsFromBitmap(self, doc: Rhino.RhinoDoc, mapping: Render.TextureMapping, xform: Transform, bitmap: Drawing.Bitmap) -> bool: ...
    @overload
    def DestroyPartition() -> None: ...
    @overload
    def DestroyTopology() -> None: ...
    @overload
    def DestroyTree() -> None: ...
    @overload
    def Duplicate() -> GeometryBase: ...
    @overload
    def DuplicateMesh() -> Mesh: ...
    @overload
    def EvaluateMeshGeometry(self, surface: Surface) -> bool: ...
    @overload
    def ExplodeAtUnweldedEdges() -> System.Array[Mesh]: ...
    @overload
    def ExtendSelectionByEdgeRidge(self, preselectedEdges: System.System.Array[int], newEdge: int, iterative: bool) -> System.System.Array[int]: ...
    @overload
    def ExtendSelectionByFaceLoop(self, preselectedFaces: System.System.Array[int], newFace: int, iterative: bool) -> System.System.Array[int]: ...
    @overload
    def ExtractNonManifoldEdges(self, selective: bool) -> Mesh: ...
    @overload
    def FileHole(self, topologyEdgeIndex: int) -> bool: ...
    @overload
    def FillHoles() -> bool: ...
    @overload
    def Flip(self, vertexNormals: bool, faceNormals: bool, faceOrientation: bool) -> None: ...
    @overload
    def Flip(self, vertexNormals: bool, faceNormals: bool, faceOrientation: bool, ngonsBoundaryDirection: bool) -> None: ...
    @property
    def ComponentStates(self) -> Collections.MeshVertexStatusList: ...
    @property
    def DisjointMeshCount(self) -> int: ...
    @property
    def FaceNormals(self) -> Collections.MeshFaceNormalList: ...
    @property
    def Faces(self) -> Collections.MeshFaceList: ...
    @property
    def HasCachedTextureCoordinates(self) -> bool: ...
    @property
    def HasPrincipalCurvatures(self) -> bool: ...
    @property
    def IsClosed(self) -> bool: ...
    @property
    def IsOriented(self) -> bool: ...
    @property
    def IsSolid(self) -> bool: ...
    @property
    def Ngons(self) -> Collections.MeshNgonList: ...
    @property
    def Normals(self) -> Collections.MeshVertexNormalList: ...
    @property
    def PartitionCount(self) -> int: ...
    @property
    def TextureCoordinates(self) -> Collections.MeshTextureCoordinateList: ...
    @property
    def TopologyEdges(self) -> Collections.MeshTopologyEdgeList: ...
    @property
    def TopologyVertices(self) -> Collections.MeshTopologyVertexList: ...
    @property
    def VertexColors(self) -> Collections.MeshVertexColorList: ...
    @property
    def Vertices(self) -> Collections.MeshVertexList: ...
    @overload
    def GetCachedTextureCoordinates(self, textureMappingId: System.Guid) -> Render.CachedTextureCoordinates: ...
    @overload
    def GetCachedTextureCoordinates(self, rhinoObject: DocObjects.RhinoObject, texture: DocObjects.Texture) -> Render.CachedTextureCoordinates: ...
    @overload
    def GetNakedEdgePointStatus() -> System.System.Array[bool]: ...
    @overload
    def GetNakedEdges() -> System.Array[Polyline]: ...
    @overload
    def GetNgonAndFacesCount() -> int: ...
    @overload
    def GetNgonAndFacesEnumerable() -> Generic.IEnumerable: ...
    @overload
    def GetOutlines(self, viewport: Display.RhinoViewport) -> System.Array[Polyline]: ...
    @overload
    def GetOutlines(self, plane: Plane) -> System.Array[Polyline]: ...
    @overload
    def GetOutlines(self, viewportInfo: DocObjects.ViewportInfo, plane: Plane) -> System.Array[Polyline]: ...
    @overload
    def GetPartition(self, which: int) -> MeshPart: ...
    @overload
    def GetSelfIntersections(self, tolerance: float, overlapsPolylines: bool, overlapsMesh: bool, textLog: FileIO.TextLog, cancel: Threading.CancellationToken, progress: System.IProgress) -> (bool, System.Array[Polyline], System.Array[Polyline], Mesh): ...
    @overload
    def GetUnsafeLock(self, writable: bool) -> MeshUnsafeLock: ...
    @overload
    def HealNakedEdges(self, distance: float) -> bool: ...
    @overload
    def InvalidateCachedTextureCoordinates(self, bOnlyInvalidateCachedSurfaceParameterMapping: bool) -> None: ...
    @overload
    def IsManifold() -> bool: ...
    @overload
    def IsManifold(self, topologicalTest: bool) -> (bool, bool, bool): ...
    @overload
    def IsPointInside(self, point: Point3d, tolerance: float, strictlyIn: bool) -> bool: ...
    @overload
    def MatchEdges(self, distance: float, rachet: bool) -> bool: ...
    @overload
    def MergeAllCoplanarFaces(self, tolerance: float) -> bool: ...
    @overload
    def MergeAllCoplanarFaces(self, tolerance: float, angleTolerance: float) -> bool: ...
    @overload
    def NormalAt(self, meshPoint: MeshPoint) -> Vector3d: ...
    @overload
    def NormalAt(self, faceIndex: int, t0: float, t1: float, t2: float, t3: float) -> Vector3d: ...
    @overload
    def Offset(self, distance: float) -> Mesh: ...
    @overload
    def Offset(self, distance: float, solidify: bool) -> Mesh: ...
    @overload
    def Offset(self, distance: float, solidify: bool, direction: Vector3d) -> Mesh: ...
    @overload
    def Offset(self, distance: float, solidify: bool, direction: Vector3d) -> (Mesh, Generic.List): ...
    @overload
    def PatchSingleFace(self, components: Generic.IEnumerable) -> bool: ...
    @overload
    def PointAt(self, meshPoint: MeshPoint) -> Point3d: ...
    @overload
    def PointAt(self, faceIndex: int, t0: float, t1: float, t2: float, t3: float) -> Point3d: ...
    @overload
    def PullCurve(self, curve: Curve, tolerance: float) -> PolylineCurve: ...
    @overload
    def PullPointsToMesh(self, points: Generic.IEnumerable) -> System.Array[Point3d]: ...
    @overload
    def QuadRemesh(self, parameters: QuadRemeshParameters) -> Mesh: ...
    @overload
    def QuadRemesh(self, parameters: QuadRemeshParameters, guideCurves: Generic.IEnumerable) -> Mesh: ...
    @overload
    def QuadRemeshAsync(self, parameters: QuadRemeshParameters, progress: System.IProgress, cancelToken: Threading.CancellationToken) -> Tasks.Task: ...
    @overload
    def QuadRemeshAsync(self, parameters: QuadRemeshParameters, guideCurves: Generic.IEnumerable, progress: System.IProgress, cancelToken: Threading.CancellationToken) -> Tasks.Task: ...
    @overload
    def QuadRemeshAsync(self, faceBlocks: Generic.IEnumerable, parameters: QuadRemeshParameters, guideCurves: Generic.IEnumerable, progress: System.IProgress, cancelToken: Threading.CancellationToken) -> Tasks.Task: ...
    @overload
    @staticmethod
    def QuadRemeshBrep(brep: Brep, parameters: QuadRemeshParameters) -> Mesh: ...
    @overload
    @staticmethod
    def QuadRemeshBrep(brep: Brep, parameters: QuadRemeshParameters, guideCurves: Generic.IEnumerable) -> Mesh: ...
    @overload
    @staticmethod
    def QuadRemeshBrepAsync(brep: Brep, parameters: QuadRemeshParameters, progress: System.IProgress, cancelToken: Threading.CancellationToken) -> Tasks.Task: ...
    @overload
    @staticmethod
    def QuadRemeshBrepAsync(brep: Brep, parameters: QuadRemeshParameters, guideCurves: Generic.IEnumerable, progress: System.IProgress, cancelToken: Threading.CancellationToken) -> Tasks.Task: ...
    @overload
    def RebuildNormals() -> None: ...
    @overload
    def Reduce(self, parameters: ReduceMeshParameters) -> bool: ...
    @overload
    def Reduce(self, parameters: ReduceMeshParameters, threaded: bool) -> bool: ...
    @overload
    def Reduce(self, desiredPolygonCount: int, allowDistortion: bool, accuracy: int, normalizeSize: bool) -> bool: ...
    @overload
    def Reduce(self, desiredPolygonCount: int, allowDistortion: bool, accuracy: int, normalizeSize: bool, threaded: bool) -> bool: ...
    @overload
    def Reduce(self, desiredPolygonCount: int, allowDistortion: bool, accuracy: int, normalizeSize: bool, cancelToken: Threading.CancellationToken, progress: System.IProgress) -> (bool, str): ...
    @overload
    def Reduce(self, desiredPolygonCount: int, allowDistortion: bool, accuracy: int, normalizeSize: bool, cancelToken: Threading.CancellationToken, progress: System.IProgress, threaded: bool) -> (bool, str): ...
    @overload
    def ReleaseUnsafeLock(self, meshData: MeshUnsafeLock) -> None: ...
    @overload
    @staticmethod
    def RequireIterativeCleanup(meshes: Generic.IEnumerable, tolerance: float) -> bool: ...
    @overload
    def SetCachedTextureCoordinates(self, tm: Render.TextureMapping) -> (Transform): ...
    @overload
    def SetCachedTextureCoordinatesFromMaterial(self, rhinoObject: DocObjects.RhinoObject, material: DocObjects.Material) -> None: ...
    @overload
    def SetSurfaceParametersFromTextureCoordinates() -> bool: ...
    @overload
    def SetTextureCoordinates(self, tm: Render.TextureMapping, xf: Transform, lazy: bool) -> None: ...
    @overload
    def SetTextureCoordinates(self, tm: Render.TextureMapping, xf: Transform, lazy: bool, seamCheck: bool) -> None: ...
    @overload
    def ShrinkWrap(self, parameters: ShrinkWrapParameters) -> Mesh: ...
    @overload
    def ShrinkWrap(self, parameters: ShrinkWrapParameters, token: Threading.CancellationToken) -> Mesh: ...
    @overload
    @staticmethod
    def ShrinkWrap(pointCloud: PointCloud, parameters: ShrinkWrapParameters) -> Mesh: ...
    @overload
    @staticmethod
    def ShrinkWrap(meshes: Generic.IEnumerable, parameters: ShrinkWrapParameters) -> Mesh: ...
    @overload
    @staticmethod
    def ShrinkWrap(geometryBases: Generic.IEnumerable, parameters: ShrinkWrapParameters, meshingParameters: MeshingParameters) -> Mesh: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> bool: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> bool: ...
    @overload
    def Smooth(self, vertexIndices: Generic.IEnumerable, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> bool: ...
    @overload
    def Smooth(self, smoothFactor: float, numSteps: int, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> bool: ...
    @overload
    def Smooth(self, vertexIndices: Generic.IEnumerable, smoothFactor: float, numSteps: int, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> bool: ...
    @overload
    def SolidOrientation() -> int: ...
    @overload
    def Split(self, mesh: Mesh) -> System.Array[Mesh]: ...
    @overload
    def Split(self, plane: Plane) -> System.Array[Mesh]: ...
    @overload
    def Split(self, meshes: Generic.IEnumerable) -> System.Array[Mesh]: ...
    @overload
    def Split(self, meshes: Generic.IEnumerable, tolerance: float, splitAtCoplanar: bool, textLog: FileIO.TextLog, cancel: Threading.CancellationToken, progress: System.IProgress) -> System.Array[Mesh]: ...
    @overload
    def Split(self, meshes: Generic.IEnumerable, tolerance: float, splitAtCoplanar: bool, createNgons: bool, textLog: FileIO.TextLog, cancel: Threading.CancellationToken, progress: System.IProgress) -> System.Array[Mesh]: ...
    @overload
    def SplitDisjointPieces() -> System.Array[Mesh]: ...
    @overload
    def SplitWithProjectedPolylines(self, curves: Generic.IEnumerable, tolerance: float) -> System.Array[Mesh]: ...
    @overload
    def SplitWithProjectedPolylines(self, curves: Generic.IEnumerable, tolerance: float, textLog: FileIO.TextLog, cancel: Threading.CancellationToken, progress: System.IProgress) -> System.Array[Mesh]: ...
    @overload
    def Subdivide() -> bool: ...
    @overload
    def Subdivide(self, faceIndices: Generic.IEnumerable) -> bool: ...
    @overload
    def UnifyNormals() -> int: ...
    @overload
    def UnifyNormals(self, countOnly: bool) -> int: ...
    @overload
    def Unweld(self, angleToleranceRadians: float, modifyNormals: bool) -> None: ...
    @overload
    def UnweldEdge(self, edgeIndices: Generic.IEnumerable, modifyNormals: bool) -> bool: ...
    @overload
    def UnweldVertices(self, topologyVertexIndices: Generic.IEnumerable, modifyNormals: bool) -> bool: ...
    @overload
    def Volume() -> float: ...
    @overload
    def Weld(self, angleToleranceRadians: float) -> None: ...
    @overload
    def WithDisplacement(self, displacement: MeshDisplacementInfo) -> Mesh: ...
    @overload
    def WithEdgeSoftening(self, softeningRadius: float, chamfer: bool, faceted: bool, force: bool, angleThreshold: float) -> Mesh: ...
    @overload
    def WithShutLining(self, faceted: bool, tolerance: float, curves: Generic.IEnumerable) -> Mesh: ...

class MeshBooleanOptions(object):
    """Contains a set of data to pass to boolean options.

    """
    def __init__(self): ...
    @property
    def CancellationToken(self) -> Threading.CancellationToken: ...
    @property
    def ProgressReporter(self) -> System.IProgress: ...
    @property
    def TextLog(self) -> FileIO.TextLog: ...
    @property
    def Tolerance(self) -> float: ...
    @CancellationToken.setter
    def CancellationToken(self, value: System.Void): ...
    @ProgressReporter.setter
    def ProgressReporter(self, value: System.Void): ...
    @TextLog.setter
    def TextLog(self, value: System.Void): ...
    @Tolerance.setter
    def Tolerance(self, value: System.Void): ...

class MeshUnsafeLock(object):
    """Permits access to the underlying mesh raw data structures in an unsafe way.

    """
    @overload
    def FaceNormalsArray() -> (Vector3f, int): ...
    @overload
    def FacesArray() -> (MeshFace, int): ...
    @overload
    def NormalVector3fArray() -> (Vector3f, int): ...
    @overload
    def Release() -> None: ...
    @overload
    def VertexColorsArray() -> (System.Int32, int): ...
    @overload
    def VertexPoint3dArray() -> (Point3d, int): ...
    @overload
    def VertexPoint3fArray() -> (Point3f, int): ...

class MeshFace(System.ValueType):
    """Represents the values of the four indices of a mesh face quad.
If the third and fourth values are the same, this face represents a triangle.

    """
    @overload
    def __init__(self, a: int, b: int, c: int): ...
    @overload
    def __init__(self, a: int, b: int, c: int, d: int): ...
    @overload
    def CompareTo(self, other: MeshFace) -> int: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Equals(self, other: MeshFace) -> bool: ...
    @overload
    def Flip() -> MeshFace: ...
    @property
    def A(self) -> int: ...
    @property
    def B(self) -> int: ...
    @property
    def C(self) -> int: ...
    @property
    def D(self) -> int: ...
    @property
    def IsQuad(self) -> bool: ...
    @property
    def IsTriangle(self) -> bool: ...
    @property
    def Item(self) -> int: ...
    @property
    def Unset(self) -> MeshFace: ...
    @overload
    def GetHashCode() -> int: ...
    @overload
    def IsValid() -> bool: ...
    @overload
    def IsValid(self, vertexCount: int) -> bool: ...
    @overload
    def IsValid(self, points: System.Array[Point3d]) -> bool: ...
    @overload
    def IsValidEx() -> (bool, System.Array[Point3d]): ...
    @overload
    def Repair(self, points: System.Array[Point3d]) -> bool: ...
    @overload
    def RepairEx() -> (bool, System.Array[Point3d]): ...
    @A.setter
    def A(self, value: System.Void): ...
    @B.setter
    def B(self, value: System.Void): ...
    @C.setter
    def C(self, value: System.Void): ...
    @D.setter
    def D(self, value: System.Void): ...
    @Item.setter
    def Item(self, value: System.Void): ...
    @overload
    def Set(self, a: int, b: int, c: int) -> None: ...
    @overload
    def Set(self, a: int, b: int, c: int, d: int) -> None: ...
    @overload
    def ToString() -> str: ...

class MeshNgon(object):
    """Represents a mesh ngon.
When retrieved from the Ngon property of a mesh, this contains faces that have edge valence strictly higher than 4.
When retrieving Ngons from
, this might contain also triangles and quads.

    """
    @overload
    def BoundaryVertexIndexList() -> System.System.Array[System.UInt32]: ...
    @overload
    def CompareTo(self, otherNgon: MeshNgon) -> int: ...
    @overload
    @staticmethod
    def Create(meshVertexIndexList: Generic.IList, meshFaceIndexList: Generic.IList) -> MeshNgon: ...
    @overload
    def Equals(self, otherNgon: MeshNgon) -> bool: ...
    @overload
    def Equals(self, otherObj: object) -> bool: ...
    @overload
    def FaceIndexList() -> System.System.Array[System.UInt32]: ...
    @property
    def BoundaryVertexCount(self) -> int: ...
    @property
    def Empty(self) -> MeshNgon: ...
    @property
    def FaceCount(self) -> int: ...
    @property
    def Item(self) -> int: ...
    @overload
    def GetHashCode() -> int: ...
    @overload
    def Set(self, meshVertexIndexList: Generic.IList, meshFaceIndexList: Generic.IList) -> None: ...
    @overload
    def ToString() -> str: ...

class ShutLiningCurveInfo(object):
    """Contains shutlining curve information. This is used in
.

    """
    def __init__(self, curve: Curve, radius: float, profile: int, pull: bool, isBump: bool, curveIntervals: Generic.IEnumerable, enabled: bool): ...
    @property
    def Curve(self) -> Curve: ...
    @property
    def CurveIntervals(self) -> ObjectModel.ReadOnlyCollection: ...
    @property
    def Enabled(self) -> bool: ...
    @property
    def IsBump(self) -> bool: ...
    @property
    def Profile(self) -> int: ...
    @property
    def Pull(self) -> bool: ...
    @property
    def Radius(self) -> float: ...

class MeshDisplacementInfo(object):
    """Contains mesh displacement information.

    """
    def __init__(self, texture: Render.RenderTexture, mapping: Render.TextureMapping): ...
    @property
    def Black(self) -> float: ...
    @property
    def BlackMove(self) -> float: ...
    @property
    def ChannelNumber(self) -> int: ...
    @property
    def FaceLimit(self) -> int: ...
    @property
    def FairingAmount(self) -> int: ...
    @property
    def InstanceTransform(self) -> Transform: ...
    @property
    def Mapping(self) -> Render.TextureMapping: ...
    @property
    def MappingTransform(self) -> Transform: ...
    @property
    def MemoryLimit(self) -> int: ...
    @property
    def PostWeldAngle(self) -> float: ...
    @property
    def RefineSensitivity(self) -> float: ...
    @property
    def RefineStepCount(self) -> int: ...
    @property
    def SweepPitch(self) -> float: ...
    @property
    def Texture(self) -> Render.RenderTexture: ...
    @property
    def White(self) -> float: ...
    @property
    def WhiteMove(self) -> float: ...
    @Black.setter
    def Black(self, value: System.Void): ...
    @BlackMove.setter
    def BlackMove(self, value: System.Void): ...
    @ChannelNumber.setter
    def ChannelNumber(self, value: System.Void): ...
    @FaceLimit.setter
    def FaceLimit(self, value: System.Void): ...
    @FairingAmount.setter
    def FairingAmount(self, value: System.Void): ...
    @InstanceTransform.setter
    def InstanceTransform(self, value: System.Void): ...
    @MappingTransform.setter
    def MappingTransform(self, value: System.Void): ...
    @MemoryLimit.setter
    def MemoryLimit(self, value: System.Void): ...
    @PostWeldAngle.setter
    def PostWeldAngle(self, value: System.Void): ...
    @RefineSensitivity.setter
    def RefineSensitivity(self, value: System.Void): ...
    @RefineStepCount.setter
    def RefineStepCount(self, value: System.Void): ...
    @SweepPitch.setter
    def SweepPitch(self, value: System.Void): ...
    @White.setter
    def White(self, value: System.Void): ...
    @WhiteMove.setter
    def WhiteMove(self, value: System.Void): ...

class NurbsSurface(Surface):
    """Represents a Non Uniform Rational B-Splines (NURBS) surface.

    """
    def __init__(self, other: NurbsSurface): ...
    @overload
    def ConvertSpanToBezier(self, spanIndex0: int, spanIndex1: int) -> BezierSurface: ...
    @overload
    def CopyFrom(self, other: NurbsSurface) -> None: ...
    @overload
    @staticmethod
    def Create(dimension: int, isRational: bool, order0: int, order1: int, controlPointCount0: int, controlPointCount1: int) -> NurbsSurface: ...
    @overload
    @staticmethod
    def CreateCurveOnSurface(surface: Surface, points: Generic.IEnumerable, tolerance: float, periodic: bool) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateCurveOnSurfacePoints(surface: Surface, fixedPoints: Generic.IEnumerable, tolerance: float, periodic: bool, initCount: int, levels: int) -> System.Array[Point2d]: ...
    @overload
    @staticmethod
    def CreateFromCone(cone: Cone) -> NurbsSurface: ...
    @overload
    @staticmethod
    def CreateFromCorners(corner1: Point3d, corner2: Point3d, corner3: Point3d) -> NurbsSurface: ...
    @overload
    @staticmethod
    def CreateFromCorners(corner1: Point3d, corner2: Point3d, corner3: Point3d, corner4: Point3d) -> NurbsSurface: ...
    @overload
    @staticmethod
    def CreateFromCorners(corner1: Point3d, corner2: Point3d, corner3: Point3d, corner4: Point3d, tolerance: float) -> NurbsSurface: ...
    @overload
    @staticmethod
    def CreateFromCylinder(cylinder: Cylinder) -> NurbsSurface: ...
    @overload
    @staticmethod
    def CreateFromPlane(plane: Plane, uInterval: Interval, vInterval: Interval, uDegree: int, vDegree: int, uPointCount: int, vPointCount: int) -> NurbsSurface: ...
    @overload
    @staticmethod
    def CreateFromPoints(points: Generic.IEnumerable, uCount: int, vCount: int, uDegree: int, vDegree: int) -> NurbsSurface: ...
    @overload
    @staticmethod
    def CreateFromSphere(sphere: Sphere) -> NurbsSurface: ...
    @overload
    @staticmethod
    def CreateFromTorus(torus: Torus) -> NurbsSurface: ...
    @overload
    @staticmethod
    def CreateNetworkSurface(curves: Generic.IEnumerable, continuity: int, edgeTolerance: float, interiorTolerance: float, angleTolerance: float) -> (NurbsSurface, int): ...
    @overload
    @staticmethod
    def CreateNetworkSurface(uCurves: Generic.IEnumerable, uContinuityStart: int, uContinuityEnd: int, vCurves: Generic.IEnumerable, vContinuityStart: int, vContinuityEnd: int, edgeTolerance: float, interiorTolerance: float, angleTolerance: float) -> (NurbsSurface, int): ...
    @overload
    @staticmethod
    def CreateRailRevolvedSurface(profile: Curve, rail: Curve, axis: Line, scaleHeight: bool) -> NurbsSurface: ...
    @overload
    @staticmethod
    def CreateRuledSurface(curveA: Curve, curveB: Curve) -> NurbsSurface: ...
    @overload
    @staticmethod
    def CreateSubDFriendly(surface: Surface) -> NurbsSurface: ...
    @overload
    @staticmethod
    def CreateThroughPoints(points: Generic.IEnumerable, uCount: int, vCount: int, uDegree: int, vDegree: int, uClosed: bool, vClosed: bool) -> NurbsSurface: ...
    @overload
    def EpsilonEquals(self, other: NurbsSurface, epsilon: float) -> bool: ...
    @overload
    def FindClosestIsoCurve(self, testPoint: Point3d) -> IsoStatus: ...
    @property
    def IsRational(self) -> bool: ...
    @property
    def KnotsU(self) -> Collections.NurbsSurfaceKnotList: ...
    @property
    def KnotsV(self) -> Collections.NurbsSurfaceKnotList: ...
    @property
    def OrderU(self) -> int: ...
    @property
    def OrderV(self) -> int: ...
    @property
    def Points(self) -> Collections.NurbsSurfacePointList: ...
    @overload
    def IncreaseDegreeU(self, desiredDegree: int) -> bool: ...
    @overload
    def IncreaseDegreeV(self, desiredDegree: int) -> bool: ...
    @overload
    @staticmethod
    def MakeCompatible(surface0: Surface, surface1: Surface) -> (bool, NurbsSurface, NurbsSurface): ...
    @overload
    def MakeNonRational() -> bool: ...
    @overload
    def MakeRational() -> bool: ...
    @overload
    def MatchToCurve(self, side: IsoStatus, targetCurve: Curve, maxEndDistance: float, maxInteriorDistance: float, matchTolerance: float, maxLevel: int) -> NurbsSurface: ...
    @overload
    def UVNDirectionsAt(self, u: float, v: float) -> (bool, Vector3d, Vector3d, Vector3d): ...

class MorphControl(GeometryBase):
    """Represents a geometry that is able to control the morphing behavior of some other geometry.

    """
    def __init__(self, originCurve: NurbsCurve, targetCurve: NurbsCurve): ...
    @property
    def Curve(self) -> NurbsCurve: ...
    @property
    def PreserveStructure(self) -> bool: ...
    @property
    def QuickPreview(self) -> bool: ...
    @property
    def SpaceMorphTolerance(self) -> float: ...
    @property
    def Surface(self) -> NurbsSurface: ...
    @overload
    def Morph(self, geometry: GeometryBase) -> bool: ...
    @PreserveStructure.setter
    def PreserveStructure(self, value: System.Void): ...
    @QuickPreview.setter
    def QuickPreview(self, value: System.Void): ...
    @SpaceMorphTolerance.setter
    def SpaceMorphTolerance(self, value: System.Void): ...

class HermiteSurface(object):
    """Create an ON_NurbsSurface satisfying Hermite interpolation conditions at a grid of points.

    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, uCount: int, vCount: int): ...
    @overload
    def Dispose() -> None: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def UCount(self) -> int: ...
    @property
    def VCount(self) -> int: ...
    @overload
    def PointAt(self, uIndex: int, vIndex: int) -> Point3d: ...
    @overload
    def SetPointAt(self, uIndex: int, vIndex: int, point: Point3d) -> None: ...
    @overload
    def SetTwistAt(self, uIndex: int, vIndex: int, twist: Vector3d) -> None: ...
    @overload
    def SetUParameterAt(self, index: int, parameter: float) -> None: ...
    @overload
    def SetUTangentAt(self, uIndex: int, vIndex: int, tangent: Vector3d) -> None: ...
    @overload
    def SetVParameterAt(self, index: int, parameter: float) -> None: ...
    @overload
    def SetVTangentAt(self, uIndex: int, vIndex: int, tangent: Vector3d) -> None: ...
    @overload
    def ToNurbsSurface() -> NurbsSurface: ...
    @overload
    def TwistAt(self, uIndex: int, vIndex: int) -> Vector3d: ...
    @overload
    def UParameterAt(self, index: int) -> float: ...
    @overload
    def UTangentAt(self, uIndex: int, vIndex: int) -> Vector3d: ...
    @overload
    def VParameterAt(self, index: int) -> float: ...
    @overload
    def VTangentAt(self, uIndex: int, vIndex: int) -> Vector3d: ...

class PlaneSurface(Surface):
    """Represents a plane surface.

    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, plane: Plane): ...
    @overload
    def __init__(self, plane: Plane, xExtents: Interval, yExtents: Interval): ...
    @overload
    @staticmethod
    def CreateThroughBox(plane: Plane, box: BoundingBox) -> PlaneSurface: ...
    @overload
    @staticmethod
    def CreateThroughBox(lineInPlane: Line, vectorInPlane: Vector3d, box: BoundingBox) -> PlaneSurface: ...
    @property
    def Plane(self) -> Plane: ...
    @overload
    def GetExtents(self, direction: int) -> Interval: ...
    @Plane.setter
    def Plane(self, value: System.Void): ...
    @overload
    def SetExtents(self, direction: int, extents: Interval, syncDomain: bool) -> None: ...
    @overload
    def ToMesh() -> Mesh: ...

class ClippingPlaneSurface(PlaneSurface):
    """Represents a planar surface that is used as clipping plane in viewports. A clipping plane object maintains a list of viewports that it clips against.

    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, plane: Plane): ...
    @overload
    def __init__(self, planeSurface: PlaneSurface): ...
    @overload
    def AddClipViewportId(self, viewportId: System.Guid) -> bool: ...
    @overload
    def ClearClipParticipationLists() -> None: ...
    @property
    def ParticipationListsEnabled(self) -> bool: ...
    @property
    def PlaneDepth(self) -> float: ...
    @property
    def PlaneDepthEnabled(self) -> bool: ...
    @overload
    def GetClipParticipation() -> (Generic.IEnumerable, Generic.IEnumerable, bool): ...
    @overload
    def RemoveClipViewportId(self, viewportId: System.Guid) -> bool: ...
    @ParticipationListsEnabled.setter
    def ParticipationListsEnabled(self, value: System.Void): ...
    @PlaneDepth.setter
    def PlaneDepth(self, value: System.Void): ...
    @PlaneDepthEnabled.setter
    def PlaneDepthEnabled(self, value: System.Void): ...
    @overload
    def SetClipParticipation(self, objectIds: Generic.IEnumerable, layerIndices: Generic.IEnumerable, isExclusionList: bool) -> None: ...
    @overload
    def ViewportIds() -> System.System.Array[System.Guid]: ...

class MeshPoint(object):
    """Represents a point that is found on a mesh.

    """
    @property
    def ComponentIndex(self) -> ComponentIndex: ...
    @property
    def EdgeIndex(self) -> int: ...
    @property
    def EdgeParameter(self) -> float: ...
    @property
    def FaceIndex(self) -> int: ...
    @property
    def Mesh(self) -> Mesh: ...
    @property
    def Point(self) -> Point3d: ...
    @property
    def T(self) -> System.System.Array[float]: ...
    @property
    def Triangle(self) -> System.Char: ...
    @overload
    def GetTriangle() -> (bool, int, int, int): ...

class SilhouetteType(enum.Enum):
    None_ = 0
    Projecting = 1
    TangentProjects = 2
    Tangent = 4
    Crease = 8
    Boundary = 16
    NonSilhouetteCrease = 256
    NonSilhouetteTangent = 512
    NonSilhouetteSeam = 1024
    SectionCut = 4096
    MiscellaneousFeature = 8192
    DraftCurve = 32768

class Silhouette(object):
    """Information about silhouette curves that are generated from geometry (surfaces, brep faces, meshes)

    """
    @overload
    @staticmethod
    def Compute(geometry: GeometryBase, silhouetteType: SilhouetteType, perspectiveCameraLocation: Point3d, tolerance: float, angleToleranceRadians: float) -> System.Array[Silhouette]: ...
    @overload
    @staticmethod
    def Compute(geometry: GeometryBase, silhouetteType: SilhouetteType, parallelCameraDirection: Vector3d, tolerance: float, angleToleranceRadians: float) -> System.Array[Silhouette]: ...
    @overload
    @staticmethod
    def Compute(geometry: GeometryBase, silhouetteType: SilhouetteType, viewport: DocObjects.ViewportInfo, tolerance: float, angleToleranceRadians: float) -> System.Array[Silhouette]: ...
    @overload
    @staticmethod
    def Compute(geometry: GeometryBase, silhouetteType: SilhouetteType, perspectiveCameraLocation: Point3d, tolerance: float, angleToleranceRadians: float, clippingPlanes: Generic.IEnumerable, cancelToken: Threading.CancellationToken) -> System.Array[Silhouette]: ...
    @overload
    @staticmethod
    def Compute(geometry: GeometryBase, silhouetteType: SilhouetteType, parallelCameraDirection: Vector3d, tolerance: float, angleToleranceRadians: float, clippingPlanes: Generic.IEnumerable, cancelToken: Threading.CancellationToken) -> System.Array[Silhouette]: ...
    @overload
    @staticmethod
    def Compute(geometry: GeometryBase, silhouetteType: SilhouetteType, viewport: DocObjects.ViewportInfo, tolerance: float, angleToleranceRadians: float, clippingPlanes: Generic.IEnumerable, cancelToken: Threading.CancellationToken) -> System.Array[Silhouette]: ...
    @overload
    @staticmethod
    def ComputeDraftCurve(geometry: GeometryBase, draftAngle: float, pullDirection: Vector3d, tolerance: float, angleToleranceRadians: float) -> System.Array[Silhouette]: ...
    @overload
    @staticmethod
    def ComputeDraftCurve(geometry: GeometryBase, draftAngle: float, pullDirection: Vector3d, tolerance: float, angleToleranceRadians: float, cancelToken: Threading.CancellationToken) -> System.Array[Silhouette]: ...
    @property
    def Curve(self) -> Curve: ...
    @property
    def GeometryComponentIndex(self) -> ComponentIndex: ...
    @property
    def SilhouetteType(self) -> SilhouetteType: ...

class PointCloudUnsafeLock(object):
    """Permits access to the underlying PointCloud raw data structures in an unsafe way.

    """
    @overload
    def ColorArray() -> (System.Int32, int): ...
    @overload
    def NormalArray() -> (Vector3d, int): ...
    @overload
    def PointArray() -> (Point3d, int): ...
    @overload
    def Release() -> None: ...
    @overload
    def ValueArray() -> (System.Double, int): ...

class PointCloudItem(object):
    """Represents a single item in a point cloud. A PointCloud item always has a location, but it has an optional normal vector and color.

    """
    @property
    def Color(self) -> Drawing.Color: ...
    @property
    def Hidden(self) -> bool: ...
    @property
    def Index(self) -> int: ...
    @property
    def Location(self) -> Point3d: ...
    @property
    def Normal(self) -> Vector3d: ...
    @property
    def PointValue(self) -> float: ...
    @property
    def X(self) -> float: ...
    @property
    def Y(self) -> float: ...
    @property
    def Z(self) -> float: ...
    @Color.setter
    def Color(self, value: System.Void): ...
    @Hidden.setter
    def Hidden(self, value: System.Void): ...
    @Location.setter
    def Location(self, value: System.Void): ...
    @Normal.setter
    def Normal(self, value: System.Void): ...
    @PointValue.setter
    def PointValue(self, value: System.Void): ...
    @X.setter
    def X(self, value: System.Void): ...
    @Y.setter
    def Y(self, value: System.Void): ...
    @Z.setter
    def Z(self, value: System.Void): ...

class PointCloud(GeometryBase):
    """Represents a collection of coordinates with optional normal vectors and colors.

    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: PointCloud): ...
    @overload
    def __init__(self, points: Generic.IEnumerable): ...
    @overload
    def Add(self, point: Point3d) -> None: ...
    @overload
    def Add(self, point: Point3d, color: Drawing.Color) -> None: ...
    @overload
    def Add(self, point: Point3d, normal: Vector3d) -> None: ...
    @overload
    def Add(self, point: Point3d, normal: Vector3d, color: Drawing.Color) -> None: ...
    @overload
    def Add(self, point: Point3d, normal: Vector3d, color: Drawing.Color, value: float) -> None: ...
    @overload
    def AddRange(self, points: Generic.IEnumerable) -> None: ...
    @overload
    def AddRange(self, points: Generic.IEnumerable, colors: Generic.IEnumerable) -> None: ...
    @overload
    def AddRange(self, points: Generic.IEnumerable, normals: Generic.IEnumerable) -> None: ...
    @overload
    def AddRange(self, points: Generic.IEnumerable, normals: Generic.IEnumerable, colors: Generic.IEnumerable) -> None: ...
    @overload
    def AddRange(self, points: Generic.IEnumerable, normals: Generic.IEnumerable, colors: Generic.IEnumerable, values: Generic.IEnumerable) -> None: ...
    @overload
    def AppendNew() -> PointCloudItem: ...
    @overload
    def AsReadOnlyListOfPoints() -> Generic.IReadOnlyList: ...
    @overload
    def ClearColors() -> None: ...
    @overload
    def ClearHiddenFlags() -> None: ...
    @overload
    def ClearNormals() -> None: ...
    @overload
    def ClearPointValues() -> None: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> int: ...
    @overload
    def CreateContourCurves(self, contourStart: Point3d, contourEnd: Point3d, interval: float, absoluteTolerance: float) -> System.Array[Curve]: ...
    @overload
    def CreateContourCurves(self, startPoint: Point3d, endPoint: Point3d, interval: float, absoluteTolerance: float, maxDistance: float, minDistance: float, openCurves: bool, createSpline: bool, createPolyline: bool, fitTolerance: float) -> System.Array[Curve]: ...
    @overload
    def CreateSectionCurve(self, plane: Plane, absoluteTolerance: float) -> System.Array[Curve]: ...
    @overload
    def CreateSectionCurve(self, plane: Plane, absoluteTolerance: float, maxDistance: float, minDistance: float, openCurves: bool, createSpline: bool, createPolyline: bool, fitTolerance: float) -> System.Array[Curve]: ...
    @property
    def ContainsColors(self) -> bool: ...
    @property
    def ContainsHiddenFlags(self) -> bool: ...
    @property
    def ContainsNormals(self) -> bool: ...
    @property
    def ContainsPointValues(self) -> bool: ...
    @property
    def Count(self) -> int: ...
    @property
    def HiddenPointCount(self) -> int: ...
    @property
    def Item(self) -> PointCloudItem: ...
    @overload
    def GetColors() -> Drawing.System.Array[Drawing.Color]: ...
    @overload
    def GetEnumerator() -> Generic.IEnumerator: ...
    @overload
    def GetNormals() -> System.Array[Vector3d]: ...
    @overload
    def GetPoints() -> System.Array[Point3d]: ...
    @overload
    def GetPointValues() -> System.System.Array[float]: ...
    @overload
    def GetRandomSubsample(self, numberOfPoints: System.UInt32) -> PointCloud: ...
    @overload
    def GetRandomSubsample(self, numberOfPoints: System.UInt32, cancelToken: Threading.CancellationToken, progress: System.IProgress) -> PointCloud: ...
    @overload
    def GetUnsafeLock(self, writable: bool) -> PointCloudUnsafeLock: ...
    @overload
    def Insert(self, index: int, point: Point3d) -> None: ...
    @overload
    def Insert(self, index: int, point: Point3d, normal: Vector3d) -> None: ...
    @overload
    def Insert(self, index: int, point: Point3d, color: Drawing.Color) -> None: ...
    @overload
    def Insert(self, index: int, point: Point3d, normal: Vector3d, color: Drawing.Color) -> None: ...
    @overload
    def Insert(self, index: int, point: Point3d, normal: Vector3d, color: Drawing.Color, value: float) -> None: ...
    @overload
    def InsertNew(self, index: int) -> PointCloudItem: ...
    @overload
    def InsertRange(self, index: int, points: Generic.IEnumerable) -> None: ...
    @overload
    def Merge(self, other: PointCloud) -> None: ...
    @overload
    def PointAt(self, index: int) -> Point3d: ...
    @overload
    def ReleaseUnsafeLock(self, pointCloudData: PointCloudUnsafeLock) -> None: ...
    @overload
    def RemoveAt(self, index: int) -> None: ...
    @overload
    def RemoveRange(self, indices: Generic.IEnumerable) -> int: ...
    @overload
    def ShrinkWrap(self, parameters: ShrinkWrapParameters) -> Mesh: ...

class Point(GeometryBase):
    """Represents a geometric point.
This is fundamentally a class that derives from
and contains a single
location.

    """
    def __init__(self, location: Point3d): ...
    @property
    def Location(self) -> Point3d: ...
    @Location.setter
    def Location(self, value: System.Void): ...

class Point3dGrid(GeometryBase):
    """Represents a rectangular grid of 3D points.

    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, rows: int, columns: int): ...

class PolyCurve(Curve):
    """Represents a curve that is the result of joining several (possibly different) types of curves.

    """
    def __init__(self): ...
    @overload
    def Append(self, line: Line) -> bool: ...
    @overload
    def Append(self, arc: Arc) -> bool: ...
    @overload
    def Append(self, curve: Curve) -> bool: ...
    @overload
    def AppendSegment(self, curve: Curve) -> bool: ...
    @overload
    def CleanUp() -> Curve: ...
    @overload
    def Duplicate() -> GeometryBase: ...
    @overload
    def DuplicatePolyCurve() -> PolyCurve: ...
    @overload
    def Explode() -> System.Array[Curve]: ...
    @property
    def HasGap(self) -> bool: ...
    @property
    def IsNested(self) -> bool: ...
    @property
    def SegmentCount(self) -> int: ...
    @overload
    def PolyCurveParameter(self, segmentIndex: int, segmentCurveParameter: float) -> float: ...
    @overload
    def RemoveNesting() -> bool: ...
    @overload
    def SegmentCurve(self, index: int) -> Curve: ...
    @overload
    def SegmentCurveParameter(self, polycurveParameter: float) -> float: ...
    @overload
    def SegmentDomain(self, segmentIndex: int) -> Interval: ...
    @overload
    def SegmentIndex(self, polycurveParameter: float) -> int: ...
    @overload
    def SegmentIndexes(self, subdomain: Interval) -> (int, int, int): ...

class Polyline(Collections.Point3dList):
    """Represents an ordered set of points connected by linear segments.
Polylines are closed if start and end points coincide.

    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, initialCapacity: int): ...
    @overload
    def __init__(self, collection: Generic.IEnumerable): ...
    @overload
    def BreakAtAngles(self, angle: float) -> System.Array[Polyline]: ...
    @overload
    def CenterPoint() -> Point3d: ...
    @overload
    def ClosestParameter(self, testPoint: Point3d) -> float: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...
    @overload
    def CollapseShortSegments(self, tolerance: float) -> int: ...
    @overload
    @staticmethod
    def CreateByJoiningLines(lines: Generic.IEnumerable, tolerance: float, splitAtIntersections: bool) -> System.Array[Polyline]: ...
    @overload
    @staticmethod
    def CreateCircumscribedPolygon(circle: Circle, sideCount: int) -> Polyline: ...
    @overload
    @staticmethod
    def CreateInscribedPolygon(circle: Circle, sideCount: int) -> Polyline: ...
    @overload
    @staticmethod
    def CreateStarPolygon(circle: Circle, radius: float, cornerCount: int) -> Polyline: ...
    @overload
    def DeleteShortSegments(self, tolerance: float) -> int: ...
    @overload
    def Duplicate() -> Polyline: ...
    @property
    def IsClosed(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Length(self) -> float: ...
    @property
    def SegmentCount(self) -> int: ...
    @overload
    def GetSegments() -> System.Array[Line]: ...
    @overload
    def IsClosedWithinTolerance(self, tolerance: float) -> bool: ...
    @overload
    def MergeColinearSegments(self, angleTolerance: float, includeSeam: bool) -> int: ...
    @overload
    def PointAt(self, t: float) -> Point3d: ...
    @overload
    def ReduceSegments(self, tolerance: float) -> int: ...
    @overload
    def RemoveNearlyEqualSubsequentPoints(self, tolerance: float) -> None: ...
    @overload
    def SegmentAt(self, index: int) -> Line: ...
    @overload
    def Smooth(self, amount: float) -> bool: ...
    @overload
    def TangentAt(self, t: float) -> Vector3d: ...
    @overload
    def ToNurbsCurve() -> NurbsCurve: ...
    @overload
    def ToPolylineCurve() -> PolylineCurve: ...
    @overload
    def TriangulateClosedPolyline() -> System.Array[MeshFace]: ...
    @overload
    def Trim(self, domain: Interval) -> Polyline: ...

class PolylineCurve(Curve):
    """Represents the geometry of a set of linked line segments.
This is fundamentally a class that derives from
and internally contains a
.

    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, other: PolylineCurve): ...
    @overload
    def __init__(self, points: Generic.IEnumerable): ...
    @overload
    @staticmethod
    def CreateConvexHull2d(points: System.Array[Point2d]) -> (PolylineCurve, System.System.Array[int]): ...
    @property
    def PointCount(self) -> int: ...
    @overload
    def Parameter(self, index: int) -> float: ...
    @overload
    def Point(self, index: int) -> Point3d: ...
    @overload
    def SetArcLengthParameterization(self, tolerance: float) -> None: ...
    @overload
    def SetParameter(self, index: int, parameter: float) -> None: ...
    @overload
    def SetPoint(self, index: int, point: Point3d) -> None: ...
    @overload
    def ToArray() -> System.Array[Point3d]: ...
    @overload
    def ToPolyline() -> Polyline: ...

class Rectangle3d(System.ValueType):
    """Represents the values of a plane and two intervals that form an oriented rectangle in three dimensions.

    """
    @overload
    def __init__(self, plane: Plane, width: float, height: float): ...
    @overload
    def __init__(self, plane: Plane, width: Interval, height: Interval): ...
    @overload
    def __init__(self, plane: Plane, cornerA: Point3d, cornerB: Point3d): ...
    @overload
    def ClosestPoint(self, point: Point3d) -> Point3d: ...
    @overload
    def ClosestPoint(self, point: Point3d, includeInterior: bool) -> Point3d: ...
    @overload
    def Contains(self, pt: Point3d) -> PointContainment: ...
    @overload
    def Contains(self, x: float, y: float) -> PointContainment: ...
    @overload
    def Corner(self, index: int) -> Point3d: ...
    @overload
    @staticmethod
    def CreateFromPolyline(polyline: Generic.IEnumerable) -> Rectangle3d: ...
    @overload
    @staticmethod
    def CreateFromPolyline(polyline: Generic.IEnumerable) -> (Rectangle3d, float, float): ...
    @overload
    def EpsilonEquals(self, other: Rectangle3d, epsilon: float) -> bool: ...
    @property
    def Area(self) -> float: ...
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @property
    def Center(self) -> Point3d: ...
    @property
    def Circumference(self) -> float: ...
    @property
    def Height(self) -> float: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Plane(self) -> Plane: ...
    @property
    def Unset(self) -> Rectangle3d: ...
    @property
    def Width(self) -> float: ...
    @property
    def X(self) -> Interval: ...
    @property
    def Y(self) -> Interval: ...
    @overload
    def MakeIncreasing() -> None: ...
    @overload
    def PointAt(self, t: float) -> Point3d: ...
    @overload
    def PointAt(self, x: float, y: float) -> Point3d: ...
    @overload
    def RecenterPlane(self, origin: Point3d) -> None: ...
    @overload
    def RecenterPlane(self, index: int) -> None: ...
    @Plane.setter
    def Plane(self, value: System.Void): ...
    @X.setter
    def X(self, value: System.Void): ...
    @Y.setter
    def Y(self, value: System.Void): ...
    @overload
    def ToNurbsCurve() -> NurbsCurve: ...
    @overload
    def ToPolyline() -> Polyline: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...

class RevSurface(Surface):
    """Represents a surface of revolution.
Revolutions can be incomplete (they can form arcs).

    """
    @overload
    @staticmethod
    def Create(revoluteCurve: Curve, axisOfRevolution: Line) -> RevSurface: ...
    @overload
    @staticmethod
    def Create(revoluteLine: Line, axisOfRevolution: Line) -> RevSurface: ...
    @overload
    @staticmethod
    def Create(revolutePolyline: Polyline, axisOfRevolution: Line) -> RevSurface: ...
    @overload
    @staticmethod
    def Create(revoluteCurve: Curve, axisOfRevolution: Line, startAngleRadians: float, endAngleRadians: float) -> RevSurface: ...
    @overload
    @staticmethod
    def Create(revoluteLine: Line, axisOfRevolution: Line, startAngleRadians: float, endAngleRadians: float) -> RevSurface: ...
    @overload
    @staticmethod
    def Create(revolutePolyline: Polyline, axisOfRevolution: Line, startAngleRadians: float, endAngleRadians: float) -> RevSurface: ...
    @overload
    @staticmethod
    def CreateFromCone(cone: Cone) -> RevSurface: ...
    @overload
    @staticmethod
    def CreateFromCylinder(cylinder: Cylinder) -> RevSurface: ...
    @overload
    @staticmethod
    def CreateFromSphere(sphere: Sphere) -> RevSurface: ...
    @overload
    @staticmethod
    def CreateFromTorus(torus: Torus) -> RevSurface: ...
    @property
    def Angle(self) -> Interval: ...
    @property
    def Axis(self) -> Line: ...
    @property
    def Curve(self) -> Curve: ...
    @property
    def Interval(self) -> Interval: ...
    @property
    def IsTransposed(self) -> bool: ...

class RTreeEventArgs(System.EventArgs):
    """Represents event data that is passed when an item that meets certain criteria is found and the passed RTree event is raised.

    """
    @property
    def Cancel(self) -> bool: ...
    @property
    def Id(self) -> int: ...
    @property
    def IdB(self) -> int: ...
    @property
    def IdBPtr(self) -> System.IntPtr: ...
    @property
    def IdPtr(self) -> System.IntPtr: ...
    @property
    def SearchBoundingBox(self) -> BoundingBox: ...
    @property
    def SearchSphere(self) -> Sphere: ...
    @property
    def Tag(self) -> object: ...
    @Cancel.setter
    def Cancel(self, value: System.Void): ...
    @SearchBoundingBox.setter
    def SearchBoundingBox(self, value: System.Void): ...
    @SearchSphere.setter
    def SearchSphere(self, value: System.Void): ...
    @Tag.setter
    def Tag(self, value: System.Void): ...

class RTree(object):
    """Represents a spatial search structure based on implementations of the R-tree algorithm by Toni Gutman.

    """
    def __init__(self): ...
    @overload
    def Clear() -> None: ...
    @overload
    @staticmethod
    def CreateFromPointArray(points: Generic.IEnumerable) -> RTree: ...
    @overload
    @staticmethod
    def CreateMeshFaceTree(mesh: Mesh) -> RTree: ...
    @overload
    @staticmethod
    def CreatePointCloudTree(cloud: PointCloud) -> RTree: ...
    @overload
    def Dispose() -> None: ...
    @property
    def Count(self) -> int: ...
    @overload
    def Insert(self, point: Point3d, elementId: int) -> bool: ...
    @overload
    def Insert(self, point: Point2d, elementId: System.IntPtr) -> bool: ...
    @overload
    def Insert(self, point: Point2d, elementId: int) -> bool: ...
    @overload
    def Insert(self, box: BoundingBox, elementId: System.IntPtr) -> bool: ...
    @overload
    def Insert(self, point: Point3d, elementId: System.IntPtr) -> bool: ...
    @overload
    def Insert(self, box: BoundingBox, elementId: int) -> bool: ...
    @overload
    @staticmethod
    def Point3dClosestPoints(hayPoints: Generic.IEnumerable, needlePts: Generic.IEnumerable, limitDistance: float) -> Generic.IEnumerable: ...
    @overload
    @staticmethod
    def Point3dKNeighbors(hayPoints: Generic.IEnumerable, needlePts: Generic.IEnumerable, amount: int) -> Generic.IEnumerable: ...
    @overload
    @staticmethod
    def PointCloudClosestPoints(pointcloud: PointCloud, needlePts: Generic.IEnumerable, limitDistance: float) -> Generic.IEnumerable: ...
    @overload
    @staticmethod
    def PointCloudKNeighbors(pointcloud: PointCloud, needlePts: Generic.IEnumerable, amount: int) -> Generic.IEnumerable: ...
    @overload
    def Remove(self, point: Point3d, elementId: System.IntPtr) -> bool: ...
    @overload
    def Remove(self, box: BoundingBox, elementId: int) -> bool: ...
    @overload
    def Remove(self, box: BoundingBox, elementId: System.IntPtr) -> bool: ...
    @overload
    def Remove(self, point: Point2d, elementId: int) -> bool: ...
    @overload
    def Remove(self, point: Point3d, elementId: int) -> bool: ...
    @overload
    def Search(self, box: BoundingBox, callback: System.EventHandler) -> bool: ...
    @overload
    def Search(self, sphere: Sphere, callback: System.EventHandler) -> bool: ...
    @overload
    def Search(self, box: BoundingBox, callback: System.EventHandler, tag: object) -> bool: ...
    @overload
    def Search(self, sphere: Sphere, callback: System.EventHandler, tag: object) -> bool: ...
    @overload
    @staticmethod
    def SearchOverlaps(treeA: RTree, treeB: RTree, tolerance: float, callback: System.EventHandler) -> bool: ...

class SquishParameters(object):
    """Parameters used by the 'Squish' command flattening algorithm

    """
    def __init__(self): ...
    @overload
    def Dispose() -> None: ...
    @property
    def AbsoluteLimit(self) -> float: ...
    @property
    def Algorithm(self) -> SquishFlatteningAlgorithm: ...
    @property
    def BoundaryCompressConstant(self) -> float: ...
    @property
    def BoundaryStretchConstant(self) -> float: ...
    @property
    def Default(self) -> SquishParameters: ...
    @property
    def InteriorCompressConstant(self) -> float: ...
    @property
    def InteriorStretchConstant(self) -> float: ...
    @property
    def PreserveTopology(self) -> bool: ...
    @property
    def SaveMapping(self) -> bool: ...
    @overload
    def GetSpringConstants() -> (bool, float, float): ...
    @AbsoluteLimit.setter
    def AbsoluteLimit(self, value: System.Void): ...
    @Algorithm.setter
    def Algorithm(self, value: System.Void): ...
    @BoundaryCompressConstant.setter
    def BoundaryCompressConstant(self, value: System.Void): ...
    @BoundaryStretchConstant.setter
    def BoundaryStretchConstant(self, value: System.Void): ...
    @InteriorCompressConstant.setter
    def InteriorCompressConstant(self, value: System.Void): ...
    @InteriorStretchConstant.setter
    def InteriorStretchConstant(self, value: System.Void): ...
    @PreserveTopology.setter
    def PreserveTopology(self, value: System.Void): ...
    @SaveMapping.setter
    def SaveMapping(self, value: System.Void): ...
    @overload
    def SetDeformation(self, deformation: SquishDeformation, bPreserveBoundary: bool, boundaryStretchConstant: float, boundaryCompressConstant: float, interiorStretchConstant: float, interiorCompressConstant: float) -> None: ...
    @overload
    def SetSpringConstants(self, boundaryBias: float, deformationBias: float) -> None: ...

class Squisher(object):
    """class used to wrap Squish functions

    """
    def __init__(self): ...
    @overload
    def Dispose() -> None: ...
    @overload
    def Get2dMesh() -> Mesh: ...
    @overload
    def Get3dMesh() -> Mesh: ...
    @overload
    def GetAreaConstrainedTrianglesIndices() -> System.Array[MeshFace]: ...
    @overload
    def GetLengthConstrained2dLines() -> System.Array[Line]: ...
    @overload
    def GetLengthConstrained3dLines() -> System.Array[Line]: ...
    @overload
    def GetMesh2dEdges() -> System.Array[Line]: ...
    @overload
    def GetMesh3dEdges() -> System.Array[Line]: ...
    @overload
    @staticmethod
    def Is2dPatternSquished(geometry: GeometryBase) -> bool: ...
    @overload
    @staticmethod
    def SquishBack2dMarks(squishedGeometry: GeometryBase, marks: Generic.IEnumerable) -> Generic.IEnumerable: ...
    @overload
    def SquishCurve(self, curve: Curve) -> PolylineCurve: ...
    @overload
    def SquishMesh(self, sp: SquishParameters, mesh3d: Mesh) -> Mesh: ...
    @overload
    def SquishMesh(self, sp: SquishParameters, mesh3d: Mesh, marks: Generic.IEnumerable, squished_marks_out: Generic.List) -> Mesh: ...
    @overload
    def SquishPoint(self, point: Point3d) -> (bool, Point3d): ...
    @overload
    def SquishSurface(self, sp: SquishParameters, surface: Surface) -> Brep: ...
    @overload
    def SquishSurface(self, sp: SquishParameters, surface: Surface, marks: Generic.IEnumerable, squished_marks_out: Generic.List) -> Brep: ...
    @overload
    def SquishTextDot(self, textDot: TextDot) -> TextDot: ...

class SubDComponent(object):
    """A part of SubD geometry. Common base class for vertices, faces, and edges

    """
    @property
    def Id(self) -> System.UInt32: ...
    @property
    def IsDamaged(self) -> bool: ...
    @property
    def IsDeleted(self) -> bool: ...
    @property
    def IsHidden(self) -> bool: ...
    @property
    def IsHighlighted(self) -> bool: ...
    @property
    def IsLocked(self) -> bool: ...
    @property
    def IsSelected(self) -> bool: ...
    @property
    def ParentSubD(self) -> SubD: ...

class SubDFace(SubDComponent):
    """Single face of a SubD

    """
    @overload
    def ComponentIndex() -> ComponentIndex: ...
    @overload
    def EdgeAt(self, index: int) -> SubDEdge: ...
    @overload
    def EdgeDirectionMatchesFaceOrientation(self, index: int) -> bool: ...
    @property
    def ControlNetCenterFrame(self) -> Plane: ...
    @property
    def ControlNetCenterNormal(self) -> Vector3d: ...
    @property
    def ControlNetCenterPoint(self) -> Point3d: ...
    @property
    def EdgeCount(self) -> int: ...
    @property
    def LimitSurfaceCenterPoint(self) -> Point3d: ...
    @property
    def PerFaceColor(self) -> Drawing.Color: ...
    @property
    def SurfaceCenterFrame(self) -> Plane: ...
    @property
    def SurfaceCenterNormal(self) -> Vector3d: ...
    @property
    def VertexCount(self) -> int: ...
    @PerFaceColor.setter
    def PerFaceColor(self, value: System.Void): ...
    @overload
    def VertexAt(self, index: int) -> SubDVertex: ...

class SubDVertex(SubDComponent):
    """Single vertex of a SubD

    """
    @overload
    def EdgeAt(self, index: int) -> SubDEdge: ...
    @overload
    def FaceAt(self, index: int) -> SubDFace: ...
    @property
    def ControlNetPoint(self) -> Point3d: ...
    @property
    def EdgeCount(self) -> int: ...
    @property
    def Edges(self) -> Generic.IEnumerable: ...
    @property
    def FaceCount(self) -> int: ...
    @property
    def Next(self) -> SubDVertex: ...
    @property
    def Previous(self) -> SubDVertex: ...
    @property
    def Tag(self) -> SubDVertexTag: ...
    @ControlNetPoint.setter
    def ControlNetPoint(self, value: System.Void): ...
    @Tag.setter
    def Tag(self, value: System.Void): ...
    @overload
    def SetControlNetPoint(self, position: Point3d, bClearNeighborhoodCache: bool) -> bool: ...
    @overload
    def SurfacePoint() -> Point3d: ...

class SubDEdge(SubDComponent):
    """Single edge of a SubD

    """
    @overload
    def ComponentIndex() -> ComponentIndex: ...
    @overload
    def FaceAt(self, index: int) -> SubDFace: ...
    @property
    def ControlNetLine(self) -> Line: ...
    @property
    def FaceCount(self) -> int: ...
    @property
    def Tag(self) -> SubDEdgeTag: ...
    @property
    def VertexFrom(self) -> SubDVertex: ...
    @property
    def VertexTo(self) -> SubDVertex: ...
    @Tag.setter
    def Tag(self, value: System.Void): ...
    @overload
    def ToNurbsCurve(self, clampEnds: bool) -> NurbsCurve: ...

class SumSurface(Surface):
    """Represents a sum surface, or an extrusion of a curve along a curved path.

    """
    @overload
    @staticmethod
    def Create(curveA: Curve, curveB: Curve) -> SumSurface: ...
    @overload
    @staticmethod
    def Create(curve: Curve, extrusionDirection: Vector3d) -> SumSurface: ...

class IsoStatus(enum.Enum):
    None_ = 0
    X = 1
    Y = 2
    West = 3
    South = 4
    East = 5
    North = 6

class SurfaceCurvature(object):
    """Maintains computed information for surface curvature evaluation.

    """
    @overload
    def Direction(self, direction: int) -> Vector3d: ...
    @property
    def Gaussian(self) -> float: ...
    @property
    def Mean(self) -> float: ...
    @property
    def Normal(self) -> Vector3d: ...
    @property
    def Point(self) -> Point3d: ...
    @property
    def UVPoint(self) -> Point2d: ...
    @overload
    def Kappa(self, direction: int) -> float: ...
    @overload
    def OsculatingCircle(self, direction: int) -> Circle: ...

class Surface(GeometryBase):
    """Represents a base class that is common to most RhinoCommon surface types.
A surface represents an entity that can be all visited by providing two independent parameters, usually called (u, v), or sometimes (s, t).

    """
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> (bool, float, float): ...
    @overload
    def ClosestSide(self, u: float, v: float) -> IsoStatus: ...
    @overload
    @staticmethod
    def CreateExtrusion(profile: Curve, direction: Vector3d) -> Surface: ...
    @overload
    @staticmethod
    def CreateExtrusionToPoint(profile: Curve, apexPoint: Point3d) -> Surface: ...
    @overload
    @staticmethod
    def CreatePeriodicSurface(surface: Surface, direction: int) -> Surface: ...
    @overload
    @staticmethod
    def CreatePeriodicSurface(surface: Surface, direction: int, bSmooth: bool) -> Surface: ...
    @overload
    @staticmethod
    def CreateRollingBallFillet(surfaceA: Surface, surfaceB: Surface, radius: float, tolerance: float) -> System.Array[Surface]: ...
    @overload
    @staticmethod
    def CreateRollingBallFillet(surfaceA: Surface, flipA: bool, surfaceB: Surface, flipB: bool, radius: float, tolerance: float) -> System.Array[Surface]: ...
    @overload
    @staticmethod
    def CreateRollingBallFillet(surfaceA: Surface, uvA: Point2d, surfaceB: Surface, uvB: Point2d, radius: float, tolerance: float) -> System.Array[Surface]: ...
    @overload
    @staticmethod
    def CreateSoftEditSurface(surface: Surface, uv: Point2d, delta: Vector3d, uLength: float, vLength: float, tolerance: float, fixEnds: bool) -> Surface: ...
    @overload
    @staticmethod
    def CreateTweenSurfacesWithSampling(surface0: Surface, surface1: Surface, numSurfaces: int, numSamples: int, tolerance: float) -> System.Array[Surface]: ...
    @overload
    def CurvatureAt(self, u: float, v: float) -> SurfaceCurvature: ...
    @overload
    def Degree(self, direction: int) -> int: ...
    @overload
    def Domain(self, direction: int) -> Interval: ...
    @overload
    def Evaluate(self, u: float, v: float, numberDerivatives: int) -> (bool, Point3d, System.Array[Vector3d]): ...
    @overload
    def Extend(self, direction: int, interval: Interval) -> bool: ...
    @overload
    def Extend(self, edge: IsoStatus, extensionLength: float, smooth: bool) -> Surface: ...
    @overload
    def Fit(self, uDegree: int, vDegree: int, fitTolerance: float) -> Surface: ...
    @overload
    def FitCurveToSurface(self, trimCurve3d: Curve, trimProjectionDir: Vector3d, tolerance: float, Knots: Generic.IEnumerable, divideIntoSections: bool) -> (System.Array[Curve], Curve, Curve): ...
    @overload
    def FrameAt(self, u: float, v: float) -> (bool, Plane): ...
    @property
    def IsSolid(self) -> bool: ...
    @property
    def IsSubDFriendly(self) -> bool: ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float) -> (bool, float): ...
    @overload
    def GetNextDiscontinuity(self, direction: int, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> (bool, float): ...
    @overload
    def GetNurbsFormParameterFromSurfaceParameter(self, surfaceS: float, surfaceT: float) -> (bool, float, float): ...
    @overload
    def GetSpanVector(self, direction: int) -> System.System.Array[float]: ...
    @overload
    def GetSurfaceParameterFromNurbsFormParameter(self, nurbsS: float, nurbsT: float) -> (bool, float, float): ...
    @overload
    def GetSurfaceSize() -> (bool, float, float): ...
    @overload
    def HasNurbsForm() -> int: ...
    @overload
    def InterpolatedCurveOnSurface(self, points: Generic.IEnumerable, tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Generic.IEnumerable, tolerance: float) -> NurbsCurve: ...
    @overload
    def InterpolatedCurveOnSurfaceUV(self, points: Generic.IEnumerable, tolerance: float, closed: bool, closedSurfaceHandling: int) -> NurbsCurve: ...
    @overload
    def IsAtSeam(self, u: float, v: float) -> int: ...
    @overload
    def IsAtSingularity(self, u: float, v: float, exact: bool) -> bool: ...
    @overload
    def IsClosed(self, direction: int) -> bool: ...
    @overload
    def IsCone() -> bool: ...
    @overload
    def IsCone(self, tolerance: float) -> bool: ...
    @overload
    def IsContinuous(self, continuityType: Continuity, u: float, v: float) -> bool: ...
    @overload
    def IsCylinder() -> bool: ...
    @overload
    def IsCylinder(self, tolerance: float) -> bool: ...
    @overload
    def IsIsoparametric(self, bbox: BoundingBox) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, curve: Curve) -> IsoStatus: ...
    @overload
    def IsIsoparametric(self, curve: Curve, curveDomain: Interval) -> IsoStatus: ...
    @overload
    def IsoCurve(self, direction: int, constantParameter: float) -> Curve: ...
    @overload
    def IsPeriodic(self, direction: int) -> bool: ...
    @overload
    def IsPlanar() -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    @overload
    def IsSingular(self, side: int) -> bool: ...
    @overload
    def IsSphere() -> bool: ...
    @overload
    def IsSphere(self, tolerance: float) -> bool: ...
    @overload
    def IsTorus() -> bool: ...
    @overload
    def IsTorus(self, tolerance: float) -> bool: ...
    @overload
    def LocalClosestPoint(self, testPoint: Point3d, seedU: float, seedV: float) -> (bool, float, float): ...
    @overload
    def NormalAt(self, u: float, v: float) -> Vector3d: ...
    @overload
    def Offset(self, distance: float, tolerance: float) -> Surface: ...
    @overload
    def PointAt(self, u: float, v: float) -> Point3d: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pullback(self, curve3d: Curve, tolerance: float, curve3dSubdomain: Interval) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float) -> Curve: ...
    @overload
    def Pushup(self, curve2d: Curve, tolerance: float, curve2dSubdomain: Interval) -> Curve: ...
    @overload
    def Rebuild(self, uDegree: int, vDegree: int, uPointCount: int, vPointCount: int) -> NurbsSurface: ...
    @overload
    def RebuildOneDirection(self, direction: int, pointCount: int, loftType: LoftType, refitTolerance: float) -> NurbsSurface: ...
    @overload
    def RefitSimplySplitSurface(self, trimCurve3d: Curve, trimProjectionDir: Vector3d, tolerance: float, knotAdditionMode: RefitTrimKnotMode, numInsertKnots: int, Knots: Generic.IEnumerable, sectionMode: RefitTrimSectionMode, numNonTrimSpans: int, meetCurve: bool, oneSided: bool, PtActive: Point3d, outputSurface: bool, outputCurve: bool, lowerSurface: Generic.List, upperSurface: Generic.List, edgeCurve: Generic.List) -> (bool, int, float, Curve, Curve): ...
    @overload
    def RefitSplit(self, curve: Curve, trimProjectionDir: Vector3d, tolerance: float, Knots: Generic.IEnumerable, bMeetCurve: bool, divideIntoSections: bool, srfLower: Generic.List, srfUpper: Generic.List, edgeCurve: Generic.List) -> (int, Curve, Curve): ...
    @overload
    def Reverse(self, direction: int) -> Surface: ...
    @overload
    def Reverse(self, direction: int, inPlace: bool) -> Surface: ...
    @overload
    def SetDomain(self, direction: int, domain: Interval) -> bool: ...
    @overload
    def ShortPath(self, start: Point2d, end: Point2d, tolerance: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Surface: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Surface: ...
    @overload
    def SpanCount(self, direction: int) -> int: ...
    @overload
    def Split(self, direction: int, parameter: float) -> System.Array[Surface]: ...
    @overload
    def ToBrep() -> Brep: ...
    @overload
    def ToNurbsSurface() -> NurbsSurface: ...
    @overload
    def ToNurbsSurface(self, tolerance: float) -> (NurbsSurface, int): ...
    @overload
    def Transpose() -> Surface: ...
    @overload
    def Transpose(self, inPlace: bool) -> Surface: ...
    @overload
    def Trim(self, u: Interval, v: Interval) -> Surface: ...
    @overload
    def TryGetCone() -> (bool, Cone): ...
    @overload
    def TryGetCone(self, tolerance: float) -> (bool, Cone): ...
    @overload
    def TryGetCylinder() -> (bool, Cylinder): ...
    @overload
    def TryGetCylinder(self, tolerance: float) -> (bool, Cylinder): ...
    @overload
    def TryGetFiniteCylinder(self, tolerance: float) -> (bool, Cylinder): ...
    @overload
    def TryGetPlane() -> (bool, Plane): ...
    @overload
    def TryGetPlane(self, tolerance: float) -> (bool, Plane): ...
    @overload
    def TryGetSphere() -> (bool, Sphere): ...
    @overload
    def TryGetSphere(self, tolerance: float) -> (bool, Sphere): ...
    @overload
    def TryGetTorus() -> (bool, Torus): ...
    @overload
    def TryGetTorus(self, tolerance: float) -> (bool, Torus): ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, tolerance: float) -> Surface: ...
    @overload
    def VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, interiorParameters: Generic.IEnumerable, interiorDistances: Generic.IEnumerable, tolerance: float) -> Surface: ...

class SurfaceProxy(Surface):
    """Provides a base class to brep faces and other surface proxies.

    """

class TextRunType(enum.Enum):
    None_ = 0
    Text = 1
    Newline = 2
    Paragraph = 3
    Column = 4
    Field = 5
    Fontdef = 6
    Header = 7

class TextEntity(AnnotationBase):
    """    """
    def __init__(self): ...
    @overload
    @staticmethod
    def Create(text: str, plane: Plane, style: DocObjects.DimensionStyle, wrapped: bool, rectWidth: float, rotationRadians: float) -> TextEntity: ...
    @overload
    def CreateCurves(self, dimstyle: DocObjects.DimensionStyle, allowOpen: bool, smallCapsScale: float, spacing: float) -> System.Array[Curve]: ...
    @overload
    def CreateCurvesGrouped(self, dimstyle: DocObjects.DimensionStyle, allowOpen: bool, smallCapsScale: float, spacing: float) -> Generic.List: ...
    @overload
    def CreateExtrusions(self, dimstyle: DocObjects.DimensionStyle, height: float, smallCapsScale: float, spacing: float) -> System.Array[Extrusion]: ...
    @overload
    def CreateExtrusionsGrouped(self, dimstyle: DocObjects.DimensionStyle, smallCapsScale: float, height: float, spacing: float) -> Generic.List: ...
    @overload
    def CreatePolySurfaces(self, dimstyle: DocObjects.DimensionStyle, height: float, smallCapsScale: float, spacing: float) -> System.Array[Brep]: ...
    @overload
    def CreatePolysurfacesGrouped(self, dimstyle: DocObjects.DimensionStyle, smallCapsScale: float, height: float, spacing: float) -> Generic.List: ...
    @overload
    def CreateSurfaces(self, dimstyle: DocObjects.DimensionStyle, smallCapsScale: float, spacing: float) -> System.Array[Brep]: ...
    @overload
    def CreateSurfacesGrouped(self, dimstyle: DocObjects.DimensionStyle, smallCapsScale: float, spacing: float) -> Generic.List: ...
    @overload
    @staticmethod
    def CreateWithRichText(richTextString: str, plane: Plane, style: DocObjects.DimensionStyle, wrapped: bool, rectWidth: float, rotationRadians: float) -> TextEntity: ...
    @overload
    def Explode() -> System.Array[Curve]: ...
    @property
    def Justification(self) -> TextJustification: ...
    @property
    def TextHorizontalAlignment(self) -> DocObjects.TextHorizontalAlignment: ...
    @property
    def TextOrientation(self) -> DocObjects.TextOrientation: ...
    @property
    def TextVerticalAlignment(self) -> DocObjects.TextVerticalAlignment: ...
    @overload
    def GetTextTransform(self, textscale: float, dimstyle: DocObjects.DimensionStyle) -> Transform: ...
    @Justification.setter
    def Justification(self, value: System.Void): ...
    @TextHorizontalAlignment.setter
    def TextHorizontalAlignment(self, value: System.Void): ...
    @TextOrientation.setter
    def TextOrientation(self, value: System.Void): ...
    @TextVerticalAlignment.setter
    def TextVerticalAlignment(self, value: System.Void): ...
    @overload
    def Transform(self, transform: Transform, style: DocObjects.DimensionStyle) -> bool: ...

class DistancingMode(enum.Enum):
    Undefined = 0
    Linear = 1
    LinearFromEnd = 2
    Ratio = 3
    RatioFromEnd = 4

class MeshExtruder(object):
    """Extrudes a mesh and provides preview

    """
    def __init__(self, inputMesh: Mesh, componentIndices: Generic.IEnumerable): ...
    @overload
    def Dispose() -> None: ...
    @overload
    def ExtrudedMesh() -> (bool, Mesh): ...
    @overload
    def ExtrudedMesh() -> (bool, Mesh, Generic.List): ...
    @property
    def EdgeBasedUVN(self) -> bool: ...
    @property
    def FaceDirectionMode(self) -> MeshExtruderFaceDirectionMode: ...
    @property
    def KeepOriginalFaces(self) -> bool: ...
    @property
    def PreviewLines(self) -> System.Array[Line]: ...
    @property
    def SurfaceParameterMode(self) -> MeshExtruderParameterMode: ...
    @property
    def TextureCoordinateMode(self) -> MeshExtruderParameterMode: ...
    @property
    def Transform(self) -> Transform: ...
    @property
    def UVN(self) -> bool: ...
    @overload
    def GetWallFaces() -> Generic.List: ...
    @EdgeBasedUVN.setter
    def EdgeBasedUVN(self, value: System.Void): ...
    @FaceDirectionMode.setter
    def FaceDirectionMode(self, value: System.Void): ...
    @KeepOriginalFaces.setter
    def KeepOriginalFaces(self, value: System.Void): ...
    @SurfaceParameterMode.setter
    def SurfaceParameterMode(self, value: System.Void): ...
    @TextureCoordinateMode.setter
    def TextureCoordinateMode(self, value: System.Void): ...
    @Transform.setter
    def Transform(self, value: System.Void): ...
    @UVN.setter
    def UVN(self, value: System.Void): ...

class MeshUnwrapper(object):
    """Unwraps meshes and stores the result in their texture coordinates

    """
    @overload
    def __init__(self, mesh: Mesh): ...
    @overload
    def __init__(self, meshes: Generic.IEnumerable): ...
    @overload
    def Dispose() -> None: ...
    @SymmetryPlane.setter
    def SymmetryPlane(self, value: System.Void): ...
    @overload
    def Unwrap(self, method: MeshUnwrapMethod) -> bool: ...

class Interpolator(Collections.RhinoList):
    """Exposes a set of standard numeric interpolation algorithms.

    """
    @overload
    def __init__(self): ...
    @overload
    def __init__(self, initialCapacity: int): ...
    @overload
    def __init__(self, list_: Collections.RhinoList): ...
    @overload
    def __init__(self, collection: Generic.IEnumerable): ...
    @overload
    def __init__(self, amount: int, defaultValue: float): ...
    @property
    def Cyclical(self) -> bool: ...
    @overload
    def InterpolateCatmullRom(self, t: float) -> float: ...
    @overload
    def InterpolateCosine(self, t: float) -> float: ...
    @overload
    def InterpolateCubic(self, t: float) -> float: ...
    @overload
    def InterpolateLinear(self, t: float) -> float: ...
    @overload
    def InterpolateNearestNeighbour(self, t: float) -> float: ...
    @Cyclical.setter
    def Cyclical(self, value: System.Void): ...

class Particle(object):
    """Represents a simple particle.
This base class only defines position and display properties (size, color, bitmap id). You will most likely create a class that derives from this particle class to perform some sort of physical simulation (movement over time or frames).

    """
    def __init__(self): ...
    @property
    def Color(self) -> Drawing.Color: ...
    @property
    def DisplayBitmapIndex(self) -> int: ...
    @property
    def Index(self) -> int: ...
    @property
    def Location(self) -> Point3d: ...
    @property
    def ParentSystem(self) -> ParticleSystem: ...
    @property
    def Size(self) -> System.Single: ...
    @Color.setter
    def Color(self, value: System.Void): ...
    @DisplayBitmapIndex.setter
    def DisplayBitmapIndex(self, value: System.Void): ...
    @Location.setter
    def Location(self, value: System.Void): ...
    @Size.setter
    def Size(self, value: System.Void): ...
    @overload
    def Update() -> None: ...

class ParticleSystem(object):
    """    """
    def __init__(self): ...
    @overload
    def Add(self, particle: Particle) -> bool: ...
    @overload
    def Clear() -> None: ...
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @property
    def DisplaySizesInWorldUnits(self) -> bool: ...
    @property
    def DrawRequiresDepthSorting(self) -> bool: ...
    @overload
    def GetEnumerator() -> Generic.IEnumerator: ...
    @overload
    def Remove(self, particle: Particle) -> None: ...
    @DisplaySizesInWorldUnits.setter
    def DisplaySizesInWorldUnits(self, value: System.Void): ...
    @DrawRequiresDepthSorting.setter
    def DrawRequiresDepthSorting(self, value: System.Void): ...
    @overload
    def Update() -> None: ...

class Arc(System.ValueType):
    """Represents the value of a plane, two angles and a radius in a sub-curve of a three-dimensional circle.
The curve is parameterized by an angle expressed in radians. For an IsValid arc the total subtended angle AngleRadians() = Domain()(1) - Domain()(0) must satisfy 0 < AngleRadians() < 2*Pi
The parameterization of the Arc is inherited from the Circle it is derived from. In particular
t -> center + cos(t)*radius*xaxis + sin(t)*radius*yaxis
where xaxis and yaxis, (part of Circle.Plane) form an orthonormal frame of the plane containing the circle.

    """
    @overload
    def __init__(self, circle: Circle, angleRadians: float): ...
    @overload
    def __init__(self, circle: Circle, angleIntervalRadians: Interval): ...
    @overload
    def __init__(self, plane: Plane, radius: float, angleRadians: float): ...
    @overload
    def __init__(self, center: Point3d, radius: float, angleRadians: float): ...
    @overload
    def __init__(self, startPoint: Point3d, pointOnInterior: Point3d, endPoint: Point3d): ...
    @overload
    def __init__(self, pointA: Point3d, tangentA: Vector3d, pointB: Point3d): ...
    @overload
    def __init__(self, plane: Plane, center: Point3d, radius: float, angleRadians: float): ...
    @overload
    def BoundingBox() -> BoundingBox: ...
    @overload
    def ClosestParameter(self, testPoint: Point3d) -> float: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...
    @overload
    def EpsilonEquals(self, other: Arc, epsilon: float) -> bool: ...
    @overload
    def Equals(self, other: Arc) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def Angle(self) -> float: ...
    @property
    def AngleDegrees(self) -> float: ...
    @property
    def AngleDomain(self) -> Interval: ...
    @property
    def Center(self) -> Point3d: ...
    @property
    def Circumference(self) -> float: ...
    @property
    def Diameter(self) -> float: ...
    @property
    def EndAngle(self) -> float: ...
    @property
    def EndAngleDegrees(self) -> float: ...
    @property
    def EndPoint(self) -> Point3d: ...
    @property
    def IsCircle(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Length(self) -> float: ...
    @property
    def MidPoint(self) -> Point3d: ...
    @property
    def Plane(self) -> Plane: ...
    @property
    def Radius(self) -> float: ...
    @property
    def StartAngle(self) -> float: ...
    @property
    def StartAngleDegrees(self) -> float: ...
    @property
    def StartPoint(self) -> Point3d: ...
    @property
    def Unset(self) -> Arc: ...
    @overload
    def GetHashCode() -> int: ...
    @overload
    def PointAt(self, t: float) -> Point3d: ...
    @overload
    def Reverse() -> None: ...
    @Angle.setter
    def Angle(self, value: System.Void): ...
    @AngleDegrees.setter
    def AngleDegrees(self, value: System.Void): ...
    @AngleDomain.setter
    def AngleDomain(self, value: System.Void): ...
    @Center.setter
    def Center(self, value: System.Void): ...
    @Diameter.setter
    def Diameter(self, value: System.Void): ...
    @EndAngle.setter
    def EndAngle(self, value: System.Void): ...
    @EndAngleDegrees.setter
    def EndAngleDegrees(self, value: System.Void): ...
    @Plane.setter
    def Plane(self, value: System.Void): ...
    @Radius.setter
    def Radius(self, value: System.Void): ...
    @StartAngle.setter
    def StartAngle(self, value: System.Void): ...
    @StartAngleDegrees.setter
    def StartAngleDegrees(self, value: System.Void): ...
    @overload
    def TangentAt(self, t: float) -> Vector3d: ...
    @overload
    def ToNurbsCurve() -> NurbsCurve: ...
    @overload
    def ToNurbsCurve(self, degree: int, cvCount: int) -> NurbsCurve: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Trim(self, domain: Interval) -> bool: ...

class BoundingBox(System.ValueType):
    """Represents the value of two points in a bounding box defined by the two extreme corner points.
This box is therefore aligned to the world X, Y and Z axes.

    """
    @overload
    def __init__(self, points: Generic.IEnumerable): ...
    @overload
    def __init__(self, min_: Point3d, max_: Point3d): ...
    @overload
    def __init__(self, points: Generic.IEnumerable, xform: Transform): ...
    @overload
    def __init__(self, minX: float, minY: float, minZ: float, maxX: float, maxY: float, maxZ: float): ...
    @overload
    def ClosestPoint(self, point: Point3d) -> Point3d: ...
    @overload
    def ClosestPoint(self, point: Point3d, includeInterior: bool) -> Point3d: ...
    @overload
    def Contains(self, point: Point3d) -> bool: ...
    @overload
    def Contains(self, box: BoundingBox) -> bool: ...
    @overload
    def Contains(self, box: BoundingBox, strict: bool) -> bool: ...
    @overload
    def Contains(self, point: Point3d, strict: bool) -> bool: ...
    @overload
    def Corner(self, minX: bool, minY: bool, minZ: bool) -> Point3d: ...
    @overload
    def FurthestPoint(self, point: Point3d) -> Point3d: ...
    @property
    def Area(self) -> float: ...
    @property
    def Center(self) -> Point3d: ...
    @property
    def Diagonal(self) -> Vector3d: ...
    @property
    def Empty(self) -> BoundingBox: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Max(self) -> Point3d: ...
    @property
    def Min(self) -> Point3d: ...
    @property
    def Unset(self) -> BoundingBox: ...
    @property
    def Volume(self) -> float: ...
    @overload
    def GetCorners() -> System.Array[Point3d]: ...
    @overload
    def GetEdges() -> System.Array[Line]: ...
    @overload
    def Inflate(self, amount: float) -> None: ...
    @overload
    def Inflate(self, xAmount: float, yAmount: float, zAmount: float) -> None: ...
    @overload
    @staticmethod
    def Intersection(a: BoundingBox, b: BoundingBox) -> BoundingBox: ...
    @overload
    def IsDegenerate(self, tolerance: float) -> int: ...
    @overload
    def MakeValid() -> bool: ...
    @overload
    def PointAt(self, tx: float, ty: float, tz: float) -> Point3d: ...
    @Max.setter
    def Max(self, value: System.Void): ...
    @Min.setter
    def Min(self, value: System.Void): ...
    @overload
    def ToBrep() -> Brep: ...
    @overload
    def ToString() -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Union(self, other: BoundingBox) -> None: ...
    @overload
    def Union(self, point: Point3d) -> None: ...
    @overload
    @staticmethod
    def Union(a: BoundingBox, b: BoundingBox) -> BoundingBox: ...
    @overload
    @staticmethod
    def Union(box: BoundingBox, point: Point3d) -> BoundingBox: ...

class Circle(System.ValueType):
    """Represents a circle in 3D.
The values used are a radius and an orthonormal frame of the plane containing the circle, with origin at the center.
The circle is parameterized by radians from 0 to 2 Pi given by
t -> center + cos(t)*radius*xaxis + sin(t)*radius*yaxis
where center, xaxis and yaxis define the orthonormal frame of the circle plane.

    """
    @overload
    def __init__(self, radius: float): ...
    @overload
    def __init__(self, arc: Arc): ...
    @overload
    def __init__(self, plane: Plane, radius: float): ...
    @overload
    def __init__(self, center: Point3d, radius: float): ...
    @overload
    def __init__(self, point1: Point3d, point2: Point3d, point3: Point3d): ...
    @overload
    def __init__(self, plane: Plane, center: Point3d, radius: float): ...
    @overload
    def __init__(self, startPoint: Point3d, tangentAtP: Vector3d, pointOnCircle: Point3d): ...
    @overload
    def ClosestParameter(self, testPoint: Point3d) -> (bool, float): ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...
    @overload
    def DerivativeAt(self, derivative: int, t: float) -> Vector3d: ...
    @overload
    def EpsilonEquals(self, other: Circle, epsilon: float) -> bool: ...
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @property
    def Center(self) -> Point3d: ...
    @property
    def Circumference(self) -> float: ...
    @property
    def Diameter(self) -> float: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Normal(self) -> Vector3d: ...
    @property
    def Plane(self) -> Plane: ...
    @property
    def Radius(self) -> float: ...
    @property
    def Unset(self) -> Circle: ...
    @overload
    def IsInPlane(self, plane: Plane, tolerance: float) -> bool: ...
    @overload
    def PointAt(self, t: float) -> Point3d: ...
    @overload
    def Reverse() -> None: ...
    @overload
    def Rotate(self, angle: float, axis: Vector3d) -> bool: ...
    @overload
    def Rotate(self, angle: float, axis: Vector3d, point: Point3d) -> bool: ...
    @overload
    def Rotate(self, sinAngle: float, cosAngle: float, axis: Vector3d) -> bool: ...
    @overload
    def Rotate(self, sinAngle: float, cosAngle: float, axis: Vector3d, point: Point3d) -> bool: ...
    @Center.setter
    def Center(self, value: System.Void): ...
    @Circumference.setter
    def Circumference(self, value: System.Void): ...
    @Diameter.setter
    def Diameter(self, value: System.Void): ...
    @Plane.setter
    def Plane(self, value: System.Void): ...
    @Radius.setter
    def Radius(self, value: System.Void): ...
    @overload
    def TangentAt(self, t: float) -> Vector3d: ...
    @overload
    def ToNurbsCurve() -> NurbsCurve: ...
    @overload
    def ToNurbsCurve(self, degree: int, cvCount: int) -> NurbsCurve: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, delta: Vector3d) -> bool: ...
    @overload
    @staticmethod
    def TryFitCircleToPoints(points: Generic.IEnumerable) -> (bool, Circle): ...
    @overload
    @staticmethod
    def TryFitCircleTT(c1: Curve, c2: Curve, t1: float, t2: float) -> Circle: ...
    @overload
    @staticmethod
    def TryFitCircleTTT(c1: Curve, c2: Curve, c3: Curve, t1: float, t2: float, t3: float) -> Circle: ...
    @overload
    @staticmethod
    def TrySmallestEnclosingCircle(points: Generic.IEnumerable, tolerance: float) -> (bool, Circle, System.System.Array[int]): ...

class Cone(System.ValueType):
    """Represents the center plane, radius and height values in a right circular cone.

    """
    def __init__(self, plane: Plane, height: float, radius: float): ...
    @overload
    def AngleInDegrees() -> float: ...
    @overload
    def AngleInRadians() -> float: ...
    @overload
    def EpsilonEquals(self, other: Cone, epsilon: float) -> bool: ...
    @property
    def ApexPoint(self) -> Point3d: ...
    @property
    def Axis(self) -> Vector3d: ...
    @property
    def BasePoint(self) -> Point3d: ...
    @property
    def Height(self) -> float: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Plane(self) -> Plane: ...
    @property
    def Radius(self) -> float: ...
    @property
    def Unset(self) -> Cone: ...
    @Height.setter
    def Height(self, value: System.Void): ...
    @Plane.setter
    def Plane(self, value: System.Void): ...
    @Radius.setter
    def Radius(self, value: System.Void): ...
    @overload
    def ToBrep(self, capBottom: bool) -> Brep: ...
    @overload
    def ToNurbsSurface() -> NurbsSurface: ...
    @overload
    def ToRevSurface() -> RevSurface: ...

class BlendContinuity(enum.Enum):
    Position = 0
    Tangency = 1
    Curvature = 2

class PreserveEnd(enum.Enum):
    None_ = 0
    Position = 1
    Tangency = 2
    Curvature = 3

class CurveOffsetCornerStyle(enum.Enum):
    None_ = 0
    Sharp = 1
    Round = 2
    Smooth = 3
    Chamfer = 4

class CurveOffsetEndStyle(enum.Enum):
    None_ = 0
    Flat = 1
    Round = 2

class CurveKnotStyle(enum.Enum):
    Uniform = 0
    Chord = 1
    ChordSquareRoot = 2
    UniformPeriodic = 3
    ChordPeriodic = 4
    ChordSquareRootPeriodic = 5

class CurveOrientation(enum.Enum):
    Undefined = 0
    CounterClockwise = 1
    Clockwise = -1

class PointContainment(enum.Enum):
    Unset = 0
    Inside = 1
    Outside = 2
    Coincident = 3

class RegionContainment(enum.Enum):
    Disjoint = 0
    MutualIntersection = 1
    AInsideB = 2
    BInsideA = 3

class CurveExtensionStyle(enum.Enum):
    Line = 0
    Arc = 1
    Smooth = 2

class CurveSimplifyOptions(enum.Enum):
    None_ = 0
    SplitAtFullyMultipleKnots = 1
    RebuildLines = 2
    RebuildArcs = 4
    RebuildRationals = 8
    AdjustG1 = 16
    Merge = 32
    All = 63

class CurveEnd(enum.Enum):
    None_ = 0
    Start = 1
    End = 2
    Both = 3

class CurveEvaluationSide(enum.Enum):
    Default = 0
    Above = 1
    Below = -1

class ConicSectionType(enum.Enum):
    Unknown = 0
    Circle = 1
    Ellipse = 2
    Hyperbola = 3
    Parabola = 4

class CurveBooleanRegions(object):
    """Represents the results of a Curve.CreateBooleanRegions calculation.

    """
    @overload
    def BoundaryCount(self, regionIndex: int) -> int: ...
    @overload
    def Dispose() -> None: ...
    @property
    def PlanarCurveCount(self) -> int: ...
    @property
    def PointCount(self) -> int: ...
    @property
    def RegionCount(self) -> int: ...
    @overload
    def PlanarCurve(self, planarCurveIndex: int) -> Curve: ...
    @overload
    def RegionCurves(self, regionIndex: int) -> System.Array[Curve]: ...
    @overload
    def RegionPointIndex(self, pointIndex: int) -> int: ...
    @overload
    def SegmentCount(self, regionIndex: int, boundaryIndex: int) -> int: ...
    @overload
    def SegmentDetails(self, regionIndex: int, boundaryIndex: int, segmmentIndex: int) -> (int, Interval, bool): ...

class Curve(GeometryBase):
    """Represents a base class that is common to most RhinoCommon curve types.
A curve represents an entity that can be all visited by providing a single parameter, usually called t.

    """
    @overload
    def ChangeClosedCurveSeam(self, t: float) -> bool: ...
    @overload
    def ChangeDimension(self, desiredDimension: int) -> bool: ...
    @overload
    def ClosedCurveOrientation() -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, upDirection: Vector3d) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, xform: Transform) -> CurveOrientation: ...
    @overload
    def ClosedCurveOrientation(self, plane: Plane) -> CurveOrientation: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> (bool, float): ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, maximumDistance: float) -> (bool, float): ...
    @overload
    def ClosestPoints(self, otherCurve: Curve) -> (bool, Point3d, Point3d): ...
    @overload
    def ClosestPoints(self, geometry: Generic.IEnumerable) -> (bool, Point3d, Point3d, int): ...
    @overload
    def ClosestPoints(self, geometry: Generic.IEnumerable, maximumDistance: float) -> (bool, Point3d, Point3d, int): ...
    @overload
    def CombineShortSegments(self, tolerance: float) -> bool: ...
    @overload
    def Contains(self, testPoint: Point3d, plane: Plane, tolerance: float) -> PointContainment: ...
    @overload
    def ControlPolygon() -> Polyline: ...
    @overload
    @staticmethod
    def CreateArcBlend(startPt: Point3d, startDir: Vector3d, endPt: Point3d, endDir: Vector3d, controlPointLengthRatio: float) -> Curve: ...
    @overload
    @staticmethod
    def CreateArcCornerRectangle(rectangle: Rectangle3d, radius: float) -> Curve: ...
    @overload
    @staticmethod
    def CreateArcLineArcBlend(startPt: Point3d, startDir: Vector3d, endPt: Point3d, endDir: Vector3d, radius: float) -> Curve: ...
    @overload
    @staticmethod
    def CreateBlendCurve(curveA: Curve, curveB: Curve, continuity: BlendContinuity) -> Curve: ...
    @overload
    @staticmethod
    def CreateBlendCurve(curveA: Curve, curveB: Curve, continuity: BlendContinuity, bulgeA: float, bulgeB: float) -> Curve: ...
    @overload
    @staticmethod
    def CreateBlendCurve(curve0: Curve, t0: float, reverse0: bool, continuity0: BlendContinuity, curve1: Curve, t1: float, reverse1: bool, continuity1: BlendContinuity) -> Curve: ...
    @overload
    @staticmethod
    def CreateBooleanDifference(curveA: Curve, curveB: Curve, tolerance: float) -> System.Array[Curve]: ...
    @overload
    @staticmethod
    def CreateBooleanDifference(curveA: Curve, subtractors: Generic.IEnumerable, tolerance: float) -> System.Array[Curve]: ...
    @overload
    @staticmethod
    def CreateBooleanIntersection(curveA: Curve, curveB: Curve, tolerance: float) -> System.Array[Curve]: ...
    @overload
    @staticmethod
    def CreateBooleanRegions(curves: Generic.IEnumerable, plane: Plane, combineRegions: bool, tolerance: float) -> CurveBooleanRegions: ...
    @overload
    @staticmethod
    def CreateBooleanRegions(curves: Generic.IEnumerable, plane: Plane, points: Generic.IEnumerable, combineRegions: bool, tolerance: float) -> CurveBooleanRegions: ...
    @overload
    @staticmethod
    def CreateBooleanUnion(curves: Generic.IEnumerable, tolerance: float) -> System.Array[Curve]: ...
    @overload
    @staticmethod
    def CreateConicCornerRectangle(rectangle: Rectangle3d, rho: float) -> Curve: ...
    @overload
    @staticmethod
    def CreateControlPointCurve(points: Generic.IEnumerable) -> Curve: ...
    @overload
    @staticmethod
    def CreateControlPointCurve(points: Generic.IEnumerable, degree: int) -> Curve: ...
    @overload
    @staticmethod
    def CreateCurve2View(curveA: Curve, curveB: Curve, vectorA: Vector3d, vectorB: Vector3d, tolerance: float, angleTolerance: float) -> System.Array[Curve]: ...
    @overload
    @staticmethod
    def CreateFillet(curve0: Curve, curve1: Curve, radius: float, t0Base: float, t1Base: float) -> Arc: ...
    @overload
    @staticmethod
    def CreateFilletCornersCurve(curve: Curve, radius: float, tolerance: float, angleTolerance: float) -> Curve: ...
    @overload
    @staticmethod
    def CreateFilletCurves(curve0: Curve, point0: Point3d, curve1: Curve, point1: Point3d, radius: float, join: bool, trim: bool, arcExtension: bool, tolerance: float, angleTolerance: float) -> System.Array[Curve]: ...
    @overload
    @staticmethod
    def CreateInterpolatedCurve(points: Generic.IEnumerable, degree: int) -> Curve: ...
    @overload
    @staticmethod
    def CreateInterpolatedCurve(points: Generic.IEnumerable, degree: int, knots: CurveKnotStyle) -> Curve: ...
    @overload
    @staticmethod
    def CreateInterpolatedCurve(points: Generic.IEnumerable, degree: int, knots: CurveKnotStyle, startTangent: Vector3d, endTangent: Vector3d) -> Curve: ...
    @overload
    @staticmethod
    def CreateMatchCurve(curve0: Curve, reverse0: bool, continuity: BlendContinuity, curve1: Curve, reverse1: bool, preserve: PreserveEnd, average: bool) -> System.Array[Curve]: ...
    @overload
    @staticmethod
    def CreateMeanCurve(curveA: Curve, curveB: Curve) -> Curve: ...
    @overload
    @staticmethod
    def CreateMeanCurve(curveA: Curve, curveB: Curve, angleToleranceRadians: float) -> Curve: ...
    @overload
    @staticmethod
    def CreatePeriodicCurve(curve: Curve) -> Curve: ...
    @overload
    @staticmethod
    def CreatePeriodicCurve(curve: Curve, smooth: bool) -> Curve: ...
    @overload
    @staticmethod
    def CreateRevisionCloud(points: Generic.IEnumerable, angle: float, flip: bool) -> Curve: ...
    @overload
    @staticmethod
    def CreateRevisionCloud(curve: Curve, segmentCount: int, angle: float, flip: bool) -> Curve: ...
    @overload
    @staticmethod
    def CreateSoftEditCurve(curve: Curve, t: float, delta: Vector3d, length: float, fixEnds: bool) -> Curve: ...
    @overload
    @staticmethod
    def CreateTextOutlines(text: str, font: str, textHeight: float, textStyle: int, closeLoops: bool, plane: Plane, smallCapsScale: float, tolerance: float) -> System.Array[Curve]: ...
    @overload
    @staticmethod
    def CreateTweenCurves(curve0: Curve, curve1: Curve, numCurves: int, tolerance: float) -> System.Array[Curve]: ...
    @overload
    @staticmethod
    def CreateTweenCurvesWithMatching(curve0: Curve, curve1: Curve, numCurves: int, tolerance: float) -> System.Array[Curve]: ...
    @overload
    @staticmethod
    def CreateTweenCurvesWithSampling(curve0: Curve, curve1: Curve, numCurves: int, numSamples: int, tolerance: float) -> System.Array[Curve]: ...
    @overload
    def CurvatureAt(self, t: float) -> Vector3d: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int) -> System.Array[Vector3d]: ...
    @overload
    def DerivativeAt(self, t: float, derivativeCount: int, side: CurveEvaluationSide) -> System.Array[Vector3d]: ...
    @overload
    def DivideAsContour(self, contourStart: Point3d, contourEnd: Point3d, interval: float) -> System.Array[Point3d]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> System.System.Array[float]: ...
    @overload
    def DivideByCount(self, segmentCount: int, includeEnds: bool) -> (System.System.Array[float], System.Array[Point3d]): ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> System.System.Array[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> System.System.Array[float]: ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool) -> (System.System.Array[float], System.Array[Point3d]): ...
    @overload
    def DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> (System.System.Array[float], System.Array[Point3d]): ...
    @overload
    def DivideEquidistant(self, distance: float) -> System.Array[Point3d]: ...
    @overload
    def DivideEquidistant(self, distance: float) -> (System.Array[Point3d], System.System.Array[float]): ...
    @overload
    @staticmethod
    def DoDirectionsMatch(curveA: Curve, curveB: Curve) -> bool: ...
    @overload
    def Duplicate() -> GeometryBase: ...
    @overload
    def DuplicateCurve() -> Curve: ...
    @overload
    def DuplicateSegments() -> System.Array[Curve]: ...
    @overload
    def Extend(self, domain: Interval) -> Curve: ...
    @overload
    def Extend(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, geometry: Generic.IEnumerable) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, length: float, style: CurveExtensionStyle) -> Curve: ...
    @overload
    def Extend(self, side: CurveEnd, style: CurveExtensionStyle, endPoint: Point3d) -> Curve: ...
    @overload
    def ExtendByArc(self, side: CurveEnd, geometry: Generic.IEnumerable) -> Curve: ...
    @overload
    def ExtendByLine(self, side: CurveEnd, geometry: Generic.IEnumerable) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, surface: Surface) -> Curve: ...
    @overload
    def ExtendOnSurface(self, side: CurveEnd, face: BrepFace) -> Curve: ...
    @overload
    def ExtremeParameters(self, direction: Vector3d) -> System.System.Array[float]: ...
    @overload
    def Fair(self, distanceTolerance: float, angleTolerance: float, clampStart: int, clampEnd: int, iterations: int) -> Curve: ...
    @overload
    def FilletSurfaceToCurve(self, face: BrepFace, t: float, u: float, v: float, radius: float, alignToCurve: int, railDegree: int, arcDegree: int, arcSliders: Generic.IEnumerable, numBezierSrfs: int, tolerance: float, out_fillets: Generic.List) -> (bool, System.System.Array[float]): ...
    @overload
    def FilletSurfaceToRail(self, faceWithCurve: BrepFace, secondFace: BrepFace, u1: float, v1: float, railDegree: int, arcDegree: int, arcSliders: Generic.IEnumerable, numBezierSrfs: int, extend: bool, split_type: FilletSurfaceSplitType, tolerance: float, out_fillets: Generic.List, out_breps0: Generic.List, out_breps1: Generic.List) -> (bool, System.System.Array[float]): ...
    @overload
    def FindLocalInflection(self, N: Vector3d, subDomain: Interval, seed: float) -> (bool, float, float): ...
    @overload
    def Fit(self, degree: int, fitTolerance: float, angleTolerance: float) -> Curve: ...
    @overload
    def FrameAt(self, t: float) -> (bool, Plane): ...
    @property
    def Degree(self) -> int: ...
    @property
    def Dimension(self) -> int: ...
    @property
    def Domain(self) -> Interval: ...
    @property
    def IsClosed(self) -> bool: ...
    @property
    def IsPeriodic(self) -> bool: ...
    @property
    def IsSubDFriendly(self) -> bool: ...
    @property
    def PointAtEnd(self) -> Point3d: ...
    @property
    def PointAtMid(self) -> Point3d: ...
    @property
    def PointAtStart(self) -> Point3d: ...
    @property
    def SpanCount(self) -> int: ...
    @property
    def TangentAtEnd(self) -> Vector3d: ...
    @property
    def TangentAtStart(self) -> Vector3d: ...
    @overload
    def GetConicSectionType() -> ConicSectionType: ...
    @overload
    def GetConicSectionType() -> (ConicSectionType, Point3d, Point3d, Point3d): ...
    @overload
    def GetCurveParameterFromNurbsFormParameter(self, nurbsParameter: float) -> (bool, float): ...
    @overload
    @staticmethod
    def GetDistancesBetweenCurves(curveA: Curve, curveB: Curve, tolerance: float) -> (bool, float, float, float, float, float, float): ...
    @overload
    @staticmethod
    def GetFilletPoints(curve0: Curve, curve1: Curve, radius: float, t0Base: float, t1Base: float) -> (bool, float, float, Plane): ...
    @overload
    def GetLength() -> float: ...
    @overload
    def GetLength(self, subdomain: Interval) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float) -> float: ...
    @overload
    def GetLength(self, fractionalTolerance: float, subdomain: Interval) -> float: ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float) -> (bool, float): ...
    @overload
    def GetLocalPerpPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> (bool, float): ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float) -> (bool, float): ...
    @overload
    def GetLocalTangentPoint(self, testPoint: Point3d, seedParmameter: float, subDomain: Interval) -> (bool, float): ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float) -> (bool, float): ...
    @overload
    def GetNextDiscontinuity(self, continuityType: Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float) -> (bool, float): ...
    @overload
    def GetNurbsFormParameterFromCurveParameter(self, curveParameter: float) -> (bool, float): ...
    @overload
    def GetPerpendicularFrames(self, parameters: Generic.IEnumerable) -> System.Array[Plane]: ...
    @overload
    def GetSubCurves() -> System.Array[Curve]: ...
    @overload
    def HasNurbsForm() -> int: ...
    @overload
    def InflectionPoints() -> System.Array[Point3d]: ...
    @overload
    def InflectionPoints() -> (System.Array[Point3d], System.System.Array[float]): ...
    @overload
    def IsArc() -> bool: ...
    @overload
    def IsArc(self, tolerance: float) -> bool: ...
    @overload
    def IsCircle() -> bool: ...
    @overload
    def IsCircle(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float) -> bool: ...
    @overload
    def IsClosable(self, tolerance: float, minimumAbsoluteSize: float, minimumRelativeSize: float) -> bool: ...
    @overload
    def IsContinuous(self, continuityType: Continuity, t: float) -> bool: ...
    @overload
    def IsEllipse() -> bool: ...
    @overload
    def IsEllipse(self, tolerance: float) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane) -> bool: ...
    @overload
    def IsInPlane(self, testPlane: Plane, tolerance: float) -> bool: ...
    @overload
    def IsLinear() -> bool: ...
    @overload
    def IsLinear(self, tolerance: float) -> bool: ...
    @overload
    def IsPlanar() -> bool: ...
    @overload
    def IsPlanar(self, tolerance: float) -> bool: ...
    @overload
    def IsPolyline() -> bool: ...
    @overload
    def IsShort(self, tolerance: float) -> bool: ...
    @overload
    def IsShort(self, tolerance: float, subdomain: Interval) -> bool: ...
    @overload
    @staticmethod
    def JoinCurves(inputCurves: Generic.IEnumerable) -> System.Array[Curve]: ...
    @overload
    @staticmethod
    def JoinCurves(inputCurves: Generic.IEnumerable, joinTolerance: float) -> System.Array[Curve]: ...
    @overload
    @staticmethod
    def JoinCurves(inputCurves: Generic.IEnumerable, joinTolerance: float, preserveDirection: bool) -> System.Array[Curve]: ...
    @overload
    @staticmethod
    def JoinCurves(inputCurves: Generic.IEnumerable, joinTolerance: float, preserveDirection: bool) -> (System.Array[Curve], System.System.Array[int]): ...
    @overload
    @staticmethod
    def JoinCurves(inputCurves: Generic.IEnumerable, joinTolerance: float, preserveDirection: bool, simpleJoin: bool) -> (System.Array[Curve], System.System.Array[int]): ...
    @overload
    def LengthParameter(self, segmentLength: float) -> (bool, float): ...
    @overload
    def LengthParameter(self, segmentLength: float, subdomain: Interval) -> (bool, float): ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float) -> (bool, float): ...
    @overload
    def LengthParameter(self, segmentLength: float, fractionalTolerance: float, subdomain: Interval) -> (bool, float): ...
    @overload
    def LocalClosestPoint(self, testPoint: Point3d, seed: float) -> (bool, float): ...
    @overload
    def MakeClosed(self, tolerance: float) -> bool: ...
    @overload
    @staticmethod
    def MakeEndsMeet(curveA: Curve, adjustStartCurveA: bool, curveB: Curve, adjustStartCurveB: bool) -> bool: ...
    @overload
    def MaxCurvaturePoints() -> System.Array[Point3d]: ...
    @overload
    def MaxCurvaturePoints() -> (System.Array[Point3d], System.System.Array[float]): ...
    @overload
    def NormalizedLengthParameter(self, s: float) -> (bool, float): ...
    @overload
    def NormalizedLengthParameter(self, s: float, subdomain: Interval) -> (bool, float): ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float) -> (bool, float): ...
    @overload
    def NormalizedLengthParameter(self, s: float, fractionalTolerance: float, subdomain: Interval) -> (bool, float): ...
    @overload
    def NormalizedLengthParameters(self, s: System.System.Array[float], absoluteTolerance: float) -> System.System.Array[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: System.System.Array[float], absoluteTolerance: float, subdomain: Interval) -> System.System.Array[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: System.System.Array[float], absoluteTolerance: float, fractionalTolerance: float) -> System.System.Array[float]: ...
    @overload
    def NormalizedLengthParameters(self, s: System.System.Array[float], absoluteTolerance: float, fractionalTolerance: float, subdomain: Interval) -> System.System.Array[float]: ...
    @overload
    def Offset(self, plane: Plane, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> System.Array[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, cornerStyle: CurveOffsetCornerStyle) -> System.Array[Curve]: ...
    @overload
    def Offset(self, directionPoint: Point3d, normal: Vector3d, distance: float, tolerance: float, angleTolerance: float, loose: bool, cornerStyle: CurveOffsetCornerStyle, endStyle: CurveOffsetEndStyle) -> System.Array[Curve]: ...
    @overload
    def OffsetNormalToSurface(self, surface: Surface, height: float) -> Curve: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, distance: float, fittingTolerance: float) -> System.Array[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, throughPoint: Point2d, fittingTolerance: float) -> System.Array[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, distance: float, fittingTolerance: float) -> System.Array[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, throughPoint: Point2d, fittingTolerance: float) -> System.Array[Curve]: ...
    @overload
    def OffsetOnSurface(self, surface: Surface, curveParameters: System.System.Array[float], offsetDistances: System.System.Array[float], fittingTolerance: float) -> System.Array[Curve]: ...
    @overload
    def OffsetOnSurface(self, face: BrepFace, curveParameters: System.System.Array[float], offsetDistances: System.System.Array[float], fittingTolerance: float) -> System.Array[Curve]: ...
    @overload
    def OffsetTangentToSurface(self, surface: Surface, height: float) -> Curve: ...
    @overload
    def PerpendicularFrameAt(self, t: float) -> (bool, Plane): ...
    @overload
    @staticmethod
    def PlanarClosedCurveRelationship(curveA: Curve, curveB: Curve, testPlane: Plane, tolerance: float) -> RegionContainment: ...
    @overload
    @staticmethod
    def PlanarCurveCollision(curveA: Curve, curveB: Curve, testPlane: Plane, tolerance: float) -> bool: ...
    @overload
    def PointAt(self, t: float) -> Point3d: ...
    @overload
    def PointAtLength(self, length: float) -> Point3d: ...
    @overload
    def PointAtNormalizedLength(self, length: float) -> Point3d: ...
    @overload
    @staticmethod
    def ProjectToBrep(curves: Generic.IEnumerable, breps: Generic.IEnumerable, direction: Vector3d, tolerance: float) -> System.Array[Curve]: ...
    @overload
    @staticmethod
    def ProjectToBrep(curve: Curve, breps: Generic.IEnumerable, direction: Vector3d, tolerance: float) -> System.Array[Curve]: ...
    @overload
    @staticmethod
    def ProjectToBrep(curve: Curve, brep: Brep, direction: Vector3d, tolerance: float) -> System.Array[Curve]: ...
    @overload
    @staticmethod
    def ProjectToBrep(curve: Curve, breps: Generic.IEnumerable, direction: Vector3d, tolerance: float) -> (System.Array[Curve], System.System.Array[int]): ...
    @overload
    @staticmethod
    def ProjectToBrep(curves: Generic.IEnumerable, breps: Generic.IEnumerable, direction: Vector3d, tolerance: float) -> (System.Array[Curve], System.System.Array[int], System.System.Array[int]): ...
    @overload
    @staticmethod
    def ProjectToBrep(curves: Generic.IEnumerable, breps: Generic.IEnumerable, direction: Vector3d, tolerance: float, loose: bool) -> (System.Array[Curve], System.System.Array[int], System.System.Array[int]): ...
    @overload
    @staticmethod
    def ProjectToMesh(curve: Curve, mesh: Mesh, direction: Vector3d, tolerance: float) -> System.Array[Curve]: ...
    @overload
    @staticmethod
    def ProjectToMesh(curve: Curve, meshes: Generic.IEnumerable, direction: Vector3d, tolerance: float) -> System.Array[Curve]: ...
    @overload
    @staticmethod
    def ProjectToMesh(curves: Generic.IEnumerable, meshes: Generic.IEnumerable, direction: Vector3d, tolerance: float) -> System.Array[Curve]: ...
    @overload
    @staticmethod
    def ProjectToMesh(curves: Generic.IEnumerable, meshes: Generic.IEnumerable, direction: Vector3d, tolerance: float, loose: bool) -> System.Array[Curve]: ...
    @overload
    @staticmethod
    def ProjectToPlane(curve: Curve, plane: Plane) -> Curve: ...
    @overload
    def PullToBrepFace(self, face: BrepFace, tolerance: float) -> System.Array[Curve]: ...
    @overload
    @staticmethod
    def PullToBrepFace(curve: Curve, face: BrepFace, tolerance: float) -> System.Array[Curve]: ...
    @overload
    @staticmethod
    def PullToBrepFace(curve: Curve, face: BrepFace, tolerance: float, loose: bool) -> System.Array[Curve]: ...
    @overload
    def PullToMesh(self, mesh: Mesh, tolerance: float) -> PolylineCurve: ...
    @overload
    def PullToMesh(self, mesh: Mesh, tolerance: float, loose: bool) -> Curve: ...
    @overload
    def Rebuild(self, pointCount: int, degree: int, preserveTangents: bool) -> NurbsCurve: ...
    @overload
    def RemoveShortSegments(self, tolerance: float) -> bool: ...
    @overload
    def Repair(self, tolerance: float) -> bool: ...
    @overload
    def Reparameterize() -> Curve: ...
    @overload
    def Reverse() -> bool: ...
    @overload
    def RibbonOffset(self, ribbonParameters: RibbonOffsetParameters) -> (Curve, System.Array[Curve], System.Array[Curve], System.Array[Brep]): ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> Curve: ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> (Curve, System.Array[Curve], System.Array[Surface]): ...
    @overload
    def RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Point3d, normal: Vector3d, tolerance: float) -> (Curve, System.System.Array[float], System.System.Array[float]): ...
    @Domain.setter
    def Domain(self, value: System.Void): ...
    @overload
    def SetEndPoint(self, point: Point3d) -> bool: ...
    @overload
    def SetStartPoint(self, point: Point3d) -> bool: ...
    @overload
    def Simplify(self, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    @overload
    def SimplifyEnd(self, end: CurveEnd, options: CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem) -> Curve: ...
    @overload
    def Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: SmoothingCoordinateSystem, plane: Plane) -> Curve: ...
    @overload
    def SpanDomain(self, spanIndex: int) -> Interval: ...
    @overload
    def SpanVector() -> System.System.Array[float]: ...
    @overload
    def Split(self, t: float) -> System.Array[Curve]: ...
    @overload
    def Split(self, t: Generic.IEnumerable) -> System.Array[Curve]: ...
    @overload
    def Split(self, cutter: Brep, tolerance: float, angleToleranceRadians: float) -> System.Array[Curve]: ...
    @overload
    def Split(self, cutter: Surface, tolerance: float, angleToleranceRadians: float) -> System.Array[Curve]: ...
    @overload
    def TangentAt(self, t: float) -> Vector3d: ...
    @overload
    def ToArcsAndLines(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolyCurve: ...
    @overload
    def ToNurbsCurve() -> NurbsCurve: ...
    @overload
    def ToNurbsCurve(self, subdomain: Interval) -> NurbsCurve: ...
    @overload
    def ToPolyline(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool) -> PolylineCurve: ...
    @overload
    def ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool, curveDomain: Interval) -> PolylineCurve: ...
    @overload
    def TorsionAt(self, t: float) -> float: ...
    @overload
    def Trim(self, domain: Interval) -> Curve: ...
    @overload
    def Trim(self, t0: float, t1: float) -> Curve: ...
    @overload
    def Trim(self, side: CurveEnd, length: float) -> Curve: ...
    @overload
    def TryGetArc() -> (bool, Arc): ...
    @overload
    def TryGetArc(self, tolerance: float) -> (bool, Arc): ...
    @overload
    def TryGetArc(self, plane: Plane) -> (bool, Arc): ...
    @overload
    def TryGetArc(self, plane: Plane, tolerance: float) -> (bool, Arc): ...
    @overload
    def TryGetCircle() -> (bool, Circle): ...
    @overload
    def TryGetCircle(self, tolerance: float) -> (bool, Circle): ...
    @overload
    def TryGetEllipse() -> (bool, Ellipse): ...
    @overload
    def TryGetEllipse(self, tolerance: float) -> (bool, Ellipse): ...
    @overload
    def TryGetEllipse(self, plane: Plane) -> (bool, Ellipse): ...
    @overload
    def TryGetEllipse(self, plane: Plane, tolerance: float) -> (bool, Ellipse): ...
    @overload
    def TryGetPlane() -> (bool, Plane): ...
    @overload
    def TryGetPlane(self, tolerance: float) -> (bool, Plane): ...
    @overload
    def TryGetPolyline() -> (bool, Polyline): ...
    @overload
    def TryGetPolyline() -> (bool, Polyline, System.System.Array[float]): ...

class RibbonOffsetParameters(object):
    """Advanced parameters for RibbonOffset Parameters mimic the RibbonOffset Command.

    """
    def __init__(self): ...
    @property
    def AlignCrossSections(self) -> bool: ...
    @property
    def BlendRadius(self) -> float: ...
    @property
    def OffsetDistance(self) -> float: ...
    @property
    def OffsetLocation(self) -> Point3d: ...
    @property
    def OffsetPlaneVector3d(self) -> Vector3d: ...
    @property
    def OffsetTolerance(self) -> float: ...
    @property
    def RebuildPointCount(self) -> int: ...
    @property
    def RefitTolerance(self) -> float: ...
    @property
    def RibbonSurfaceGenerationMethod(self) -> RibbonOffsetSurfaceMethod: ...
    @AlignCrossSections.setter
    def AlignCrossSections(self, value: System.Void): ...
    @BlendRadius.setter
    def BlendRadius(self, value: System.Void): ...
    @OffsetDistance.setter
    def OffsetDistance(self, value: System.Void): ...
    @OffsetLocation.setter
    def OffsetLocation(self, value: System.Void): ...
    @OffsetPlaneVector3d.setter
    def OffsetPlaneVector3d(self, value: System.Void): ...
    @OffsetTolerance.setter
    def OffsetTolerance(self, value: System.Void): ...
    @RebuildPointCount.setter
    def RebuildPointCount(self, value: System.Void): ...
    @RefitTolerance.setter
    def RefitTolerance(self, value: System.Void): ...
    @RibbonSurfaceGenerationMethod.setter
    def RibbonSurfaceGenerationMethod(self, value: System.Void): ...

class RibbonOffsetSurfaceMethod(enum.Enum):
    None_ = 0
    Sweep2 = 1
    Sweep2NetworkSrf = 2

class Cylinder(System.ValueType):
    """Represents the values of a plane, a radius and two heights -on top and beneath- that define a right circular cylinder.

    """
    @overload
    def __init__(self, baseCircle: Circle): ...
    @overload
    def __init__(self, baseCircle: Circle, height: float): ...
    @overload
    def CircleAt(self, linearParameter: float) -> Circle: ...
    @overload
    def EpsilonEquals(self, other: Cylinder, epsilon: float) -> bool: ...
    @property
    def Axis(self) -> Vector3d: ...
    @property
    def BasePlane(self) -> Plane: ...
    @property
    def Center(self) -> Point3d: ...
    @property
    def Height1(self) -> float: ...
    @property
    def Height2(self) -> float: ...
    @property
    def IsFinite(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Radius(self) -> float: ...
    @property
    def TotalHeight(self) -> float: ...
    @property
    def Unset(self) -> Cylinder: ...
    @overload
    def LineAt(self, angularParameter: float) -> Line: ...
    @BasePlane.setter
    def BasePlane(self, value: System.Void): ...
    @Height1.setter
    def Height1(self, value: System.Void): ...
    @Height2.setter
    def Height2(self, value: System.Void): ...
    @Radius.setter
    def Radius(self, value: System.Void): ...
    @overload
    def ToBrep(self, capBottom: bool, capTop: bool) -> Brep: ...
    @overload
    def ToNurbsSurface() -> NurbsSurface: ...
    @overload
    def ToRevSurface() -> RevSurface: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...

class Ellipse(System.ValueType):
    """Represents the values of a plane and the two semi-axes radii in an ellipse.

    """
    @overload
    def __init__(self, plane: Plane, radius1: float, radius2: float): ...
    @overload
    def __init__(self, center: Point3d, second: Point3d, third: Point3d): ...
    @overload
    def EpsilonEquals(self, other: Ellipse, epsilon: float) -> bool: ...
    @property
    def Center(self) -> Point3d: ...
    @property
    def FocalDistance(self) -> float: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Plane(self) -> Plane: ...
    @property
    def Radius1(self) -> float: ...
    @property
    def Radius2(self) -> float: ...
    @overload
    def GetFoci() -> (Point3d, Point3d): ...
    @Center.setter
    def Center(self, value: System.Void): ...
    @Plane.setter
    def Plane(self, value: System.Void): ...
    @Radius1.setter
    def Radius1(self, value: System.Void): ...
    @Radius2.setter
    def Radius2(self, value: System.Void): ...
    @overload
    def ToNurbsCurve() -> NurbsCurve: ...

class GeometryBase(Runtime.CommonObject):
    """Provides a common base for most geometric classes. This class is abstract.

    """
    @overload
    def ComponentIndex() -> ComponentIndex: ...
    @overload
    def DataCRC(self, currentRemainder: System.UInt32) -> System.UInt32: ...
    @overload
    def DeleteAllUserStrings() -> None: ...
    @overload
    def DeleteUserString(self, key: str) -> bool: ...
    @overload
    def Duplicate() -> GeometryBase: ...
    @overload
    def DuplicateShallow() -> GeometryBase: ...
    @overload
    @staticmethod
    def GeometryEquals(first: GeometryBase, second: GeometryBase) -> bool: ...
    @overload
    @staticmethod
    def GeometryReferenceEquals(one: GeometryBase, other: GeometryBase) -> bool: ...
    @property
    def HasBrepForm(self) -> bool: ...
    @property
    def IsDeformable(self) -> bool: ...
    @property
    def IsDocumentControlled(self) -> bool: ...
    @property
    def ObjectType(self) -> DocObjects.ObjectType: ...
    @property
    def UserStringCount(self) -> int: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, accurate: bool) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, xform: Transform) -> BoundingBox: ...
    @overload
    def GetBoundingBox(self, plane: Plane) -> (BoundingBox, Box): ...
    @overload
    def GetUserString(self, key: str) -> str: ...
    @overload
    def GetUserStrings() -> Specialized.NameValueCollection: ...
    @overload
    def MakeDeformable() -> bool: ...
    @overload
    def MemoryEstimate() -> System.UInt32: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> bool: ...
    @overload
    def Scale(self, scaleFactor: float) -> bool: ...
    @overload
    def SetUserString(self, key: str, value: str) -> bool: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, translationVector: Vector3d) -> bool: ...
    @overload
    def Translate(self, x: float, y: float, z: float) -> bool: ...

class Line(System.ValueType):
    """Represents the value of start and end points in a single line segment.

    """
    @overload
    def __init__(self, from_: Point3d, to: Point3d): ...
    @overload
    def __init__(self, start: Point3d, span: Vector3d): ...
    @overload
    def __init__(self, start: Point3d, direction: Vector3d, length: float): ...
    @overload
    def __init__(self, x0: float, y0: float, z0: float, x1: float, y1: float, z1: float): ...
    @overload
    def ClosestParameter(self, testPoint: Point3d) -> float: ...
    @overload
    def ClosestPoint(self, testPoint: Point3d, limitToFiniteSegment: bool) -> Point3d: ...
    @overload
    def DistanceTo(self, testPoint: Point3d, limitToFiniteSegment: bool) -> float: ...
    @overload
    def EpsilonEquals(self, other: Line, epsilon: float) -> bool: ...
    @overload
    def Equals(self, other: Line) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Extend(self, startLength: float, endLength: float) -> bool: ...
    @overload
    def ExtendThroughBox(self, box: BoundingBox) -> bool: ...
    @overload
    def ExtendThroughBox(self, box: Box) -> bool: ...
    @overload
    def ExtendThroughBox(self, box: Box, additionalLength: float) -> bool: ...
    @overload
    def ExtendThroughBox(self, box: BoundingBox, additionalLength: float) -> bool: ...
    @overload
    def Flip() -> None: ...
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @property
    def Direction(self) -> Vector3d: ...
    @property
    def From(self) -> Point3d: ...
    @property
    def FromX(self) -> float: ...
    @property
    def FromY(self) -> float: ...
    @property
    def FromZ(self) -> float: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Length(self) -> float: ...
    @property
    def To(self) -> Point3d: ...
    @property
    def ToX(self) -> float: ...
    @property
    def ToY(self) -> float: ...
    @property
    def ToZ(self) -> float: ...
    @property
    def UnitTangent(self) -> Vector3d: ...
    @property
    def Unset(self) -> Line: ...
    @overload
    def GetHashCode() -> int: ...
    @overload
    def MaximumDistanceTo(self, testLine: Line) -> float: ...
    @overload
    def MaximumDistanceTo(self, testPoint: Point3d) -> float: ...
    @overload
    def MinimumDistanceTo(self, testLine: Line) -> float: ...
    @overload
    def MinimumDistanceTo(self, testPoint: Point3d) -> float: ...
    @overload
    def PointAt(self, t: float) -> Point3d: ...
    @overload
    def PointAtLength(self, distance: float) -> Point3d: ...
    @From.setter
    def From(self, value: System.Void): ...
    @FromX.setter
    def FromX(self, value: System.Void): ...
    @FromY.setter
    def FromY(self, value: System.Void): ...
    @FromZ.setter
    def FromZ(self, value: System.Void): ...
    @Length.setter
    def Length(self, value: System.Void): ...
    @To.setter
    def To(self, value: System.Void): ...
    @ToX.setter
    def ToX(self, value: System.Void): ...
    @ToY.setter
    def ToY(self, value: System.Void): ...
    @ToZ.setter
    def ToZ(self, value: System.Void): ...
    @overload
    def ToNurbsCurve() -> NurbsCurve: ...
    @overload
    def ToString() -> str: ...
    @overload
    def ToString(self, format_: str, formatProvider: System.IFormatProvider) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    @staticmethod
    def TryCreateBetweenCurves(curve0: Curve, curve1: Curve, perpendicular0: bool, perpendicular1: bool) -> (bool, float, float, Line): ...
    @overload
    @staticmethod
    def TryFitLineToPoints(points: Generic.IEnumerable) -> (bool, Line): ...
    @overload
    def TryGetPlane() -> (bool, Plane): ...

class Triangle3d(System.ValueType):
    """Represents a triangle, modeled using double three points that use double-precision floating point numbers.

    """
    def __init__(self, a: Point3d, b: Point3d, c: Point3d): ...
    @overload
    def BarycentricCoordsAt(self, point: Point3d) -> (Point2d, float): ...
    @overload
    def ClosestParameterOnBoundary(self, point: Point3d) -> float: ...
    @overload
    def ClosestPointOnBoundary(self, point: Point3d) -> Point3d: ...
    @property
    def A(self) -> Point3d: ...
    @property
    def AB(self) -> Line: ...
    @property
    def AltitudeA(self) -> Line: ...
    @property
    def AltitudeB(self) -> Line: ...
    @property
    def AltitudeC(self) -> Line: ...
    @property
    def AngleA(self) -> float: ...
    @property
    def AngleB(self) -> float: ...
    @property
    def AngleC(self) -> float: ...
    @property
    def Area(self) -> float: ...
    @property
    def AreaCenter(self) -> Point3d: ...
    @property
    def B(self) -> Point3d: ...
    @property
    def BC(self) -> Line: ...
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @property
    def C(self) -> Point3d: ...
    @property
    def CA(self) -> Line: ...
    @property
    def Circumcenter(self) -> Point3d: ...
    @property
    def Circumcircle(self) -> Circle: ...
    @property
    def MedianA(self) -> Line: ...
    @property
    def MedianB(self) -> Line: ...
    @property
    def MedianC(self) -> Line: ...
    @property
    def Orthocenter(self) -> Point3d: ...
    @property
    def Perimeter(self) -> float: ...
    @property
    def PerpendicularAB(self) -> Line: ...
    @property
    def PerpendicularBC(self) -> Line: ...
    @property
    def PerpendicularCA(self) -> Line: ...
    @overload
    def PointAlongBoundary(self, t: float) -> Point3d: ...
    @overload
    def PointAtBarycentricCoords(self, coords: Point2d) -> Point3d: ...
    @overload
    def PointOnInterior(self, u: float, v: float) -> Point3d: ...
    @overload
    def ToMesh() -> Mesh: ...
    @overload
    def ToPolyline() -> Polyline: ...
    @overload
    def Transform(self, transform: Transform) -> Triangle3d: ...
    @overload
    @staticmethod
    def TrySmallestEnclosingTriangle(points: Generic.IEnumerable, tolerance: float) -> (bool, Triangle3d): ...
    @overload
    def WithA(self, a: Point3d) -> Triangle3d: ...
    @overload
    def WithB(self, b: Point3d) -> Triangle3d: ...
    @overload
    def WithC(self, c: Point3d) -> Triangle3d: ...

class KnotStyle(enum.Enum):
    Unknown = 0
    Uniform = 1
    QuasiUniform = 2
    PiecewiseBezier = 3
    ClampedEnd = 4
    NonUniform = 5

class NurbsCurve(Curve):
    """Represents a Non Uniform Rational B-Splines (NURBS) curve.

    """
    @overload
    def __init__(self, other: NurbsCurve): ...
    @overload
    def __init__(self, degree: int, pointCount: int): ...
    @overload
    def __init__(self, dimension: int, rational: bool, order: int, pointCount: int): ...
    @overload
    def Append(self, nurbsCurve: NurbsCurve) -> bool: ...
    @overload
    def ConvertSpanToBezier(self, spanIndex: int) -> BezierCurve: ...
    @overload
    @staticmethod
    def Create(periodic: bool, degree: int, points: Generic.IEnumerable) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateFromArc(arc: Arc) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateFromArc(arc: Arc, degree: int, cvCount: int) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateFromCircle(circle: Circle) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateFromCircle(circle: Circle, degree: int, cvCount: int) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateFromEllipse(ellipse: Ellipse) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateFromFitPoints(points: Generic.IEnumerable, tolerance: float, periodic: bool) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateFromFitPoints(points: Generic.IEnumerable, tolerance: float, degree: int, periodic: bool, startTangent: Vector3d, endTangent: Vector3d) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateFromLine(line: Line) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateHSpline(points: Generic.IEnumerable) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateHSpline(points: Generic.IEnumerable, startTangent: Vector3d, endTangent: Vector3d) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateNonRationalArcBezier(degree: int, center: Point3d, start: Point3d, end: Point3d, radius: float, tanSlider: float, midSlider: float) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateParabolaFromFocus(focus: Point3d, startPoint: Point3d, endPoint: Point3d) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateParabolaFromPoints(startPoint: Point3d, innerPoint: Point3d, endPoint: Point3d) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateParabolaFromVertex(vertex: Point3d, startPoint: Point3d, endPoint: Point3d) -> NurbsCurve: ...
    @overload
    def CreatePlanarRailFrames(self, parameters: Generic.IEnumerable, normal: Vector3d) -> System.Array[Plane]: ...
    @overload
    def CreateRailFrames(self, parameters: Generic.IEnumerable) -> System.Array[Plane]: ...
    @overload
    @staticmethod
    def CreateSpiral(axisStart: Point3d, axisDir: Vector3d, radiusPoint: Point3d, pitch: float, turnCount: float, radius0: float, radius1: float) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateSpiral(railCurve: Curve, t0: float, t1: float, radiusPoint: Point3d, pitch: float, turnCount: float, radius0: float, radius1: float, pointsPerTurn: int) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateSubDFriendly(curve: Curve) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateSubDFriendly(points: Generic.IEnumerable, interpolatePoints: bool, periodicClosedCurve: bool) -> NurbsCurve: ...
    @overload
    @staticmethod
    def CreateSubDFriendly(curve: Curve, pointCount: int, periodicClosedCurve: bool) -> NurbsCurve: ...
    @overload
    def EpsilonEquals(self, other: NurbsCurve, epsilon: float) -> bool: ...
    @property
    def HasBezierSpans(self) -> bool: ...
    @property
    def IsRational(self) -> bool: ...
    @property
    def Knots(self) -> Collections.NurbsCurveKnotList: ...
    @property
    def Order(self) -> int: ...
    @property
    def Points(self) -> Collections.NurbsCurvePointList: ...
    @overload
    def GrevilleParameter(self, index: int) -> float: ...
    @overload
    def GrevilleParameters() -> System.System.Array[float]: ...
    @overload
    def GrevillePoint(self, index: int) -> Point3d: ...
    @overload
    def GrevillePoints() -> Collections.Point3dList: ...
    @overload
    def GrevillePoints(self, all_: bool) -> Collections.Point3dList: ...
    @overload
    def IncreaseDegree(self, desiredDegree: int) -> bool: ...
    @overload
    @staticmethod
    def IsDuplicate(curveA: NurbsCurve, curveB: NurbsCurve, ignoreParameterization: bool, tolerance: float) -> bool: ...
    @overload
    @staticmethod
    def MakeCompatible(curves: Generic.IEnumerable, startPt: Point3d, endPt: Point3d, simplifyMethod: int, numPoints: int, refitTolerance: float, angleTolerance: float) -> System.Array[NurbsCurve]: ...
    @overload
    def MakePiecewiseBezier(self, setEndWeightsToOne: bool) -> bool: ...
    @overload
    def MatchToCurve(self, targetCurve: Curve, maxEndDistance: float, maxInteriorDistance: float, matchTolerance: float, maxLevel: int) -> NurbsCurve: ...
    @overload
    def Reparameterize(self, c: float) -> bool: ...
    @overload
    def SetEndCondition(self, bSetEnd: bool, continuity: NurbsCurveEndConditionType, point: Point3d, tangent: Vector3d) -> bool: ...
    @overload
    def SetEndCondition(self, bSetEnd: bool, continuity: NurbsCurveEndConditionType, point: Point3d, tangent: Vector3d, curvature: Vector3d) -> bool: ...
    @overload
    def SetGrevillePoints(self, points: Generic.IEnumerable) -> bool: ...
    @overload
    def UVNDirectionsAt(self, t: float) -> (bool, Vector3d, Vector3d, Vector3d): ...

class ControlPoint(System.ValueType):
    """Represents control point geometry with three-dimensional position and weight.

    """
    @overload
    def __init__(self, pt: Point3d): ...
    @overload
    def __init__(self, pt: Point4d): ...
    @overload
    def __init__(self, euclideanPt: Point3d, weight: float): ...
    @overload
    def __init__(self, x: float, y: float, z: float): ...
    @overload
    def __init__(self, x: float, y: float, z: float, weight: float): ...
    @overload
    def EpsilonEquals(self, other: ControlPoint, epsilon: float) -> bool: ...
    @overload
    def Equals(self, other: ControlPoint) -> bool: ...
    @property
    def Location(self) -> Point3d: ...
    @property
    def Unset(self) -> ControlPoint: ...
    @property
    def Weight(self) -> float: ...
    @property
    def X(self) -> float: ...
    @property
    def Y(self) -> float: ...
    @property
    def Z(self) -> float: ...
    @Location.setter
    def Location(self, value: System.Void): ...
    @Weight.setter
    def Weight(self, value: System.Void): ...
    @X.setter
    def X(self, value: System.Void): ...
    @Y.setter
    def Y(self, value: System.Void): ...
    @Z.setter
    def Z(self, value: System.Void): ...

class PlaneFitResult(enum.Enum):
    Success = 0
    Inconclusive = 1
    Failure = -1

class Plane(System.ValueType):
    """Represents the value of a center point and two axes in a plane in three dimensions.

    """
    @overload
    def __init__(self, other: Plane): ...
    @overload
    def __init__(self, origin: Point3d, normal: Vector3d): ...
    @overload
    def __init__(self, origin: Point3d, xDirection: Vector3d, yDirection: Vector3d): ...
    @overload
    def __init__(self, origin: Point3d, xPoint: Point3d, yPoint: Point3d): ...
    @overload
    def __init__(self, a: float, b: float, c: float, d: float): ...
    @overload
    def Clone() -> Plane: ...
    @overload
    def ClosestParameter(self, testPoint: Point3d) -> (bool, float, float): ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...
    @overload
    @staticmethod
    def CreateFromFrame(origin: Point3d, xDirection: Vector3d, yDirection: Vector3d) -> Plane: ...
    @overload
    @staticmethod
    def CreateFromNormal(origin: Point3d, normal: Vector3d) -> Plane: ...
    @overload
    @staticmethod
    def CreateFromNormalYup(origin: Point3d, normal: Vector3d, yDirection: Vector3d) -> Plane: ...
    @overload
    @staticmethod
    def CreateFromPoints(origin: Point3d, xPoint: Point3d, yPoint: Point3d) -> Plane: ...
    @overload
    def DistanceTo(self, testPoint: Point3d) -> float: ...
    @overload
    def DistanceTo(self, bbox: BoundingBox) -> (bool, float, float): ...
    @overload
    def EpsilonEquals(self, other: Plane, epsilon: float) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Equals(self, plane: Plane) -> bool: ...
    @overload
    def ExtendThroughBox(self, box: BoundingBox) -> (bool, Interval, Interval): ...
    @overload
    def ExtendThroughBox(self, box: Box) -> (bool, Interval, Interval): ...
    @overload
    @staticmethod
    def FitPlaneToPoints(points: Generic.IEnumerable) -> (PlaneFitResult, Plane): ...
    @overload
    @staticmethod
    def FitPlaneToPoints(points: Generic.IEnumerable) -> (PlaneFitResult, Plane, float): ...
    @overload
    def Flip() -> None: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Normal(self) -> Vector3d: ...
    @property
    def Origin(self) -> Point3d: ...
    @property
    def OriginX(self) -> float: ...
    @property
    def OriginY(self) -> float: ...
    @property
    def OriginZ(self) -> float: ...
    @property
    def Unset(self) -> Plane: ...
    @property
    def WorldXY(self) -> Plane: ...
    @property
    def WorldYZ(self) -> Plane: ...
    @property
    def WorldZX(self) -> Plane: ...
    @property
    def XAxis(self) -> Vector3d: ...
    @property
    def YAxis(self) -> Vector3d: ...
    @property
    def ZAxis(self) -> Vector3d: ...
    @overload
    def GetHashCode() -> int: ...
    @overload
    def GetPlaneEquation() -> System.System.Array[float]: ...
    @overload
    def IsCoplanar(self, plane: Plane) -> bool: ...
    @overload
    def IsCoplanar(self, plane: Plane, tolerance: float) -> bool: ...
    @overload
    def PointAt(self, u: float, v: float) -> Point3d: ...
    @overload
    def PointAt(self, u: float, v: float, w: float) -> Point3d: ...
    @overload
    def RemapToPlaneSpace(self, ptSample: Point3d) -> (bool, Point3d): ...
    @overload
    def Rotate(self, angle: float, axis: Vector3d) -> bool: ...
    @overload
    def Rotate(self, angle: float, axis: Vector3d, centerOfRotation: Point3d) -> bool: ...
    @overload
    def Rotate(self, sinAngle: float, cosAngle: float, axis: Vector3d) -> bool: ...
    @overload
    def Rotate(self, sinAngle: float, cosAngle: float, axis: Vector3d, centerOfRotation: Point3d) -> bool: ...
    @Origin.setter
    def Origin(self, value: System.Void): ...
    @OriginX.setter
    def OriginX(self, value: System.Void): ...
    @OriginY.setter
    def OriginY(self, value: System.Void): ...
    @OriginZ.setter
    def OriginZ(self, value: System.Void): ...
    @XAxis.setter
    def XAxis(self, value: System.Void): ...
    @YAxis.setter
    def YAxis(self, value: System.Void): ...
    @ZAxis.setter
    def ZAxis(self, value: System.Void): ...
    @overload
    def ToString() -> str: ...
    @overload
    def ToString(self, format_: str, formatProvider: System.IFormatProvider) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, delta: Vector3d) -> bool: ...
    @overload
    def UpdateEquation() -> bool: ...
    @overload
    def ValueAt(self, p: Point3d) -> float: ...

class Point2f(System.ValueType):
    """Represents the two coordinates of a point in two-dimensional space, using
-precision floating point numbers.

    """
    @overload
    def __init__(self, x: System.Single, y: System.Single): ...
    @overload
    def __init__(self, x: float, y: float): ...
    @overload
    def CompareTo(self, other: Point2f) -> int: ...
    @overload
    def DistanceTo(self, other: Point2f) -> float: ...
    @overload
    def DistanceToSquared(self, other: Point2f) -> float: ...
    @overload
    def EpsilonEquals(self, other: Point2f, epsilon: System.Single) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Equals(self, point: Point2f) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Item(self) -> System.Single: ...
    @property
    def Unset(self) -> Point2f: ...
    @property
    def X(self) -> System.Single: ...
    @property
    def Y(self) -> System.Single: ...
    @overload
    def GetHashCode() -> int: ...
    @Item.setter
    def Item(self, value: System.Void): ...
    @X.setter
    def X(self, value: System.Void): ...
    @Y.setter
    def Y(self, value: System.Void): ...
    @overload
    def ToString() -> str: ...
    @overload
    def ToString(self, format_: str, formatProvider: System.IFormatProvider) -> str: ...

class Point3f(System.ValueType):
    """Represents the three coordinates of a point in three-dimensional space, using
-precision floating point numbers.

    """
    def __init__(self, x: System.Single, y: System.Single, z: System.Single): ...
    @overload
    def CompareTo(self, other: Point3f) -> int: ...
    @overload
    def DistanceTo(self, other: Point3f) -> float: ...
    @overload
    def DistanceToSquared(self, other: Point3f) -> float: ...
    @overload
    def EpsilonEquals(self, other: Point3f, epsilon: System.Single) -> bool: ...
    @overload
    def Equals(self, point: Point3f) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Origin(self) -> Point3f: ...
    @property
    def Unset(self) -> Point3f: ...
    @property
    def X(self) -> System.Single: ...
    @property
    def Y(self) -> System.Single: ...
    @property
    def Z(self) -> System.Single: ...
    @overload
    def GetHashCode() -> int: ...
    @X.setter
    def X(self, value: System.Void): ...
    @Y.setter
    def Y(self, value: System.Void): ...
    @Z.setter
    def Z(self, value: System.Void): ...
    @overload
    @staticmethod
    def Subtract(point1: Point3f, point2: Point3f) -> Vector3f: ...
    @overload
    def ToString() -> str: ...
    @overload
    def ToString(self, format_: str, formatProvider: System.IFormatProvider) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> None: ...

class Vector2f(System.ValueType):
    """Represents the two components of a vector in two-dimensional space, using
-precision floating point numbers.

    """
    def __init__(self, x: System.Single, y: System.Single): ...
    @overload
    @staticmethod
    def Add(point: Point2f, vector: Vector2f) -> Point2f: ...
    @overload
    @staticmethod
    def Add(vector1: Vector2f, vector2: Vector2f) -> Vector2f: ...
    @overload
    def CompareTo(self, other: Vector2f) -> int: ...
    @overload
    def EpsilonEquals(self, other: Vector2f, epsilon: System.Single) -> bool: ...
    @overload
    def Equals(self, vector: Vector2f) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def IsUnitVector(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def IsZero(self) -> bool: ...
    @property
    def Length(self) -> float: ...
    @property
    def SquareLength(self) -> System.Single: ...
    @property
    def Unset(self) -> Vector2f: ...
    @property
    def X(self) -> System.Single: ...
    @property
    def XAxis(self) -> Vector2f: ...
    @property
    def Y(self) -> System.Single: ...
    @property
    def YAxis(self) -> Vector2f: ...
    @property
    def Zero(self) -> Vector2f: ...
    @overload
    def GetHashCode() -> int: ...
    @overload
    @staticmethod
    def Multiply(point1: Vector2f, point2: Vector2f) -> float: ...
    @overload
    @staticmethod
    def Negate(vector: Vector2f) -> Vector2f: ...
    @overload
    def PerpendicularTo(self, other: Vector2f) -> bool: ...
    @overload
    def Reverse() -> bool: ...
    @X.setter
    def X(self, value: System.Void): ...
    @Y.setter
    def Y(self, value: System.Void): ...
    @overload
    @staticmethod
    def Subtract(vector1: Vector2f, vector2: Vector2f) -> Vector2f: ...
    @overload
    def ToString() -> str: ...
    @overload
    def ToString(self, format_: str, formatProvider: System.IFormatProvider) -> str: ...
    @overload
    def Unitize() -> bool: ...

class Vector3f(System.ValueType):
    """Represents the three components of a vector in three-dimensional space, using
-precision floating point numbers.

    """
    def __init__(self, x: System.Single, y: System.Single, z: System.Single): ...
    @overload
    @staticmethod
    def Add(vector1: Vector3f, vector2: Vector3f) -> Vector3f: ...
    @overload
    @staticmethod
    def Add(point: Point3f, vector: Vector3f) -> Point3f: ...
    @overload
    def CompareTo(self, other: Vector3f) -> int: ...
    @overload
    @staticmethod
    def CrossProduct(a: Vector3f, b: Vector3f) -> Vector3f: ...
    @overload
    @staticmethod
    def Divide(vector: Vector3f, t: float) -> Vector3f: ...
    @overload
    @staticmethod
    def Divide(vector: Vector3f, t: System.Single) -> Vector3f: ...
    @overload
    def EpsilonEquals(self, other: Vector3f, epsilon: System.Single) -> bool: ...
    @overload
    def Equals(self, vector: Vector3f) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def IsUnitVector(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def IsZero(self) -> bool: ...
    @property
    def Length(self) -> System.Single: ...
    @property
    def SquareLength(self) -> System.Single: ...
    @property
    def Unset(self) -> Vector3f: ...
    @property
    def X(self) -> System.Single: ...
    @property
    def XAxis(self) -> Vector3f: ...
    @property
    def Y(self) -> System.Single: ...
    @property
    def YAxis(self) -> Vector3f: ...
    @property
    def Z(self) -> System.Single: ...
    @property
    def ZAxis(self) -> Vector3f: ...
    @property
    def Zero(self) -> Vector3f: ...
    @overload
    def GetHashCode() -> int: ...
    @overload
    @staticmethod
    def Multiply(t: System.Single, vector: Vector3f) -> Vector3f: ...
    @overload
    @staticmethod
    def Multiply(vector: Vector3f, t: System.Single) -> Vector3f: ...
    @overload
    @staticmethod
    def Multiply(point1: Vector3f, point2: Vector3f) -> float: ...
    @overload
    @staticmethod
    def Negate(vector: Vector3f) -> Vector3f: ...
    @overload
    def PerpendicularTo(self, other: Vector3f) -> bool: ...
    @overload
    def Reverse() -> bool: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3f) -> bool: ...
    @X.setter
    def X(self, value: System.Void): ...
    @Y.setter
    def Y(self, value: System.Void): ...
    @Z.setter
    def Z(self, value: System.Void): ...
    @overload
    @staticmethod
    def Subtract(vector1: Vector3f, vector2: Vector3f) -> Vector3f: ...
    @overload
    def ToString() -> str: ...
    @overload
    def ToString(self, format_: str, formatProvider: System.IFormatProvider) -> str: ...
    @overload
    def Transform(self, transformation: Transform) -> None: ...
    @overload
    def Unitize() -> bool: ...

class Quaternion(System.ValueType):
    """Represents the four coefficient values in a quaternion.
The first value
a
is the real part, while the rest multiplies
i
,
j
and
k
, that are imaginary.
quaternion = a + bi + cj + dk

    """
    def __init__(self, a: float, b: float, c: float, d: float): ...
    @overload
    @staticmethod
    def CreateFromRotationZYX(yaw: float, pitch: float, roll: float) -> Quaternion: ...
    @overload
    @staticmethod
    def CreateFromRotationZYZ(alpha: float, beta: float, gamma: float) -> Quaternion: ...
    @overload
    @staticmethod
    def CrossProduct(p: Quaternion, q: Quaternion) -> Quaternion: ...
    @overload
    @staticmethod
    def Distance(p: Quaternion, q: Quaternion) -> float: ...
    @overload
    def DistanceTo(self, q: Quaternion) -> float: ...
    @overload
    def EpsilonEquals(self, other: Quaternion, epsilon: float) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Equals(self, other: Quaternion) -> bool: ...
    @property
    def A(self) -> float: ...
    @property
    def B(self) -> float: ...
    @property
    def C(self) -> float: ...
    @property
    def Conjugate(self) -> Quaternion: ...
    @property
    def D(self) -> float: ...
    @property
    def I(self) -> Quaternion: ...
    @property
    def Identity(self) -> Quaternion: ...
    @property
    def Inverse(self) -> Quaternion: ...
    @property
    def IsScalar(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def IsVector(self) -> bool: ...
    @property
    def IsZero(self) -> bool: ...
    @property
    def J(self) -> Quaternion: ...
    @property
    def K(self) -> Quaternion: ...
    @property
    def Length(self) -> float: ...
    @property
    def LengthSquared(self) -> float: ...
    @property
    def Scalar(self) -> float: ...
    @property
    def Vector(self) -> Vector3d: ...
    @property
    def Zero(self) -> Quaternion: ...
    @overload
    def GetEulerZYZ() -> (bool, float, float, float): ...
    @overload
    def GetHashCode() -> int: ...
    @overload
    def GetRotation() -> (bool, Transform): ...
    @overload
    def GetRotation() -> (bool, Plane): ...
    @overload
    def GetRotation() -> (bool, float, Vector3d): ...
    @overload
    def GetYawPitchRoll() -> (bool, float, float, float): ...
    @overload
    def Invert() -> bool: ...
    @overload
    @staticmethod
    def Lerp(a: Quaternion, b: Quaternion, t: float) -> Quaternion: ...
    @overload
    def MatrixForm() -> Transform: ...
    @overload
    @staticmethod
    def Product(p: Quaternion, q: Quaternion) -> Quaternion: ...
    @overload
    def Rotate(self, v: Vector3d) -> Vector3d: ...
    @overload
    @staticmethod
    def RotateTowards(a: Quaternion, b: Quaternion, maxRadians: float) -> Quaternion: ...
    @overload
    @staticmethod
    def Rotation(plane0: Plane, plane1: Plane) -> Quaternion: ...
    @overload
    @staticmethod
    def Rotation(angle: float, axisOfRotation: Vector3d) -> Quaternion: ...
    @A.setter
    def A(self, value: System.Void): ...
    @B.setter
    def B(self, value: System.Void): ...
    @C.setter
    def C(self, value: System.Void): ...
    @D.setter
    def D(self, value: System.Void): ...
    @overload
    def Set(self, a: float, b: float, c: float, d: float) -> None: ...
    @overload
    def SetRotation(self, plane0: Plane, plane1: Plane) -> None: ...
    @overload
    def SetRotation(self, angle: float, axisOfRotation: Vector3d) -> None: ...
    @overload
    @staticmethod
    def Slerp(a: Quaternion, b: Quaternion, t: float) -> Quaternion: ...
    @overload
    def ToString() -> str: ...
    @overload
    def Unitize() -> bool: ...

class Sphere(System.ValueType):
    """Represents the plane and radius values of a sphere.

    """
    @overload
    def __init__(self, center: Point3d, radius: float): ...
    @overload
    def __init__(self, equatorialPlane: Plane, radius: float): ...
    @overload
    def ClosestParameter(self, testPoint: Point3d) -> (bool, float, float): ...
    @overload
    def ClosestPoint(self, testPoint: Point3d) -> Point3d: ...
    @overload
    def EpsilonEquals(self, other: Sphere, epsilon: float) -> bool: ...
    @overload
    @staticmethod
    def FitSphereToPoints(points: Generic.IEnumerable) -> Sphere: ...
    @property
    def BoundingBox(self) -> BoundingBox: ...
    @property
    def Center(self) -> Point3d: ...
    @property
    def Diameter(self) -> float: ...
    @property
    def EquatorialPlane(self) -> Plane: ...
    @property
    def EquitorialPlane(self) -> Plane: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def NorthPole(self) -> Point3d: ...
    @property
    def Radius(self) -> float: ...
    @property
    def SouthPole(self) -> Point3d: ...
    @property
    def Unset(self) -> Sphere: ...
    @overload
    def LatitudeDegrees(self, degrees: float) -> Circle: ...
    @overload
    def LatitudeRadians(self, radians: float) -> Circle: ...
    @overload
    def LongitudeDegrees(self, degrees: float) -> Circle: ...
    @overload
    def LongitudeRadians(self, radians: float) -> Circle: ...
    @overload
    def NormalAt(self, longitudeRadians: float, latitudeRadians: float) -> Vector3d: ...
    @overload
    def PointAt(self, longitudeRadians: float, latitudeRadians: float) -> Point3d: ...
    @overload
    def Rotate(self, angleRadians: float, axisOfRotation: Vector3d) -> bool: ...
    @overload
    def Rotate(self, angleRadians: float, axisOfRotation: Vector3d, centerOfRotation: Point3d) -> bool: ...
    @overload
    def Rotate(self, sinAngle: float, cosAngle: float, axisOfRotation: Vector3d) -> bool: ...
    @overload
    def Rotate(self, sinAngle: float, cosAngle: float, axisOfRotation: Vector3d, centerOfRotation: Point3d) -> bool: ...
    @Center.setter
    def Center(self, value: System.Void): ...
    @Diameter.setter
    def Diameter(self, value: System.Void): ...
    @EquatorialPlane.setter
    def EquatorialPlane(self, value: System.Void): ...
    @EquitorialPlane.setter
    def EquitorialPlane(self, value: System.Void): ...
    @Radius.setter
    def Radius(self, value: System.Void): ...
    @overload
    def ToBrep() -> Brep: ...
    @overload
    def ToNurbsSurface() -> NurbsSurface: ...
    @overload
    def ToRevSurface() -> RevSurface: ...
    @overload
    def Transform(self, xform: Transform) -> bool: ...
    @overload
    def Translate(self, delta: Vector3d) -> bool: ...

class Torus(System.ValueType):
    """Represents the value of a plane and two radii in a torus that is oriented in three-dimensional space.

    """
    def __init__(self, basePlane: Plane, majorRadius: float, minorRadius: float): ...
    @overload
    def EpsilonEquals(self, other: Torus, epsilon: float) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def MajorRadius(self) -> float: ...
    @property
    def MinorRadius(self) -> float: ...
    @property
    def Plane(self) -> Plane: ...
    @property
    def Unset(self) -> Torus: ...
    @MajorRadius.setter
    def MajorRadius(self, value: System.Void): ...
    @MinorRadius.setter
    def MinorRadius(self, value: System.Void): ...
    @Plane.setter
    def Plane(self, value: System.Void): ...
    @overload
    def ToBrep() -> Brep: ...
    @overload
    def ToNurbsSurface() -> NurbsSurface: ...
    @overload
    def ToRevSurface() -> RevSurface: ...

class Transform(System.ValueType):
    """Represents the values in a 4x4 transform matrix.
This is parallel to C++ ON_Xform.

    """
    @overload
    def __init__(self, diagonalValue: float): ...
    @overload
    def __init__(self, value: Transform): ...
    @overload
    def Affineize() -> None: ...
    @overload
    @staticmethod
    def ChangeBasis(plane0: Plane, plane1: Plane) -> Transform: ...
    @overload
    @staticmethod
    def ChangeBasis(X0: Vector3d, Y0: Vector3d, Z0: Vector3d, X1: Vector3d, Y1: Vector3d, Z1: Vector3d) -> Transform: ...
    @overload
    @staticmethod
    def ChangeBasis(P0: Point3d, X0: Vector3d, Y0: Vector3d, Z0: Vector3d, P1: Point3d, X1: Vector3d, Y1: Vector3d, Z1: Vector3d) -> Transform: ...
    @overload
    def Clone() -> Transform: ...
    @overload
    def CompareTo(self, other: Transform) -> int: ...
    @overload
    def DecomposeAffine() -> (bool, Vector3d, Transform): ...
    @overload
    def DecomposeAffine() -> (bool, Transform, Vector3d): ...
    @overload
    def DecomposeAffine() -> (bool, Vector3d, Transform, Transform, Vector3d): ...
    @overload
    def DecomposeRigid(self, tolerance: float) -> (TransformRigidType, Vector3d, Transform): ...
    @overload
    def DecomposeSimilarity(self, tolerance: float) -> (TransformSimilarityType, Vector3d, float, Transform): ...
    @overload
    def DecomposeSymmetric() -> (bool, Transform, Vector3d): ...
    @overload
    def DecomposeTextureMapping() -> (Vector3d, Vector3d, Vector3d): ...
    @overload
    @staticmethod
    def Diagonal(diagonal: Vector3d) -> Transform: ...
    @overload
    @staticmethod
    def Diagonal(d0: float, d1: float, d2: float) -> Transform: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Equals(self, other: Transform) -> bool: ...
    @property
    def Determinant(self) -> float: ...
    @property
    def Identity(self) -> Transform: ...
    @property
    def IsAffine(self) -> bool: ...
    @property
    def IsIdentity(self) -> bool: ...
    @property
    def IsLinear(self) -> bool: ...
    @property
    def IsRotation(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def IsZero(self) -> bool: ...
    @property
    def IsZero4x4(self) -> bool: ...
    @property
    def IsZeroTransformation(self) -> bool: ...
    @property
    def Item(self) -> float: ...
    @property
    def M00(self) -> float: ...
    @property
    def M01(self) -> float: ...
    @property
    def M02(self) -> float: ...
    @property
    def M03(self) -> float: ...
    @property
    def M10(self) -> float: ...
    @property
    def M11(self) -> float: ...
    @property
    def M12(self) -> float: ...
    @property
    def M13(self) -> float: ...
    @property
    def M20(self) -> float: ...
    @property
    def M21(self) -> float: ...
    @property
    def M22(self) -> float: ...
    @property
    def M23(self) -> float: ...
    @property
    def M30(self) -> float: ...
    @property
    def M31(self) -> float: ...
    @property
    def M32(self) -> float: ...
    @property
    def M33(self) -> float: ...
    @property
    def RigidType(self) -> TransformRigidType: ...
    @property
    def SimilarityType(self) -> TransformSimilarityType: ...
    @property
    def Unset(self) -> Transform: ...
    @property
    def ZeroTransformation(self) -> Transform: ...
    @overload
    def GetEulerZYZ() -> (bool, float, float, float): ...
    @overload
    def GetHashCode() -> int: ...
    @overload
    def GetQuaternion() -> (bool, Quaternion): ...
    @overload
    def GetYawPitchRoll() -> (bool, float, float, float): ...
    @overload
    def IsRigid(self, tolerance: float) -> TransformRigidType: ...
    @overload
    def IsSimilarity(self, tolerance: float) -> TransformSimilarityType: ...
    @overload
    def IsZeroTransformationWithTolerance(self, zeroTolerance: float) -> bool: ...
    @overload
    def Linearize() -> None: ...
    @overload
    @staticmethod
    def Mirror(mirrorPlane: Plane) -> Transform: ...
    @overload
    @staticmethod
    def Mirror(pointOnMirrorPlane: Point3d, normalToMirrorPlane: Vector3d) -> Transform: ...
    @overload
    @staticmethod
    def Multiply(a: Transform, b: Transform) -> Transform: ...
    @overload
    def Orthogonalize(self, tolerance: float) -> bool: ...
    @overload
    @staticmethod
    def PlanarProjection(plane: Plane) -> Transform: ...
    @overload
    @staticmethod
    def PlaneToPlane(plane0: Plane, plane1: Plane) -> Transform: ...
    @overload
    @staticmethod
    def ProjectAlong(plane: Plane, direction: Vector3d) -> Transform: ...
    @overload
    @staticmethod
    def Rotation(angleRadians: float, rotationCenter: Point3d) -> Transform: ...
    @overload
    @staticmethod
    def Rotation(startDirection: Vector3d, endDirection: Vector3d, rotationCenter: Point3d) -> Transform: ...
    @overload
    @staticmethod
    def Rotation(angleRadians: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> Transform: ...
    @overload
    @staticmethod
    def Rotation(sinAngle: float, cosAngle: float, rotationAxis: Vector3d, rotationCenter: Point3d) -> Transform: ...
    @overload
    @staticmethod
    def Rotation(x0: Vector3d, y0: Vector3d, z0: Vector3d, x1: Vector3d, y1: Vector3d, z1: Vector3d) -> Transform: ...
    @overload
    @staticmethod
    def RotationZYX(yaw: float, pitch: float, roll: float) -> Transform: ...
    @overload
    @staticmethod
    def RotationZYZ(alpha: float, beta: float, gamma: float) -> Transform: ...
    @overload
    @staticmethod
    def Scale(anchor: Point3d, scaleFactor: float) -> Transform: ...
    @overload
    @staticmethod
    def Scale(plane: Plane, xScaleFactor: float, yScaleFactor: float, zScaleFactor: float) -> Transform: ...
    @Item.setter
    def Item(self, value: System.Void): ...
    @M00.setter
    def M00(self, value: System.Void): ...
    @M01.setter
    def M01(self, value: System.Void): ...
    @M02.setter
    def M02(self, value: System.Void): ...
    @M03.setter
    def M03(self, value: System.Void): ...
    @M10.setter
    def M10(self, value: System.Void): ...
    @M11.setter
    def M11(self, value: System.Void): ...
    @M12.setter
    def M12(self, value: System.Void): ...
    @M13.setter
    def M13(self, value: System.Void): ...
    @M20.setter
    def M20(self, value: System.Void): ...
    @M21.setter
    def M21(self, value: System.Void): ...
    @M22.setter
    def M22(self, value: System.Void): ...
    @M23.setter
    def M23(self, value: System.Void): ...
    @M30.setter
    def M30(self, value: System.Void): ...
    @M31.setter
    def M31(self, value: System.Void): ...
    @M32.setter
    def M32(self, value: System.Void): ...
    @M33.setter
    def M33(self, value: System.Void): ...
    @overload
    @staticmethod
    def Shear(plane: Plane, x: Vector3d, y: Vector3d, z: Vector3d) -> Transform: ...
    @overload
    @staticmethod
    def TextureMapping(offset: Vector3d, repeat: Vector3d, rotation: Vector3d) -> Transform: ...
    @overload
    def ToDoubleArray(self, rowDominant: bool) -> System.System.Array[float]: ...
    @overload
    def ToFloatArray(self, rowDominant: bool) -> System.System.Array[System.Single]: ...
    @overload
    def ToString() -> str: ...
    @overload
    def TransformBoundingBox(self, bbox: BoundingBox) -> BoundingBox: ...
    @overload
    def TransformList(self, points: Generic.IEnumerable) -> System.Array[Point3d]: ...
    @overload
    @staticmethod
    def Translation(motion: Vector3d) -> Transform: ...
    @overload
    @staticmethod
    def Translation(dx: float, dy: float, dz: float) -> Transform: ...
    @overload
    def Transpose() -> Transform: ...
    @overload
    def TryGetInverse() -> (bool, Transform): ...

class TransformSimilarityType(enum.Enum):
    NotSimilarity = 0
    OrientationPreserving = 1
    OrientationReversing = -1

class TransformRigidType(enum.Enum):
    NotRigid = 0
    Rigid = 1
    RigidReversing = -1

class SpaceMorph(object):
    """Represents a spacial, Euclidean morph.

    """
    @property
    def PreserveStructure(self) -> bool: ...
    @property
    def QuickPreview(self) -> bool: ...
    @property
    def Tolerance(self) -> float: ...
    @overload
    @staticmethod
    def IsMorphable(geometry: GeometryBase) -> bool: ...
    @overload
    def Morph(self, geometry: GeometryBase) -> bool: ...
    @overload
    def Morph() -> (bool, Plane): ...
    @overload
    def MorphPoint(self, point: Point3d) -> Point3d: ...
    @PreserveStructure.setter
    def PreserveStructure(self, value: System.Void): ...
    @QuickPreview.setter
    def QuickPreview(self, value: System.Void): ...
    @Tolerance.setter
    def Tolerance(self, value: System.Void): ...

class Interval(System.ValueType):
    """Represents an interval in one-dimensional space, that is defined as two extrema or bounds.

    """
    @overload
    def __init__(self, other: Interval): ...
    @overload
    def __init__(self, t0: float, t1: float): ...
    @overload
    def CompareTo(self, other: Interval) -> int: ...
    @overload
    def EpsilonEquals(self, other: Interval, epsilon: float) -> bool: ...
    @overload
    def Equals(self, other: Interval) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    @staticmethod
    def FromIntersection(a: Interval, b: Interval) -> Interval: ...
    @overload
    @staticmethod
    def FromUnion(a: Interval, b: Interval) -> Interval: ...
    @property
    def IsDecreasing(self) -> bool: ...
    @property
    def IsIncreasing(self) -> bool: ...
    @property
    def IsSingleton(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Item(self) -> float: ...
    @property
    def Length(self) -> float: ...
    @property
    def Max(self) -> float: ...
    @property
    def Mid(self) -> float: ...
    @property
    def Min(self) -> float: ...
    @property
    def T0(self) -> float: ...
    @property
    def T1(self) -> float: ...
    @property
    def Unset(self) -> Interval: ...
    @overload
    def GetHashCode() -> int: ...
    @overload
    def Grow(self, value: float) -> None: ...
    @overload
    def IncludesInterval(self, interval: Interval) -> bool: ...
    @overload
    def IncludesInterval(self, interval: Interval, strict: bool) -> bool: ...
    @overload
    def IncludesParameter(self, t: float) -> bool: ...
    @overload
    def IncludesParameter(self, t: float, strict: bool) -> bool: ...
    @overload
    def MakeIncreasing() -> None: ...
    @overload
    def NormalizedIntervalAt(self, intervalParameter: Interval) -> Interval: ...
    @overload
    def NormalizedParameterAt(self, intervalParameter: float) -> float: ...
    @overload
    def ParameterAt(self, normalizedParameter: float) -> float: ...
    @overload
    def ParameterIntervalAt(self, normalizedInterval: Interval) -> Interval: ...
    @overload
    def Reverse() -> None: ...
    @Item.setter
    def Item(self, value: System.Void): ...
    @T0.setter
    def T0(self, value: System.Void): ...
    @T1.setter
    def T1(self, value: System.Void): ...
    @overload
    def Swap() -> None: ...
    @overload
    def ToString() -> str: ...

class Point2d(System.ValueType):
    """Represents the two coordinates of a point in two-dimensional space, using
-precision floating point numbers.

    """
    @overload
    def __init__(self, vector: Vector2d): ...
    @overload
    def __init__(self, point: Point2d): ...
    @overload
    def __init__(self, point: Point3d): ...
    @overload
    def __init__(self, x: float, y: float): ...
    @overload
    @staticmethod
    def Add(point1: Point2d, point2: Point2d) -> Point2d: ...
    @overload
    @staticmethod
    def Add(vector: Vector2d, point: Point2d) -> Point2d: ...
    @overload
    @staticmethod
    def Add(point: Point2d, vector: Vector2d) -> Point2d: ...
    @overload
    def CompareTo(self, other: Point2d) -> int: ...
    @overload
    def DistanceTo(self, other: Point2d) -> float: ...
    @overload
    def DistanceToSquared(self, other: Point2d) -> float: ...
    @overload
    @staticmethod
    def Divide(point: Point2d, t: float) -> Point2d: ...
    @overload
    def EpsilonEquals(self, other: Point2d, epsilon: float) -> bool: ...
    @overload
    def Equals(self, point: Point2d) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Item(self) -> float: ...
    @property
    def MaximumCoordinate(self) -> float: ...
    @property
    def MinimumCoordinate(self) -> float: ...
    @property
    def Origin(self) -> Point2d: ...
    @property
    def Unset(self) -> Point2d: ...
    @property
    def X(self) -> float: ...
    @property
    def Y(self) -> float: ...
    @overload
    def GetHashCode() -> int: ...
    @overload
    @staticmethod
    def Multiply(point: Point2d, t: float) -> Point2d: ...
    @overload
    @staticmethod
    def Multiply(t: float, point: Point2d) -> Point2d: ...
    @Item.setter
    def Item(self, value: System.Void): ...
    @X.setter
    def X(self, value: System.Void): ...
    @Y.setter
    def Y(self, value: System.Void): ...
    @overload
    @staticmethod
    def Subtract(point: Point2d, vector: Vector2d) -> Point2d: ...
    @overload
    @staticmethod
    def Subtract(point1: Point2d, point2: Point2d) -> Vector2d: ...
    @overload
    def ToString() -> str: ...
    @overload
    def ToString(self, format_: str, formatProvider: System.IFormatProvider) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> None: ...

class Point3d(System.ValueType):
    """Represents the three coordinates of a point in three-dimensional space, using
-precision floating point values.

    """
    @overload
    def __init__(self, vector: Vector3d): ...
    @overload
    def __init__(self, point: Point3f): ...
    @overload
    def __init__(self, point: Point3d): ...
    @overload
    def __init__(self, point: Point4d): ...
    @overload
    def __init__(self, x: float, y: float, z: float): ...
    @overload
    @staticmethod
    def Add(point: Point3d, vector: Vector3d) -> Point3d: ...
    @overload
    @staticmethod
    def Add(vector: Vector3d, point: Point3d) -> Point3d: ...
    @overload
    @staticmethod
    def Add(point1: Point3d, point2: Point3d) -> Point3d: ...
    @overload
    @staticmethod
    def Add(point: Point3d, vector: Vector3f) -> Point3d: ...
    @overload
    @staticmethod
    def ArePointsCoplanar(points: Generic.IEnumerable, tolerance: float) -> bool: ...
    @overload
    def CompareTo(self, other: Point3d) -> int: ...
    @overload
    @staticmethod
    def CullDuplicates(points: Generic.IEnumerable, tolerance: float) -> System.Array[Point3d]: ...
    @overload
    def DistanceTo(self, other: Point3d) -> float: ...
    @overload
    def DistanceToSquared(self, other: Point3d) -> float: ...
    @overload
    @staticmethod
    def Divide(point: Point3d, t: float) -> Point3d: ...
    @overload
    def EpsilonEquals(self, other: Point3d, epsilon: float) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Equals(self, point: Point3d) -> bool: ...
    @overload
    @staticmethod
    def FromPoint3f(point: Point3f) -> Point3d: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Item(self) -> float: ...
    @property
    def MaximumCoordinate(self) -> float: ...
    @property
    def MinimumCoordinate(self) -> float: ...
    @property
    def Origin(self) -> Point3d: ...
    @property
    def Unset(self) -> Point3d: ...
    @property
    def X(self) -> float: ...
    @property
    def Y(self) -> float: ...
    @property
    def Z(self) -> float: ...
    @overload
    def GetHashCode() -> int: ...
    @overload
    def Interpolate(self, pA: Point3d, pB: Point3d, t: float) -> None: ...
    @overload
    @staticmethod
    def Multiply(t: float, point: Point3d) -> Point3d: ...
    @overload
    @staticmethod
    def Multiply(point: Point3d, t: float) -> Point3d: ...
    @Item.setter
    def Item(self, value: System.Void): ...
    @X.setter
    def X(self, value: System.Void): ...
    @Y.setter
    def Y(self, value: System.Void): ...
    @Z.setter
    def Z(self, value: System.Void): ...
    @overload
    @staticmethod
    def SortAndCullPointList(points: Generic.IEnumerable, minimumDistance: float) -> System.Array[Point3d]: ...
    @overload
    @staticmethod
    def Subtract(point1: Point3d, point2: Point3d) -> Vector3d: ...
    @overload
    @staticmethod
    def Subtract(point: Point3d, vector: Vector3d) -> Point3d: ...
    @overload
    def ToString() -> str: ...
    @overload
    def ToString(self, format_: str, formatProvider: System.IFormatProvider) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> None: ...
    @overload
    @staticmethod
    def TryParse(input_: str) -> (bool, Point3d): ...

class Point4d(System.ValueType):
    """Represents the four coordinates of a point in four-dimensional space.
The W (fourth) dimension is often considered the weight of the point as seen in 3D space.

    """
    @overload
    def __init__(self, point: Point3d): ...
    @overload
    def __init__(self, point: Point4d): ...
    @overload
    def __init__(self, x: float, y: float, z: float, w: float): ...
    @overload
    @staticmethod
    def Add(point1: Point4d, point2: Point4d) -> Point4d: ...
    @overload
    def EpsilonEquals(self, other: Point4d, epsilon: float) -> bool: ...
    @overload
    def Equals(self, point: Point4d) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Unset(self) -> Point4d: ...
    @property
    def W(self) -> float: ...
    @property
    def X(self) -> float: ...
    @property
    def Y(self) -> float: ...
    @property
    def Z(self) -> float: ...
    @overload
    def GetHashCode() -> int: ...
    @overload
    @staticmethod
    def Multiply(point: Point4d, d: float) -> Point4d: ...
    @W.setter
    def W(self, value: System.Void): ...
    @X.setter
    def X(self, value: System.Void): ...
    @Y.setter
    def Y(self, value: System.Void): ...
    @Z.setter
    def Z(self, value: System.Void): ...
    @overload
    @staticmethod
    def Subtract(point1: Point4d, point2: Point4d) -> Point4d: ...
    @overload
    def ToString() -> str: ...
    @overload
    def ToString(self, format_: str, formatProvider: System.IFormatProvider) -> str: ...
    @overload
    def Transform(self, xform: Transform) -> None: ...

class Vector2d(System.ValueType):
    """Represents the two components of a vector in two-dimensional space, using
-precision floating point numbers.

    """
    def __init__(self, x: float, y: float): ...
    @overload
    @staticmethod
    def Add(vector1: Vector2d, vector2: Vector2d) -> Vector2d: ...
    @overload
    def CompareTo(self, other: Vector2d) -> int: ...
    @overload
    @staticmethod
    def Divide(vector: Vector2d, t: float) -> Vector2d: ...
    @overload
    def EpsilonEquals(self, other: Vector2d, epsilon: float) -> bool: ...
    @overload
    def Equals(self, vector: Vector2d) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def Length(self) -> float: ...
    @property
    def SquareLength(self) -> float: ...
    @property
    def Unset(self) -> Vector2d: ...
    @property
    def X(self) -> float: ...
    @property
    def Y(self) -> float: ...
    @property
    def Zero(self) -> Vector2d: ...
    @overload
    def GetHashCode() -> int: ...
    @overload
    def IsTiny() -> bool: ...
    @overload
    def IsTiny(self, tolerance: float) -> bool: ...
    @overload
    @staticmethod
    def Multiply(vector1: Vector2d, vector2: Vector2d) -> float: ...
    @overload
    @staticmethod
    def Multiply(vector: Vector2d, t: float) -> Vector2d: ...
    @overload
    @staticmethod
    def Multiply(t: float, vector: Vector2d) -> Vector2d: ...
    @overload
    @staticmethod
    def Negate(vector: Vector2d) -> Vector2d: ...
    @overload
    def Rotate(self, angleRadians: float) -> bool: ...
    @X.setter
    def X(self, value: System.Void): ...
    @Y.setter
    def Y(self, value: System.Void): ...
    @overload
    @staticmethod
    def Subtract(vector1: Vector2d, vector2: Vector2d) -> Vector2d: ...
    @overload
    def ToString() -> str: ...
    @overload
    def ToString(self, format_: str, formatProvider: System.IFormatProvider) -> str: ...
    @overload
    def Unitize() -> bool: ...

class Vector3d(System.ValueType):
    """Represents the three components of a vector in three-dimensional space, using
-precision floating point numbers.

    """
    @overload
    def __init__(self, point: Point3d): ...
    @overload
    def __init__(self, vector: Vector3f): ...
    @overload
    def __init__(self, vector: Vector3d): ...
    @overload
    def __init__(self, x: float, y: float, z: float): ...
    @overload
    @staticmethod
    def Add(vector1: Vector3d, vector2: Vector3d) -> Vector3d: ...
    @overload
    @staticmethod
    def AreOrthogonal(x: Vector3d, y: Vector3d, z: Vector3d) -> bool: ...
    @overload
    @staticmethod
    def AreOrthonormal(x: Vector3d, y: Vector3d, z: Vector3d) -> bool: ...
    @overload
    @staticmethod
    def AreRighthanded(x: Vector3d, y: Vector3d, z: Vector3d) -> bool: ...
    @overload
    def CompareTo(self, other: Vector3d) -> int: ...
    @overload
    @staticmethod
    def CrossProduct(a: Vector3d, b: Vector3d) -> Vector3d: ...
    @overload
    @staticmethod
    def Divide(vector: Vector3d, t: float) -> Vector3d: ...
    @overload
    def EpsilonEquals(self, other: Vector3d, epsilon: float) -> bool: ...
    @overload
    def Equals(self, vector: Vector3d) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def IsUnitVector(self) -> bool: ...
    @property
    def IsValid(self) -> bool: ...
    @property
    def IsZero(self) -> bool: ...
    @property
    def Item(self) -> float: ...
    @property
    def Length(self) -> float: ...
    @property
    def MaximumCoordinate(self) -> float: ...
    @property
    def MinimumCoordinate(self) -> float: ...
    @property
    def SquareLength(self) -> float: ...
    @property
    def Unset(self) -> Vector3d: ...
    @property
    def X(self) -> float: ...
    @property
    def XAxis(self) -> Vector3d: ...
    @property
    def Y(self) -> float: ...
    @property
    def YAxis(self) -> Vector3d: ...
    @property
    def Z(self) -> float: ...
    @property
    def ZAxis(self) -> Vector3d: ...
    @property
    def Zero(self) -> Vector3d: ...
    @overload
    def GetHashCode() -> int: ...
    @overload
    def IsParallelTo(self, other: Vector3d) -> int: ...
    @overload
    def IsParallelTo(self, other: Vector3d, angleTolerance: float) -> int: ...
    @overload
    def IsPerpendicularTo(self, other: Vector3d) -> bool: ...
    @overload
    def IsPerpendicularTo(self, other: Vector3d, angleTolerance: float) -> bool: ...
    @overload
    def IsTiny() -> bool: ...
    @overload
    def IsTiny(self, tolerance: float) -> bool: ...
    @overload
    @staticmethod
    def Multiply(vector: Vector3d, t: float) -> Vector3d: ...
    @overload
    @staticmethod
    def Multiply(t: float, vector: Vector3d) -> Vector3d: ...
    @overload
    @staticmethod
    def Multiply(vector1: Vector3d, vector2: Vector3d) -> float: ...
    @overload
    @staticmethod
    def Negate(vector: Vector3d) -> Vector3d: ...
    @overload
    def PerpendicularTo(self, other: Vector3d) -> bool: ...
    @overload
    def PerpendicularTo(self, point0: Point3d, point1: Point3d, point2: Point3d) -> bool: ...
    @overload
    def Reverse() -> bool: ...
    @overload
    def Rotate(self, angleRadians: float, rotationAxis: Vector3d) -> bool: ...
    @Item.setter
    def Item(self, value: System.Void): ...
    @X.setter
    def X(self, value: System.Void): ...
    @Y.setter
    def Y(self, value: System.Void): ...
    @Z.setter
    def Z(self, value: System.Void): ...
    @overload
    @staticmethod
    def Subtract(vector1: Vector3d, vector2: Vector3d) -> Vector3d: ...
    @overload
    def ToString() -> str: ...
    @overload
    def ToString(self, format_: str, formatProvider: System.IFormatProvider) -> str: ...
    @overload
    def Transform(self, transformation: Transform) -> None: ...
    @overload
    def Unitize() -> bool: ...
    @overload
    @staticmethod
    def VectorAngle(a: Vector3d, b: Vector3d) -> float: ...
    @overload
    @staticmethod
    def VectorAngle(v1: Vector3d, v2: Vector3d, vNormal: Vector3d) -> float: ...
    @overload
    @staticmethod
    def VectorAngle(a: Vector3d, b: Vector3d, plane: Plane) -> float: ...

class Ray3d(System.ValueType):
    """Represents an immutable ray in three dimensions, using position and direction.

    """
    def __init__(self, position: Point3d, direction: Vector3d): ...
    @overload
    def EpsilonEquals(self, other: Ray3d, epsilon: float) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @overload
    def Equals(self, ray: Ray3d) -> bool: ...
    @property
    def Direction(self) -> Vector3d: ...
    @property
    def Position(self) -> Point3d: ...
    @overload
    def GetHashCode() -> int: ...
    @overload
    def PointAt(self, t: float) -> Point3d: ...

class Continuity(enum.Enum):
    None_ = 0
    C0_continuous = 1
    C1_continuous = 2
    C2_continuous = 3
    G1_continuous = 4
    G2_continuous = 5
    C0_locus_continuous = 6
    C1_locus_continuous = 7
    C2_locus_continuous = 8
    G1_locus_continuous = 9
    G2_locus_continuous = 10
    Cinfinity_continuous = 11
    Gsmooth_continuous = 12

class MeshType(enum.Enum):
    Default = 0
    Render = 1
    Analysis = 2
    Preview = 3
    Any = 4

class LightStyle(enum.Enum):
    None_ = 0
    CameraDirectional = 4
    CameraPoint = 5
    CameraSpot = 6
    WorldDirectional = 7
    WorldPoint = 8
    WorldSpot = 9
    Ambient = 10
    WorldLinear = 11
    WorldRectangular = 12

class ComponentIndexType(enum.Enum):
    InvalidType = 0
    BrepVertex = 1
    BrepEdge = 2
    BrepFace = 3
    BrepTrim = 4
    BrepLoop = 5
    MeshVertex = 11
    MeshTopologyVertex = 12
    MeshTopologyEdge = 13
    MeshFace = 14
    MeshNgon = 15
    InstanceDefinitionPart = 21
    PolycurveSegment = 31
    PointCloudPoint = 41
    GroupMember = 51
    ExtrusionBottomProfile = 61
    ExtrusionTopProfile = 62
    ExtrusionWallEdge = 63
    ExtrusionWallSurface = 64
    ExtrusionCapSurface = 65
    ExtrusionPath = 66
    SubdVertex = 71
    SubdEdge = 72
    SubdFace = 73
    DimLinearPoint = 100
    DimRadialPoint = 101
    DimAngularPoint = 102
    DimOrdinatePoint = 103
    DimTextPoint = 104
    NoType = 268435455

class ComponentIndex(System.ValueType):
    """Represents an index of an element contained in another object.

    """
    def __init__(self, type_: ComponentIndexType, index: int): ...
    @overload
    def CompareTo(self, other: ComponentIndex) -> int: ...
    @overload
    def Equals(self, other: ComponentIndex) -> bool: ...
    @overload
    def Equals(self, obj: object) -> bool: ...
    @property
    def ComponentIndexType(self) -> ComponentIndexType: ...
    @property
    def Index(self) -> int: ...
    @property
    def Unset(self) -> ComponentIndex: ...
    @overload
    def GetHashCode() -> int: ...
    @overload
    def IsUnset() -> bool: ...

class SurfaceFilletBase(object):
    """New interactive FilletSrf

    """
    @overload
    @staticmethod
    def CreateG2ChordalQuinticFilletSrf(faceA: BrepFace, uvA: Point2d, faceB: BrepFace, uvB: Point2d, radius: float, tolerance: float, trimmedBrepsA: Generic.List, trimmedBrepsB: Generic.List, rail_degree: int, bTrim: bool, bExtend: bool, Fillets: Generic.List) -> bool: ...
    @overload
    @staticmethod
    def CreateNonRationalCubicArcsFilletSrf(faceA: BrepFace, uvA: Point2d, faceB: BrepFace, uvB: Point2d, radius: float, tolerance: float, trimmedBrepsA: Generic.List, trimmedBrepsB: Generic.List, rail_degree: int, bTrim: bool, bExtend: bool, Fillets: Generic.List) -> bool: ...
    @overload
    @staticmethod
    def CreateNonRationalCubicFilletSrf(faceA: BrepFace, uvA: Point2d, faceB: BrepFace, uvB: Point2d, radius: float, tolerance: float, trimmedBrepsA: Generic.List, trimmedBrepsB: Generic.List, rail_degree: int, TanSlider: float, bTrim: bool, bExtend: bool, Fillets: Generic.List) -> bool: ...
    @overload
    @staticmethod
    def CreateNonRationalQuarticArcsFilletSrf(faceA: BrepFace, uvA: Point2d, faceB: BrepFace, uvB: Point2d, radius: float, tolerance: float, trimmedBrepsA: Generic.List, trimmedBrepsB: Generic.List, rail_degree: int, bTrim: bool, bExtend: bool, Fillets: Generic.List) -> bool: ...
    @overload
    @staticmethod
    def CreateNonRationalQuarticFilletSrf(faceA: BrepFace, uvA: Point2d, faceB: BrepFace, uvB: Point2d, radius: float, tolerance: float, trimmedBrepsA: Generic.List, trimmedBrepsB: Generic.List, rail_degree: int, TanSlider: float, InnerSlider: float, bTrim: bool, bExtend: bool, Fillets: Generic.List) -> bool: ...
    @overload
    @staticmethod
    def CreateNonRationalQuinticArcsFilletSrf(faceA: BrepFace, uvA: Point2d, faceB: BrepFace, uvB: Point2d, radius: float, tolerance: float, trimmedBrepsA: Generic.List, trimmedBrepsB: Generic.List, rail_degree: int, bTrim: bool, bExtend: bool, Fillets: Generic.List) -> bool: ...
    @overload
    @staticmethod
    def CreateNonRationalQuinticFilletSrf(faceA: BrepFace, uvA: Point2d, faceB: BrepFace, uvB: Point2d, radius: float, tolerance: float, trimmedBrepsA: Generic.List, trimmedBrepsB: Generic.List, rail_degree: int, TanSlider: float, InnerSlider: float, bTrim: bool, bExtend: bool, Fillets: Generic.List) -> bool: ...
    @overload
    @staticmethod
    def CreateRationalArcsFilletSrf(faceA: BrepFace, uvA: Point2d, faceB: BrepFace, uvB: Point2d, radius: float, tolerance: float, trimmedBrepsA: Generic.List, trimmedBrepsB: Generic.List, rail_degree: int, bTrim: bool, bExtend: bool, Fillets: Generic.List) -> bool: ...
    @overload
    def Dispose() -> None: ...
    @overload
    def G2ChordalQuintic(self, railDegree: int, bExtend: bool, Fillets: Generic.List) -> bool: ...
    @overload
    def IsInitialized() -> bool: ...
    @overload
    def NonRationalCubic(self, railDegree: int, TanSlider: float, bExtend: bool, Fillets: Generic.List) -> bool: ...
    @overload
    def NonRationalCubicArcs(self, railDegree: int, bExtend: bool, Fillets: Generic.List) -> bool: ...
    @overload
    def NonRationalQuartic(self, railDegree: int, TanSlider: float, InnerSlider: float, bExtend: bool, Fillets: Generic.List) -> bool: ...
    @overload
    def NonRationalQuarticArcs(self, railDegree: int, bExtend: bool, Fillets: Generic.List) -> bool: ...
    @overload
    def NonRationalQuintic(self, railDegree: int, TanSlider: float, InnerSlider: float, bExtend: bool, Fillets: Generic.List) -> bool: ...
    @overload
    def NonRationalQuinticArcs(self, railDegree: int, bExtend: bool, Fillets: Generic.List) -> bool: ...
    @overload
    def RationalArcs(self, railDegree: int, bExtend: bool, Fillets: Generic.List) -> bool: ...
    @overload
    def TrimBreps(self, bExtend: bool, TrimmedBreps0: Generic.List, TrimmedBreps1: Generic.List) -> bool: ...

class SweepOneRail(object):
    """Utility class for generating Breps by sweeping cross section curves over a single rail curve. Note, this class has been superseded by the Rhino.Geometry.Brep.CreateFromSweep static functions.

    """
    def __init__(self): ...
    @property
    def AngleToleranceRadians(self) -> float: ...
    @property
    def ClosedSweep(self) -> bool: ...
    @property
    def GlobalShapeBlending(self) -> bool: ...
    @property
    def IsFreeform(self) -> bool: ...
    @property
    def IsRoadlike(self) -> bool: ...
    @property
    def IsRoadlikeFront(self) -> bool: ...
    @property
    def IsRoadlikeTop(self) -> bool: ...
    @property
    def IsRoadlineRight(self) -> bool: ...
    @property
    def MiterType(self) -> int: ...
    @property
    def SweepTolerance(self) -> float: ...
    @overload
    def PerformSweep(self, rail: Curve, crossSections: Generic.IEnumerable) -> System.Array[Brep]: ...
    @overload
    def PerformSweep(self, rail: Curve, crossSection: Curve) -> System.Array[Brep]: ...
    @overload
    def PerformSweep(self, rail: Curve, crossSection: Curve, crossSectionParameter: float) -> System.Array[Brep]: ...
    @overload
    def PerformSweep(self, rail: Curve, crossSections: Generic.IEnumerable, crossSectionParameters: Generic.IEnumerable) -> System.Array[Brep]: ...
    @overload
    def PerformSweepRebuild(self, rail: Curve, crossSections: Generic.IEnumerable, rebuildCount: int) -> System.Array[Brep]: ...
    @overload
    def PerformSweepRebuild(self, rail: Curve, crossSection: Curve, rebuildCount: int) -> System.Array[Brep]: ...
    @overload
    def PerformSweepRebuild(self, rail: Curve, crossSections: Generic.IEnumerable, crossSectionParameters: Generic.IEnumerable, rebuildCount: int) -> System.Array[Brep]: ...
    @overload
    def PerformSweepRebuild(self, rail: Curve, crossSection: Curve, crossSectionParameter: float, rebuildCount: int) -> System.Array[Brep]: ...
    @overload
    def PerformSweepRefit(self, rail: Curve, crossSection: Curve, refitTolerance: float) -> System.Array[Brep]: ...
    @overload
    def PerformSweepRefit(self, rail: Curve, crossSections: Generic.IEnumerable, refitTolerance: float) -> System.Array[Brep]: ...
    @overload
    def PerformSweepRefit(self, rail: Curve, crossSection: Curve, crossSectionParameter: float, refitTolerance: float) -> System.Array[Brep]: ...
    @overload
    def PerformSweepRefit(self, rail: Curve, crossSections: Generic.IEnumerable, crossSectionParameters: Generic.IEnumerable, refitTolerance: float) -> System.Array[Brep]: ...
    @AngleToleranceRadians.setter
    def AngleToleranceRadians(self, value: System.Void): ...
    @ClosedSweep.setter
    def ClosedSweep(self, value: System.Void): ...
    @GlobalShapeBlending.setter
    def GlobalShapeBlending(self, value: System.Void): ...
    @MiterType.setter
    def MiterType(self, value: System.Void): ...
    @SweepTolerance.setter
    def SweepTolerance(self, value: System.Void): ...
    @overload
    def SetRoadlikeUpDirection(self, up: Vector3d) -> None: ...
    @overload
    def SetToRoadlikeFront() -> None: ...
    @overload
    def SetToRoadlikeRight() -> None: ...
    @overload
    def SetToRoadlikeTop() -> None: ...

class SweepTwoRail(object):
    """Utility class for generating Breps by sweeping cross section curves over two rail curves. Note, this class has been superseded by the Rhino.Geometry.Brep.CreateFromSweep static functions.

    """
    def __init__(self): ...
    @property
    def AngleToleranceRadians(self) -> float: ...
    @property
    def AutoAdjust(self) -> bool: ...
    @property
    def ClosedSweep(self) -> bool: ...
    @property
    def MaintainHeight(self) -> bool: ...
    @property
    def SweepTolerance(self) -> float: ...
    @property
    def UseLegacySweeper(self) -> bool: ...
    @overload
    def PerformSweep(self, rail1: Curve, rail2: Curve, crossSection: Curve) -> System.Array[Brep]: ...
    @overload
    def PerformSweep(self, rail1: Curve, rail2: Curve, crossSections: Generic.IEnumerable) -> System.Array[Brep]: ...
    @overload
    def PerformSweep(self, rail1: Curve, rail2: Curve, crossSection: Curve, crossSectionParameterRail1: float, crossSectionParameterRail2: float) -> System.Array[Brep]: ...
    @overload
    def PerformSweep(self, rail1: Curve, rail2: Curve, crossSections: Generic.IEnumerable, crossSectionParameters1: Generic.IEnumerable, crossSectionParameters2: Generic.IEnumerable) -> System.Array[Brep]: ...
    @overload
    def PerformSweepRebuild(self, rail1: Curve, rail2: Curve, crossSections: Generic.IEnumerable, rebuildCount: int) -> System.Array[Brep]: ...
    @overload
    def PerformSweepRebuild(self, rail1: Curve, rail2: Curve, crossSection: Curve, rebuildCount: int) -> System.Array[Brep]: ...
    @overload
    def PerformSweepRebuild(self, rail1: Curve, rail2: Curve, crossSections: Generic.IEnumerable, crossSectionParametersRail1: Generic.IEnumerable, crossSectionParametersRail2: Generic.IEnumerable, rebuildCount: int) -> System.Array[Brep]: ...
    @overload
    def PerformSweepRebuild(self, rail1: Curve, rail2: Curve, crossSection: Curve, crossSectionParameterRail1: float, crossSectionParameterRail2: float, rebuildCount: int) -> System.Array[Brep]: ...
    @overload
    def PerformSweepRefit(self, rail1: Curve, rail2: Curve, crossSection: Curve, refitTolerance: float) -> System.Array[Brep]: ...
    @overload
    def PerformSweepRefit(self, rail1: Curve, rail2: Curve, crossSections: Generic.IEnumerable, refitTolerance: float) -> System.Array[Brep]: ...
    @overload
    def PerformSweepRefit(self, rail1: Curve, rail2: Curve, crossSection: Curve, crossSectionParameterRail1: float, crossSectionParameterRail2: float, refitTolerance: float) -> System.Array[Brep]: ...
    @overload
    def PerformSweepRefit(self, rail1: Curve, rail2: Curve, crossSections: Generic.IEnumerable, crossSectionParametersRail1: Generic.IEnumerable, crossSectionParametersRail2: Generic.IEnumerable, refitTolerance: float) -> System.Array[Brep]: ...
    @AngleToleranceRadians.setter
    def AngleToleranceRadians(self, value: System.Void): ...
    @AutoAdjust.setter
    def AutoAdjust(self, value: System.Void): ...
    @ClosedSweep.setter
    def ClosedSweep(self, value: System.Void): ...
    @MaintainHeight.setter
    def MaintainHeight(self, value: System.Void): ...
    @SweepTolerance.setter
    def SweepTolerance(self, value: System.Void): ...
    @UseLegacySweeper.setter
    def UseLegacySweeper(self, value: System.Void): ...

class Unroller(object):
    """Represents the operation of unrolling a single surface.

    """
    @overload
    def __init__(self, surface: Surface): ...
    @overload
    def __init__(self, brep: Brep): ...
    @overload
    def AddFollowingGeometry(self, curves: Generic.IEnumerable) -> None: ...
    @overload
    def AddFollowingGeometry(self, curve: Curve) -> None: ...
    @overload
    def AddFollowingGeometry(self, points: Generic.IEnumerable) -> None: ...
    @overload
    def AddFollowingGeometry(self, point: Point3d) -> None: ...
    @overload
    def AddFollowingGeometry(self, point: Point) -> None: ...
    @overload
    def AddFollowingGeometry(self, dots: Generic.IEnumerable) -> None: ...
    @overload
    def AddFollowingGeometry(self, dot: TextDot) -> None: ...
    @overload
    def AddFollowingGeometry(self, dotLocations: Generic.IEnumerable, dotText: Generic.IEnumerable) -> None: ...
    @overload
    def AddFollowingGeometry(self, dotLocation: Point3d, dotText: str) -> None: ...
    @overload
    def FollowingGeometryIndex(self, curve: Curve) -> int: ...
    @overload
    def FollowingGeometryIndex(self, dot: TextDot) -> int: ...
    @property
    def AbsoluteTolerance(self) -> float: ...
    @property
    def ExplodeOutput(self) -> bool: ...
    @property
    def ExplodeSpacing(self) -> float: ...
    @property
    def RelativeTolerance(self) -> float: ...
    @overload
    def PerformUnroll(self, flatbreps: Generic.List) -> int: ...
    @overload
    def PerformUnroll() -> (System.Array[Brep], System.Array[Curve], System.Array[Point3d], System.Array[TextDot]): ...
    @AbsoluteTolerance.setter
    def AbsoluteTolerance(self, value: System.Void): ...
    @ExplodeOutput.setter
    def ExplodeOutput(self, value: System.Void): ...
    @ExplodeSpacing.setter
    def ExplodeSpacing(self, value: System.Void): ...
    @RelativeTolerance.setter
    def RelativeTolerance(self, value: System.Void): ...

class DevelopableSrf(object):
    """Helpers for developable surface functions

    """
    def __init__(self): ...
    @overload
    @staticmethod
    def GetLocalDevopableRuling(rail0: NurbsCurve, t0: float, dom0: Interval, rail1: NurbsCurve, t1: float, dom1: Interval) -> (int, float, float): ...
    @overload
    @staticmethod
    def RulingMinTwist(rail0: NurbsCurve, t0: float, rail1: NurbsCurve, t1: float, dom1: Interval) -> (bool, float, float): ...
    @overload
    @staticmethod
    def RulingMinTwist(rail0: NurbsCurve, t0: float, dom0: Interval, rail1: NurbsCurve, t1: float, dom1: Interval) -> (bool, float, float, float): ...
    @overload
    @staticmethod
    def UntwistRulings(rail0: NurbsCurve, rail1: NurbsCurve) -> (bool, Generic.IEnumerable): ...

class ForceArrow(enum.Enum):
    Auto = 0
    Inside = 1
    Outside = 2

class ForceText(enum.Enum):
    Auto = 0
    Inside = 1
    Right = 2
    Left = 3
    HintRight = 4
    HintLeft = 5

class MeasuredDirection(enum.Enum):
    Unset = 0
    Xaxis = 1
    Yaxis = 2

class ExtraordinaryVertexProcessOption(enum.Enum):
    None_ = 0
    LocalG1 = 1
    LocalG2 = 2
    LocalG1x = 3
    LocalG1xx = 4

class NurbsSurfaceType(enum.Enum):
    Unset = 0
    Large = 1
    Medium = 2
    Small = 3
    Unprocessed = 4

class InteriorCreaseOption(enum.Enum):
    Unset = 0
    None_ = 1
    AtMeshDoubleEdge = 2

class ConvexCornerOption(enum.Enum):
    Unset = 0
    None_ = 1
    AtMeshCorner = 2

class ConcaveCornerOption(enum.Enum):
    Unset = 0
    None_ = 1
    AtMeshCorner = 2

class TextureCoordinateOption(enum.Enum):
    Unset = 0
    None_ = 1
    Automatic = 2
    Packed = 3
    CopyMapping = 4
    CopyCoordinates = 5

class MaximumCounts(enum.Enum):
    MaximumRecommendedInterpolatedVertexCount = 1000

class ShrinkDisableSide(enum.Enum):
    ShrinkAllSides = 0
    DoNotShrinkWestSide = 1
    DoNotShrinkSouthSide = 2
    DoNotShrinkEastSide = 4
    DoNotShrinkNorthSide = 8

class Visibility(enum.Enum):
    Unset = 0
    Visible = 1
    Hidden = 2
    Duplicate = 3

class Visibility(enum.Enum):
    Unset = 0
    Visible = 1
    Hidden = 2
    Duplicate = 3
    Projecting = 4
    Clipped = 5

class SideFill(enum.Enum):
    SideUnset = 0
    SideSurface = 1
    SideVoid = 2
    OtherSurface = 3

class Attenuation(enum.Enum):
    Constant = 0
    Linear = 1
    InverseSquared = 2

class Density(enum.Enum):
    UnsetDensity = 0
    MinimumDensity = 0
    ExtraCoarseDensity = 1
    MinimumUserInterfaceDensity = 1
    MinimumAdaptiveDensity = 1
    CoarseDensity = 2
    MediumDensity = 3
    DefaultDensity = 4
    FineDensity = 4
    MaximumUserInterfaceDensity = 5
    ExtraFineDensity = 5
    MaximumDensity = 6

class NurbsCurveEndConditionType(enum.Enum):
    Nothing = 0
    Position = 1
    Tangency = 2
    Curvature = 3

# endregion
